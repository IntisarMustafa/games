<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ÿßŸÑÿ±ÿßÿπŸä ÿßŸÑÿ∞ŸÉŸä ŸàÿßŸÑÿÆÿ±ÿßŸÅ ÿßŸÑÿ∂ÿßÿ¶ÿπÿ©</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet" />
    <script>

        // Reusable objects for performance optimization
        const _v1 = new THREE.Vector3();
        const _v2 = new THREE.Vector3();
        const _sphere = new THREE.Sphere();
        const _box = new THREE.Box3();
    
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$']],
                processEscapes: true
            },
            options: {
                enableMenu: false
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Cairo", sans-serif;
        }
        body, html {
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FF);
            color: #1a1a2e;
            height: 100%;
            width: 100%;
            cursor: grab;
        }
        body.dragging, html.dragging {
            cursor: grabbing;
        }
        body {
            touch-action: none;
        }
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            z-index: 300;
        }
        .start-screen-content {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            animation: fadeInScale 0.7s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        .start-screen h1 {
            color: #4caf50;
            font-size: 40px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #4caf50;
        }
        .start-screen h2 {
            color: #8bc34a;
            margin-top: 30px;
            margin-bottom: 10px;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 5px;
            font-size: 24px;
        }
        .start-screen p {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: center;
        }
        .start-btn {
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 15px 35px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            margin: 20px 0;
        }
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
            align-items: center;
            justify-content: center;
        }
        .info-panel {
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            opacity: 0.95;
            display: none;
        }
        .scene-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            height: 100%;
            width: 100%;
        }
        #gameScene {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 10px;
            color: white;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4caf50;
        }
        .stat-label {
            font-size: 12px;
            opacity: 0.8;
        }
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
            pointer-events: none;
            max-width: 400px;
            display: none;
            color: white;
        }
        .title {
            font-size: 24px;
            margin-bottom: 10px;
            color: #4caf50;
            text-align: center;
        }
        .subtitle {
            font-size: 16px;
            opacity: 0.8;
            text-align: center;
        }
        .game-ui {
            position: absolute;
            bottom: 200px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }
        .ui-button {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .charge-btn {
            background: linear-gradient(to bottom, #ff5722, #ff9800);
            box-shadow: 0 4px 10px rgba(255, 87, 34, 0.5);
            transition: transform 0.1s ease, box-shadow 0.3s ease;
        }
        .ui-button:active {
            background: rgba(76, 175, 80, 0.5);
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        .score-display {
            position: absolute;
            top: 50px;
            right: 20px;
            font-size: 24px;
            color: #2e7d32;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .coins-display {
            position: absolute;
            top: 85px;
            right: 20px;
            font-size: 20px;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .leaderboard-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; z-index: 500; overflow-y: auto; backdrop-filter: blur(5px); }
        .leaderboard-modal.active { display: flex; align-items: center; justify-content: center; }
        .leaderboard-content { background: white; border-radius: 20px; padding: 30px; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); animation: slideUp 0.5s ease-out; position: relative; }
        @keyframes slideUp { from { opacity: 0; transform: translateY(50px); } to { opacity: 1; transform: translateY(0); } }
        .leaderboard-header { text-align: center; margin-bottom: 30px; border-bottom: 3px solid #667eea; padding-bottom: 20px; }
        .leaderboard-header h2 { font-size: 32px; color: #667eea; margin-bottom: 10px; }
        .leaderboard-header p { color: #666; font-size: 14px; }
        .leaderboard-table { width: 100%; border-collapse: collapse; }
        .leaderboard-table th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; text-align: right; font-weight: bold; }
        .leaderboard-table td { padding: 12px 15px; border-bottom: 1px solid #eee; text-align: right; }
        .leaderboard-table tr:hover { background: #f5f5f5; }
        .leaderboard-table tr:nth-child(1) { background: rgba(255,215,0,0.1); }
        .leaderboard-table tr:nth-child(2) { background: rgba(192,192,192,0.1); }
        .leaderboard-table tr:nth-child(3) { background: rgba(205,127,50,0.1); }
        .leaderboard-close { position: absolute; top: 20px; right: 20px; background: #667eea; color: white; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 24px; cursor: pointer; transition: all 0.3s ease; }
        .leaderboard-close:hover { background: #764ba2; transform: scale(1.1); }
        .leaderboard-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 30px; }
        .stat-item { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 10px; text-align: center; }
        .stat-label { font-size: 12px; opacity: 0.8; margin-bottom: 5px; }
        .stat-value { font-size: 24px; font-weight: bold; }
        .sheep-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #ffffff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
        }
        .health-indicator {
            position: absolute;
            top: 155px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }
        .health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s ease;
        }
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            z-index: 9999;
            display: none;
            color: white;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 0 30px rgba(0,0,0,1);
            border: 2px solid #4caf50;
        }
        .toxic-water-alert {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            animation: pulse 1s infinite;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            text-align: center;
            pointer-events: none;
        }
        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); }
        }
        .restart-btn {
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin-top: 20px;
        }
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        /* ÿ™ŸÜÿ≥ŸäŸÇÿßÿ™ ŸÑŸàÿ≠ÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ ÿßŸÑÿ¨ÿØŸäÿØÿ© */
        .leaderboard-container {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            max-height: 250px;
            overflow-y: auto;
            text-align: right;
            display: block !important;
            visibility: visible !important;
        }
        .leaderboard-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        .leaderboard-input {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #4caf50;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
            width: 100%;
        }
        .save-score-btn {
            background: #ffd700;
            color: #333;
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        .save-score-btn:hover {
            background: #ffc107;
        }
        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin-top: 10px;
        }
        .leaderboard-item {
            background: rgba(255, 255, 255, 0.15);
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            border-right: 4px solid #4caf50;
        }
        .leaderboard-item span {
            display: inline-block;
        }
        /* ÿ£ŸÜŸÖÿßÿ∑ ÿ≤ÿ± ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸàŸÜÿßŸÅÿ∞ÿ© ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ - ŸÖŸÜŸáÿßÿ¨ ÿßŸÑÿµŸÅ ÿßŸÑÿ≥ÿßÿ®ÿπ ÿßŸÑÿ£ÿ±ÿØŸÜŸä */
        .math-help-btn {
            position: absolute;
            bottom: 30px;
            left: 30px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            border-radius: 30px;
            display: none; /* ŸÖÿÆŸÅŸä ÿßŸÅÿ™ÿ±ÿßÿ∂ŸäÿßŸã ŸàŸäÿ∏Ÿáÿ± ÿπŸÜÿØ ŸÅÿ™ÿ≠ ÿßŸÑÿµŸÜÿØŸàŸÇ */
            justify-content: center;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 2px solid white;
            transition: all 0.3s ease;
            animation: slideInLeft 0.5s ease-out;
        }
        @keyframes slideInLeft {
            from { transform: translateX(-100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .math-help-btn:hover {
            transform: scale(1.1) rotate(2deg);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.5);
        }
        .math-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background: white;
            border-radius: 20px;
            padding: 25px;
            z-index: 2000;
            display: none;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            direction: rtl;
            max-height: 80vh;
            overflow-y: auto;
        }
        .math-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .math-modal-title {
            color: #1976D2;
            font-size: 22px;
            font-weight: bold;
        }
        .close-math-modal {
            font-size: 28px;
            cursor: pointer;
            color: #666;
        }
        .math-content-item {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-right: 5px solid #2196F3;
            border-radius: 5px;
        }
        .math-content-item h3 {
            color: #333;
            margin-bottom: 8px;
            font-size: 18px;
        }
        .math-content-item p {
            color: #555;
            line-height: 1.6;
            font-size: 15px;
        }
        .math-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 1999;
            display: none;
        }
        .movement-controls {
            position: absolute;
            bottom: 200px;
            left: 20px;
            z-index: 100;
        }
        .joystick-container {
            position: relative;
            width: 150px;
            height: 150px;
            touch-action: none;
        }
        .joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            touch-action: none;
        }
        .joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(76, 175, 80, 0.7);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            touch-action: none;
        }
        .joystick-handle.active {
            background: rgba(76, 175, 80, 0.9);
            transform: translate(-50%, -50%) scale(1.1);
        }
        .coin-animation {
            position: absolute;
            font-size: 24px;
            color: #ffd700;
            font-weight: bold;
            animation: coinFloat 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 90;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .laser-sight {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: transparent;
            border: 3px solid #ff5722;
            box-shadow: 0 0 15px rgba(255, 87, 34, 0.9);
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
            pointer-events: none;
            z-index: 90;
            display: none;
        }
        .round-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        .round-transition.active {
            opacity: 1;
            pointer-events: all;
        }
        .round-message {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            font-size: 32px;
            color: #4caf50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .question-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 250;
            display: none;
            color: white;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        .question-panel h2 {
            color: #4caf50;
            margin-bottom: 20px;
            font-size: 28px;
        }
        .question-panel p {
            font-size: 20px;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        .options-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .option-btn {
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        .option-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        .health-box-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
        }
        .health-box-icon {
            font-size: 50px;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: pulse 1.5s infinite ease-in-out;
        }
        .health-box-label {
            position: absolute;
            bottom: -30px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #00bfff;
            text-shadow: 0 0 5px rgba(0, 191, 255, 0.5);
            font-weight: bold;
        }
        .jump-btn {
            background: linear-gradient(to bottom, #2196f3, #0d47a1);
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.5);
        }
        .jump-effect {
            position: absolute;
            width: 50px;
            height: 10px;
            background: rgba(33, 150, 243, 0.5);
            border-radius: 50%;
            filter: blur(5px);
            z-index: 90;
            animation: jumpPulse 0.5s ease-out;
        }
        .laser-sight.sprinting {
            border-color: #9c27b0;
            box-shadow: 0 0 15px rgba(156, 39, 176, 0.9);
        }
        .stick-attack {
            position: absolute;
            width: 100px;
            height: 20px;
            background: linear-gradient(to right, #8b4513, #a0522d);
            border-radius: 10px;
            transform-origin: left center;
            z-index: 80;
            pointer-events: none;
            display: none;
        }
        .bomb-btn {
            background: linear-gradient(to bottom, #ff5722, #d32f2f);
            box-shadow: 0 4px 10px rgba(255, 87, 34, 0.5);
        }
        .bomb-btn.disabled {
            background: #888;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            cursor: not-allowed;
        }
        .bomb-btn.charging {
            animation: bombChargePulse 0.5s infinite alternate;
        }
        .bomb-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,215,0,0.8) 0%, rgba(255,0,0,0) 70%);
            z-index: 90;
            pointer-events: none;
            animation: bombExplosion 0.5s ease-out;
        }
        .bomb-charge-indicator {
            position: absolute;
            bottom: 280px;
            right: 20px;
            width: 80px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            z-index: 100;
        }
        .bomb-charge-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #ff9800, #ff5722);
            transition: width 0.1s linear;
        }
        .bomb-range-indicator {
            position: absolute;
            border: 2px solid rgba(255, 87, 34, 0.7);
            border-radius: 50%;
            pointer-events: none;
            z-index: 90;
            display: none;
        }
        @keyframes bombChargePulse {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(255, 87, 34, 0.5); }
            100% { transform: scale(1.1); box-shadow: 0 0 20px rgba(255, 87, 34, 0.8); }
        }
        @keyframes bombExplosion {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        @keyframes jumpPulse {
            0% { opacity: 0.8; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(2); }
        }
        @keyframes coinFloat {
            0% { opacity: 1; transform: translate(0, 0); }
            100% { opacity: 0; transform: translate(0, -100px); }
        }
        @keyframes fadeInScale {
            0% { opacity: 0; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .hidden {
            display: none;
        }
        .success-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            font-size: 42px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            animation: popIn 0.8s ease-out;
            border: 5px solid #fff;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            .info-panel {
                width: 100%;
                max-height: 45vh;
            }
            .overlay {
                font-size: 14px;
                max-width: 80%;
                left: 15px;
                top: 15px;
            }
            .overlay .title {
                font-size: 18px;
            }
            .overlay .subtitle {
                font-size: 14px;
            }
            .game-ui {
                bottom: 170px;
                right: 10px;
            }
            .ui-button {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
            .movement-controls {
                bottom: 170px;
                left: 10px;
            }
            .joystick-container {
                width: 120px;
                height: 120px;
            }
            .joystick-handle {
                width: 50px;
                height: 50px;
            }
            .score-display {
                bottom: 150px;
                right: 10px;
                font-size: 16px;
            }
            .coins-display {
                bottom: 180px;
                right: 10px;
                font-size: 16px;
            }
            .sheep-display {
                top: 10px;
                left: 10px;
                font-size: 16px;
                padding: 8px 12px;
            }
            .health-indicator {
                top: 150px;
                right: 10px;
                width: 150px;
            }
            .start-screen-content {
                padding: 20px;
            }
            .start-screen h1 {
                font-size: 30px;
            }
            .start-screen h2 {
                font-size: 20px;
            }
            .start-screen p {
                font-size: 16px;
            }
            .start-btn {
                font-size: 18px;
                padding: 12px 25px;
            }
            .round-indicator {
                font-size: 16px;
                padding: 8px 15px;
            }
            .next-round-btn {
                bottom: 170px;
                right: 10px;
                font-size: 14px;
                padding: 10px 15px;
            }
            .charge-indicator {
                bottom: 150px;
                right: 90px;
                width: 80px;
            }
            .round-message {
                font-size: 24px;
                padding: 20px 30px;
            }
            .bomb-charge-indicator {
                bottom: 250px;
                right: 10px;
                width: 70px;
            }
            .success-message {
                font-size: 28px;
                padding: 25px 40px;
            }
        }
        .answer-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            color: white;
            padding: 30px;
            border-radius: 20px;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: popIn 0.5s ease-out;
            border: 5px solid #fff;
        }
        .answer-message.incorrect {
            background: linear-gradient(45deg, #f44336, #ff9800);
        }
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        .player-damage-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .player-damage-effect.active {
            opacity: 1;
            animation: damageFlash 0.5s;
        }
        @keyframes damageFlash {
            0% { opacity: 0.7; }
            50% { opacity: 0.3; }
            100% { opacity: 0; }
        }
        .bombs-display {
            position: absolute;
            top: 190px;
            right: 20px;
            font-size: 20px;
            color: #ff5722;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .sequence-container {
            direction: ltr;
            text-align: left;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
            font-size: 18px;
            line-height: 1.5;
        }
        .sequence-item {
            display: inline-block;
            margin: 0 5px;
        }
        .next-round-btn {
            position: absolute;
            bottom: 200px;
            right: 120px;
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 100;
            display: none;
        }
        .next-round-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        .buy-health-btn {
            position: absolute;
            bottom: 290px;
            right: 20px;
            background: linear-gradient(to right, #4caf50, #2e7d32);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 100;
            display: none;
        }
        .buy-health-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        .buy-health-btn.disabled {
            background: #888;
            cursor: not-allowed;
        }
        .health-purchase-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            z-index: 300;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: popIn 0.5s ease-out;
            border: 3px solid #fff;
        }
        .health-purchase-message.error {
            background: linear-gradient(45deg, #f44336, #ff9800);
        }
        .wolf-health-effect {
            position: absolute;
            font-size: 20px;
            color: #ff4444;
            font-weight: bold;
            animation: healthFloat 1s ease-out forwards;
            pointer-events: none;
            z-index: 90;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        @keyframes healthFloat {
            0% { opacity: 1; transform: translate(0, 0); }
            100% { opacity: 0; transform: translate(0, -50px); }
        }
        .crocodile-damage-effect {
            position: absolute;
            font-size: 28px;
            color: #ff0000;
            font-weight: bold;
            animation: healthFloat 1s ease-out forwards;
            pointer-events: none;
            z-index: 90;
            text-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
        }
        .crocodiles-display {
            position: absolute;
            top: 220px;
            right: 20px;
            font-size: 20px;
            color: #00cc66;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .hives-display {
            position: absolute;
            top: 250px;
            right: 20px;
            font-size: 20px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .eagles-display {
            position: absolute;
            top: 280px;
            right: 20px;
            font-size: 20px;
            color: #8B4513;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        }
        .snatching-eagles-display {
            position: absolute;
            top: 310px;
            right: 20px;
            font-size: 20px;
            color: #ff3300;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
        .emergency-fix-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: rgba(244, 67, 54, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 3000;
            display: block;
            font-size: 12px;
            font-family: "Cairo", sans-serif;
            font-weight: bold;
        }
        .emergency-fix-btn:hover {
            background: #f44336;
        }
    </style>
<script>
            // ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÇŸÅÿ≤ ÿßŸÑÿ™ÿ±ÿ®ŸäÿπŸä ÿßŸÑŸÖÿ∑Ÿàÿ± (Quadratic Projectile System) - Manus Ultimate Fix
            window.jumpData = {
                isJumping: false,
                jumpCount: 0,
                maxJumps: 2,
                vVel: 0,
                hVel: { x: 0, z: 0 },
                gravity: 0.07,
                jumpForce: 0.3,
                airControl: 0.05 // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑŸÖÿ≥ÿßÿ± ŸÅŸä ÿßŸÑŸáŸàÿßÿ°
            };

            
            // ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ¥ÿ≠ŸÜ ŸÑŸÑŸÇŸÅÿ≤
            window.chargeTime = 0;
            window.isCharging = false;
            
            window.startCharging = function() {
                window.isCharging = true;
                window.chargeTime = 0;
            };
            
            window.stopCharging = function() {
                if (window.isCharging) {
                    window.isCharging = false;
                    window.triggerJump();
                }
            };
            
            window.updateCharging = function() {
                if (window.isCharging && window.chargeTime < 500) {
                    window.chargeTime += 16; // ~60fps
                    if (window.chargeTime > 1000) window.chargeTime = 1000;
                }
            };
            window.updateChargeBar = function() {
                const chargeBar = document.getElementById('chargeBar');
                const chargeBarFill = document.getElementById('chargeBarFill');
                const chargeText = document.getElementById('chargeText');
                
                if (window.isCharging) {
                    chargeBar.style.display = 'block';
                    chargeText.style.display = 'block';
                    
                    const chargePercent = Math.min(100, (window.chargeTime / 10));
                    chargeBarFill.style.height = chargePercent + '%';
                    chargeText.textContent = 'ÿßŸÑÿ¥ÿ≠ŸÜ: ' + Math.floor(chargePercent) + '%';
                } else {
                    chargeBar.style.display = 'none';
                    chargeText.style.display = 'none';
                }
            };


            window.triggerJump = function() {
                if (gameStarted && !gameOver) {
                    if (window.jumpData.jumpCount < window.jumpData.maxJumps) {
                        window.jumpData.isJumping = true;
                        window.jumpData.jumpCount++;
                        window.jumpData.vVel = window.jumpData.jumpForce;
                        
                        // ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿØŸÅÿπ ÿßŸÑÿ£ŸÅŸÇŸä ÿßŸÑÿ£ŸàŸÑŸä ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
                        let moveX = 0;
                        let moveZ = 0;
                        if (keys.w || keys.arrowup) moveZ -= 1;
                        if (keys.s || keys.arrowdown) moveZ += 1;
                        if (keys.a || keys.arrowleft) moveX -= 1;
                        if (keys.d || keys.arrowright) moveX += 1;
                        if (typeof joystickActive !== 'undefined' && joystickActive) {
                            moveX = joystickDirection.x;
                            moveZ = joystickDirection.y;
                        }
                        
                        const mag = Math.sqrt(moveX*moveX + moveZ*moveZ);
                        const boost = 0.1;
                        if (mag > 0) {
                            window.jumpData.hVel.x = (moveX / mag) * boost;
                            window.jumpData.hVel.z = (moveZ / mag) * boost;
                        }
                        
                        console.log('Jump Triggered! Count:', window.jumpData.jumpCount);
                    }
                }
            };

            // ÿØÿßŸÑÿ© ÿ™ÿ≠ÿØŸäÿ´ ŸÅŸäÿ≤Ÿäÿßÿ° ÿßŸÑŸÖŸÇÿ∞ŸàŸÅÿßÿ™ (ÿ™ÿ≥ÿ™ÿØÿπŸâ ŸÅŸä animate)
            window.updateQuadraticJump = function() {
                if (!window.jumpData.isJumping) return;

                const p = player.position;
                
                // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ≠ÿ±ŸÉÿ© (ÿßŸÑŸÖÿπÿßÿØŸÑÿ© ÿßŸÑÿ™ÿ±ÿ®ŸäÿπŸäÿ© ŸÑŸÑÿ≠ÿ±ŸÉÿ©: y = y0 + v0t - 0.5gt^2)
                p.y += window.jumpData.vVel;
                p.x += window.jumpData.hVel.x;
                p.z += window.jumpData.hVel.z;
                
                // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ©
                window.jumpData.vVel -= window.jumpData.gravity;
                
                // ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑŸÖÿ≥ÿßÿ± ŸÅŸä ÿßŸÑŸáŸàÿßÿ° (Air Control)
                let airX = 0;
                let airZ = 0;
                if (keys.w || keys.arrowup) airZ -= window.jumpData.airControl;
                if (keys.s || keys.arrowdown) airZ += window.jumpData.airControl;
                if (keys.a || keys.arrowleft) airX -= window.jumpData.airControl;
                if (keys.d || keys.arrowright) airX += window.jumpData.airControl;
                if (typeof joystickActive !== 'undefined' && joystickActive) {
                    airX = joystickDirection.x * window.jumpData.airControl;
                    airZ = joystickDirection.y * window.jumpData.airControl;
                }
                window.jumpData.hVel.x += airX * 0.1;
                window.jumpData.hVel.z += airZ * 0.1;

                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáÿ®Ÿàÿ∑ ÿπŸÑŸâ ÿßŸÑÿµÿÆŸàÿ± ŸÖÿπ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ¨ÿ∞ÿ® ÿßŸÑŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥Ÿä (ŸÖÿπÿØŸÑ)
                let landed = false;
                if (window.riverRocks && window.jumpData.vVel <= 0) {
                    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿµÿÆÿ±ÿ© ŸÑŸÑŸáÿ®Ÿàÿ∑ ÿπŸÑŸäŸáÿß
                    let landingRock = null;
                    for (let r of window.riverRocks) {
                        const rockData = r.userData;
                        const horizontalDistance = Math.sqrt(
                            (p.x - r.position.x) ** 2 +
                            (p.z - r.position.z) ** 2
                        );
                        
                        // Check if player is horizontally on the rock and is about to land
                        if (horizontalDistance < rockData.radius * 0.5 && p.y >= rockData.topY - 1 && p.y <= rockData.topY + 0.5) {
                            landingRock = r;
                            break;
                        }
                    }
                    
                    if (landingRock) {
                        const rockData = landingRock.userData;
                        const rockTopY = rockData.topY;
                        
                        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáÿ®Ÿàÿ∑ ÿπŸÑŸâ ÿßŸÑÿµÿÆÿ±ÿ©
                        if (p.y <= rockTopY + 0.1) {
                            p.y = rockTopY;
                            window.jumpData.vVel = 0;
                            window.jumpState.active = false;
                            window.jumpState.onGround = true;
                            window.jumpState.onRock = true;
                            return; // ÿ™ŸÖ ÿßŸÑŸáÿ®Ÿàÿ∑ÿå ŸÑÿß ÿ≠ÿßÿ¨ÿ© ŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©
                        }
                    }      if (window.jumpData.vVel <= 0 && distance > 0 && distance <= magneticRange) {
                            // ÿ™ÿ∑ÿ®ŸäŸÇ ŸÇŸàÿ© ÿßŸÑÿ¨ÿ∞ÿ® ÿ®ÿ¥ŸÉŸÑ ÿ™ÿØÿ±Ÿäÿ¨Ÿä (ÿ£ŸÇŸàŸâ ŸÉŸÑŸÖÿß ÿßŸÇÿ™ÿ±ÿ®ŸÜÿß)
                            const pullFactor = (1 - distance / magneticRange) * magneticStrength;
                            
                            // ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ≥ÿ±ÿπÿ© ÿßŸÑÿ£ŸÅŸÇŸäÿ© ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿ™ÿπÿØŸäŸÑ ÿßŸÑŸÖŸàÿ∂ÿπ ŸÑŸäŸÉŸàŸÜ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿ£ŸÉÿ´ÿ± ÿ≥ŸÑÿßÿ≥ÿ© ŸàŸÅÿπÿßŸÑŸäÿ©
                            window.jumpData.hVel.x += (dirX / distance) * pullFactor * 0.2; // ŸÖÿ∂ÿßÿπŸÅÿ© ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑÿ¨ÿ∞ÿ® ÿπŸÑŸâ ÿßŸÑÿ≥ÿ±ÿπÿ©
                            window.jumpData.hVel.z += (dirZ / distance) * pullFactor * 0.2;
                            
                            // ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑÿ≥ÿ±ÿπÿ© ÿßŸÑÿ£ŸÅŸÇŸäÿ© ŸÑŸÑÿßÿπÿ® ŸÑÿ¨ÿπŸÑŸá ÿ£ÿ≥ŸáŸÑ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿπŸÜÿØ ÿßŸÑŸáÿ®Ÿàÿ∑
                            window.jumpData.hVel.x *= 0.9; // ÿ™ÿÆŸÅŸäŸÅ ÿ£ŸÉÿ®ÿ± ŸÑŸÑÿ≥ÿ±ÿπÿ©
                            window.jumpData.hVel.z *= 0.9;
                        }
                        
                        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáÿ®Ÿàÿ∑ ÿßŸÑŸÜŸáÿßÿ¶Ÿä ÿ®ÿπÿØ ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ¨ÿ∞ÿ®
                        const finalDist = Math.sqrt((p.x - closestRock.position.x)**2 + (p.z - closestRock.position.z)**2);
                        if (finalDist < 6) { // ŸÜÿ∑ÿßŸÇ ÿßŸÑŸáÿ®Ÿàÿ∑
                            p.y = closestRock.position.y + 1.2;
                            // ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑŸÑÿßÿπÿ® ŸÅŸä ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿµÿÆÿ±ÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑŸáÿ®Ÿàÿ∑
                            p.x = closestRock.position.x;
                            p.z = closestRock.position.z;
                            landed = true;
                        }
                    }
                }
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáÿ®Ÿàÿ∑ ÿπŸÑŸâ ÿßŸÑÿ£ÿ±ÿ∂
                if (!landed && p.y <= 1.2 && !(p.z < -25 && p.z > -115)) {
                    p.y = 1.2;
                    landed = true;
                }

                if (landed) {
                    window.jumpData.isJumping = false;
                    window.jumpData.jumpCount = 0;
                    window.jumpData.vVel = 0;
                    window.jumpData.hVel = { x: 0, z: 0 };
                }
            };
</script>
            <style>
                #chargeBar {
                    position: fixed;
                    bottom: 120px;
                    right: 20px;
                    width: 60px;
                    height: 200px;
                    background: rgba(0, 0, 0, 0.5);
                    border: 3px solid #00ff00;
                    border-radius: 5px;
                    overflow: hidden;
                    display: none;
                    z-index: 1000;
                }
                
                #chargeBarFill {
                    width: 100%;
                    height: 0%;
                    background: linear-gradient(to top, #00ff00, #ffff00, #ff6600);
                    transition: height 0.05s linear;
                }
                
                #chargeText {
                    position: fixed;
                    bottom: 330px;
                    right: 25px;
                    color: #00ff00;
                    font-weight: bold;
                    font-size: 14px;
                    display: none;
                    z-index: 1000;
                    text-shadow: 0 0 5px #00ff00;
                }
            </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-screen-content">
            <h1>ÿßŸÑÿ±ÿßÿπŸä ÿßŸÑÿ∞ŸÉŸä ŸàÿßŸÑÿÆÿ±ÿßŸÅ ÿßŸÑÿ∂ÿßÿ¶ÿπÿ©</h1>
            <h2>ŸÇÿµÿ© ÿßŸÑŸÑÿπÿ®ÿ©</h2>
            <p>ÿ∂ÿßÿπÿ™ ÿÆŸÖÿ≥ ÿÆÿ±ÿßŸÅ ÿ®ÿ≥ÿ®ÿ® ÿßŸÑÿπÿßÿµŸÅÿ©! Ÿäÿ®ÿ≠ÿ´ ÿßŸÑÿ±ÿßÿπŸä ÿπŸÜŸáÿß ŸàŸäŸàÿßÿ¨Ÿá ÿßŸÑÿ≠ŸäŸàÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿ±ÿ≥ÿ© ŸÅŸäÿ∂ÿ±ÿ®Ÿáÿß ÿ®ÿßŸÑÿπÿµÿß ŸàŸäÿ®ÿπÿØ ÿßŸÑÿ∞ÿ¶ÿßÿ® ÿßŸÑÿ∂ÿÆŸÖÿ© ÿßŸÑŸÖÿ™ÿ¨ŸÖÿπÿ© ÿ≠ŸàŸÑ ÿßŸÑÿÆÿ±ÿßŸÅ ÿ®ÿ¥ÿπŸÑÿ© ÿßŸÑŸÜÿßÿ±.</p>
            <p>ÿ≥ŸäŸÇŸàŸÖ ÿßŸÑŸÑÿßÿπÿ® ÿ®ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ∫ÿ∞ÿßÿ° ŸÖŸÜ ÿÆŸÑÿßŸäÿß ÿßŸÑŸÜÿ≠ŸÑ ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ™ŸàŸä ÿßŸÑÿπÿ≥ŸÑ ÿßŸÑŸÑÿ∞Ÿäÿ∞!</p>
            <p>‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±: ÿ™Ÿàÿ¨ÿØ ŸÜÿ≥Ÿàÿ± ÿÆÿßÿ∑ŸÅÿ© ÿ™ÿ∑Ÿäÿ± ÿπŸÑŸâ ÿßÿ±ÿ™ŸÅÿßÿπ ŸÖŸÜÿÆŸÅÿ∂ Ÿàÿ™ÿ≠ÿßŸàŸÑ ÿÆÿ∑ŸÅ ÿÆÿ±ÿßŸÅŸÉ!</p>
            <p>üéÅ ÿπŸÜÿØ ÿ≠ŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖŸàÿ¨ŸàÿØ ŸÅŸä ÿßŸÑÿµŸÜÿØŸàŸÇ ÿ≥ÿ™ÿ≠ÿµŸÑ ÿπŸÑŸâ ŸáÿØŸäÿ©!</p>
            <button class="start-btn" id="startGameBtn" onclick="window.startGame(); return false;">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®ÿ©</button>
        </div>
    </div>
    <div class="laser-sight" id="laserSight"></div>
    <div class="round-transition" id="roundTransition">
        <div class="round-message" id="roundMessage">ÿßŸÑÿ¨ŸàŸÑÿ© 1</div>
    </div>
    <div class="player-damage-effect" id="playerDamageEffect"></div>
    <div class="container">
        <div class="info-panel" id="infoPanel">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="levelDisplay">1</div>
                    <div class="stat-label">ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="wasteCount">0</div>
                    <div class="stat-label">ÿßŸÑÿ∞ÿ¶ÿßÿ®</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coinsCount">0</div>
                    <div class="stat-label">ÿßŸÑÿπŸÖŸÑÿßÿ™</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="aggressiveCount">0</div>
                    <div class="stat-label">ÿßŸÑÿπÿØŸàÿßŸÜŸäÿ©</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="beesCount">0</div>
                    <div class="stat-label">ÿßŸÑŸÜÿ≠ŸÑ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="crocodilesCount">0</div>
                    <div class="stat-label">ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="hivesCount">0</div>
                    <div class="stat-label">ÿÆŸÑŸäÿ© ÿπÿ≥ŸÑ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="eaglesCount">0</div>
                    <div class="stat-label">ÿßŸÑŸÜÿ≥Ÿàÿ±</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="snatchingEaglesCount">0</div>
                    <div class="stat-label">ÿßŸÑÿÆÿßÿ∑ŸÅÿ©</div>
                </div>
            </div>
        </div>
        <div class="scene-container">
            <canvas id="gameScene"></canvas>
            <div class="score-display" id="scoreDisplay">ÿßŸÑŸÜŸÇÿßÿ∑: 0</div>
            <div id="chargeBar">
                <div id="chargeBarFill"></div>
            </div>
            <div id="chargeText">ÿßŸÑÿ¥ÿ≠ŸÜ: 0%</div>
        
            <div class="coins-display" id="coinsDisplay">ÿßŸÑÿπŸÖŸÑÿßÿ™: 0</div>
            <div class="sheep-display" id="sheepDisplay">ÿßŸÑÿÆÿ±ÿßŸÅ: 0/5</div>
            <div class="bombs-display" id="bombsDisplay">ÿ¥ÿπŸÑÿßÿ™ ÿßŸÑŸÜÿßÿ±: 0</div>
            <div class="crocodiles-display" id="crocodilesDisplay">ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠: 0</div>
            <div class="hives-display" id="hivesDisplay">ÿÆŸÑÿßŸäÿß ÿßŸÑÿπÿ≥ŸÑ: 0</div>
            <div class="eagles-display" id="eaglesDisplay">ÿßŸÑŸÜÿ≥Ÿàÿ±: 0</div>
            <div class="snatching-eagles-display" id="snatchingEaglesDisplay">ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©: 0</div>
            <div class="health-indicator" id="healthIndicator">
                <div class="health-bar" id="healthBar"></div>
            </div>
            <button class="buy-health-btn" id="buyHealthBtn">ÿ¥ÿ±ÿßÿ° ÿµÿ≠ÿ© (100 ÿπŸÖŸÑÿ©)</button>
            <div class="round-indicator" id="roundIndicator">ÿßŸÑÿ¨ŸàŸÑÿ©: 1</div>
            <button class="next-round-btn" id="nextRoundBtn">ÿßŸÑÿ¨ŸàŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©</button>
            <div class="bomb-charge-indicator" id="bombChargeIndicator">
                <div class="bomb-charge-bar" id="bombChargeBar"></div>
            </div>
            <div class="movement-controls" id="movementControls">
                <div class="joystick-container">
                    <div class="joystick-base" id="joystickBase"></div>
                    <div class="joystick-handle" id="joystickHandle"></div>
                </div>
            </div>
            <div class="game-ui">
                <div class="ui-button jump-btn" id="jumpBtn">‚Üü</div>
                <div class="ui-button bomb-btn" id="bombBtn">üî•</div>
                <div class="ui-button" id="attackBtn">ü™Ñ</div>
            </div>
            <div class="game-over" id="gameOverPanel">
                <h2 style="color: #4caf50; margin-bottom: 10px;">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!</h2>
                <p style="font-size: 20px; margin-bottom: 5px;">ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©: <span id="finalScore" style="color: #ffd700; font-weight: bold;">0</span></p>
                <p style="font-size: 16px; opacity: 0.8; margin-bottom: 20px;">ÿßŸÑÿπŸÖŸÑÿßÿ™ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©: <span id="finalCoins">0</span></p>
                
                <div id="scoreSubmissionArea">
                    <h3 style="font-size: 18px; margin-bottom: 10px; color: #fff;">üìù ÿ≥ÿ¨ŸÑ ŸÜÿ™Ÿäÿ¨ÿ™ŸÉ ŸÅŸä ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ</h3>
                    <div class="leaderboard-input-group">
                        <input type="text" id="playerName" class="leaderboard-input" placeholder="ÿßÿ≥ŸÖ ÿßŸÑÿ∑ÿßŸÑÿ®">
                        <input type="text" id="playerSchool" class="leaderboard-input" placeholder="ÿßÿ≥ŸÖ ÿßŸÑŸÖÿØÿ±ÿ≥ÿ©">
                        <button type="button" id="submitScoreBtn" class="save-score-btn" style="position: relative; z-index: 999999; pointer-events: auto !important; cursor: pointer !important;">ÿ≠ŸÅÿ∏ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© üèÜ</button>
                    </div>
                </div>

                <div class="leaderboard-container">
                    <h3 style="font-size: 18px; border-bottom: 1px solid #4caf50; padding-bottom: 5px; margin-bottom: 10px;">üèÜ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ</h3>
                    <ul id="leaderboardList" class="leaderboard-list">
                        <li style="text-align: center; opacity: 0.6;">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©...</li>
                    </ul>
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="restart-btn" id="restartBtn" style="flex: 1;">ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÑÿπÿ® üîÑ</button>
                    <button class="restart-btn" id="viewLeaderboardBtn" style="flex: 1; background: #667eea;">ŸÑŸàÿ≠ÿ© ÿßŸÑÿµÿØÿßÿ±ÿ© üèÜ</button>
                </div>

                <!-- ŸÜŸÖŸàÿ∞ÿ¨ ŸÖÿÆŸÅŸä ŸÑŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸÑŸÖŸÑŸÅ ÿßŸÑÿ•ŸÉÿ≥ŸÑ - ÿ≠ŸÑ GitHub Pages ÿßŸÑŸÖÿ∂ŸÖŸàŸÜ -->
                <form id="saveForm" action="https://script.google.com/macros/s/AKfycbzQaSrbe596ppDbDdAnmaLmx3Of54-e4BTZkgL3Gf7Nfj3CwJbh8hqKUBUk7AwP-uqTEA/exec" method="POST" target="hidden_iframe" style="display:none;">
                    <input type="hidden" name="name" id="hiddenName">
                    <input type="hidden" name="school" id="hiddenSchool">
                    <input type="hidden" name="score" id="hiddenScore">
                </form>
                <iframe name="hidden_iframe" style="display:none;"></iframe>
            </div>
            
            <!-- ŸÑŸàÿ≠ÿ© ÿßŸÑÿµÿØÿßÿ±ÿ© ÿßŸÑŸÖÿØŸÖÿ¨ÿ© -->
            <div class="leaderboard-modal" id="leaderboardModal">
                <div class="leaderboard-content">
                    <button class="leaderboard-close" onclick="closeLeaderboard()">‚úï</button>
                    <div class="leaderboard-header">
                        <h2>üèÜ ŸÑŸàÿ≠ÿ© ÿßŸÑÿµÿØÿßÿ±ÿ©</h2>
                        <p>ÿ£ŸÅÿ∂ŸÑ ÿßŸÑÿ∑ŸÑÿßÿ® ŸÅŸä ÿßŸÑŸÑÿπÿ®ÿ©</p>
                    </div>
                    <div class="leaderboard-stats" id="leaderboardStats"></div>
                    <table class="leaderboard-table">
                        <thead>
                            <tr>
                                <th style="width: 80px;">ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®</th>
                                <th>ÿßÿ≥ŸÖ ÿßŸÑÿ∑ÿßŸÑÿ®</th>
                                <th>ÿßŸÑŸÖÿØÿ±ÿ≥ÿ©</th>
                                <th style="width: 100px;">ÿßŸÑŸÜŸÇÿßÿ∑</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboardTableBody">
                            <tr><td colspan="4" style="text-align: center; padding: 30px;">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div id="toxicAlert" class="toxic-water-alert">
                ÿ™ÿ≠ÿ∞Ÿäÿ±: ŸÖŸäÿßŸá ŸÖŸÑŸàÿ´ÿ©! ÿµÿ≠ÿ™ŸÉ ÿ™ÿ™ŸÜÿßŸÇÿµ!
            </div>

            <!-- ÿ≤ÿ± ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿ© - ŸÖŸÜŸáÿßÿ¨ ÿßŸÑÿµŸÅ ÿßŸÑÿ≥ÿßÿ®ÿπ ÿßŸÑÿ£ÿ±ÿØŸÜŸä -->
            <div class="math-help-btn" id="mathHelpBtn" title="ŸÖÿ≥ÿßÿπÿØÿ© ÿ±Ÿäÿßÿ∂Ÿäÿ©">
                <span>ŸÖÿ≥ÿßÿπÿØ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™</span>
                <span style="font-size: 24px;">ÿü</span>
            </div>

            <div class="math-overlay" id="mathOverlay"></div>
            <div class="math-modal" id="mathModal">
                <div class="math-modal-header">
                    <div class="math-modal-title">ŸÖÿ≥ÿßÿπÿØ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™ (ÿßŸÑÿµŸÅ ÿßŸÑÿ≥ÿßÿ®ÿπ)</div>
                    <div class="close-math-modal" id="closeMathModal">&times;</div>
                </div>
                <div id="mathModalContent">
                    <!-- ÿ≥Ÿäÿ™ŸÖ ŸÖŸÑÿ° ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ®ÿ±ŸÖÿ¨ŸäÿßŸã ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÖŸàÿ∂Ÿàÿπ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ≠ÿßŸÑŸä -->
                </div>
            </div>
        </div>
    </div>
    <div class="question-panel" id="questionPanel">
        <h2>ÿ≥ÿ§ÿßŸÑ ÿ±Ÿäÿßÿ∂Ÿä!</h2>
        <p id="questionText">ŸÖÿß ÿßŸÑÿ≠ÿØ ÿßŸÑÿ™ÿßŸÑŸä ŸÅŸä ÿßŸÑŸÖÿ™ÿ™ÿßŸÑŸäÿ© ÿßŸÑÿ¢ÿ™Ÿäÿ©ÿü</p>
        <div id="sequenceContainer" class="sequence-container"></div>
        <div id="svgContainer" class="svg-container" style="display:none; margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 10px; border: 2px solid rgba(79,172,254,0.3);"></div>
        <div class="options-container" id="optionsContainer"></div>
    </div>
    <button class="emergency-fix-btn" id="emergencyFixBtn">üîß ÿ•ÿµŸÑÿßÿ≠ ÿßŸÑŸÑÿπÿ®ÿ©</button>
    <script>
        // ===== ŸÜÿ∏ÿßŸÖ ÿßŸÑÿµŸàÿ™ =====
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, type = "sine", duration = 0.1, volume = 0.3) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playMonsterAttackSound() {
            const now = audioContext.currentTime;
            const duration = 0.3;
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioContext.createGain();
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);
            source.start(now);
        }

        function playStickSound() {
            const hitOscillator = audioContext.createOscillator();
            const hitGain = audioContext.createGain();
            hitOscillator.connect(hitGain);
            hitGain.connect(audioContext.destination);
            hitOscillator.type = "sawtooth";
            hitOscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            hitGain.gain.setValueAtTime(0.7, audioContext.currentTime);
            hitGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            hitOscillator.start(audioContext.currentTime);
            hitOscillator.stop(audioContext.currentTime + 0.1);

            const thumpOscillator = audioContext.createOscillator();
            const thumpGain = audioContext.createGain();
            thumpOscillator.connect(thumpGain);
            thumpGain.connect(audioContext.destination);
            thumpOscillator.type = "sawtooth";
            thumpOscillator.frequency.setValueAtTime(100, audioContext.currentTime + 0.05);
            thumpGain.gain.setValueAtTime(0.4, audioContext.currentTime + 0.05);
            thumpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            thumpOscillator.start(audioContext.currentTime + 0.05);
            thumpOscillator.stop(audioContext.currentTime + 0.2);
        }

        function playMonsterExplosionSound() {
            const now = audioContext.currentTime;
            const duration = 0.5;
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = "sawtooth";
            oscillator1.frequency.value = 60;
            gainNode1.gain.setValueAtTime(0.5, now);
            gainNode1.gain.exponentialRampToValueAtTime(0.001, now + duration);
            oscillator1.start(now);
            oscillator1.stop(now + duration);

            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = "square";
            oscillator2.frequency.value = 1000;
            gainNode2.gain.setValueAtTime(0.3, now);
            gainNode2.gain.exponentialRampToValueAtTime(0.001, now + duration);
            oscillator2.start(now);
            oscillator2.stop(now + duration);
        }

        function playCoinSound() {
            playSound(880, "triangle", 0.1, 0.2);
        }

        function playSheepSound() {
            playSound(440, "sine", 0.2, 0.3);
            setTimeout(() => playSound(550, "sine", 0.2, 0.3), 100);
            setTimeout(() => playSound(660, "sine", 0.2, 0.3), 200);
        }

        function playBoxSound() {
            playSound(440, "sine", 0.1, 0.3);
            setTimeout(() => playSound(660, "sine", 0.1, 0.3), 100);
        }

        function playGiftSound() {
            playSound(523, "sine", 0.1, 0.3);
            setTimeout(() => playSound(659, "sine", 0.1, 0.3), 100);
            setTimeout(() => playSound(784, "sine", 0.1, 0.3), 200);
        }

        function playJumpSound() {
            playSound(500, "sine", 0.2, 0.3);
        }

        function playDamageSound() {
            playSound(200, "sine", 0.1, 0.3); // A softer, less aggressive sound
            setTimeout(() => playSound(150, "sine", 0.1, 0.2), 50);
        }

        function playBombSound() {
            const explosionOscillator = audioContext.createOscillator();
            const explosionGain = audioContext.createGain();
            explosionOscillator.connect(explosionGain);
            explosionGain.connect(audioContext.destination);
            explosionOscillator.type = "sawtooth";
            explosionOscillator.frequency.setValueAtTime(40, audioContext.currentTime);
            explosionGain.gain.setValueAtTime(1.0, audioContext.currentTime);
            explosionGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);
            explosionOscillator.start(audioContext.currentTime);
            explosionOscillator.stop(audioContext.currentTime + 1.5);

            const shrapnelOscillator = audioContext.createOscillator();
            const shrapnelGain = audioContext.createGain();
            shrapnelOscillator.connect(shrapnelGain);
            shrapnelGain.connect(audioContext.destination);
            shrapnelOscillator.type = "square";
            shrapnelOscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
            shrapnelOscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.7);
            shrapnelGain.gain.setValueAtTime(0.7, audioContext.currentTime);
            shrapnelGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.7);
            shrapnelOscillator.start(audioContext.currentTime);
            shrapnelOscillator.stop(audioContext.currentTime + 0.7);

            const rumbleOscillator = audioContext.createOscillator();
            const rumbleGain = audioContext.createGain();
            rumbleOscillator.connect(rumbleGain);
            rumbleGain.connect(audioContext.destination);
            rumbleOscillator.type = "sine";
            rumbleOscillator.frequency.setValueAtTime(30, audioContext.currentTime);
            rumbleGain.gain.setValueAtTime(0.4, audioContext.currentTime);
            rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.0);
            rumbleOscillator.start(audioContext.currentTime);
            rumbleOscillator.stop(audioContext.currentTime + 1.0);
        }

        function playBeeAttackSound() {
            playSound(1000, "sawtooth", 0.1, 0.3);
            setTimeout(() => playSound(800, "sawtooth", 0.1, 0.2), 100);
        }

        function playEagleSound() {
            playSound(600, "sine", 0.3, 0.4);
            setTimeout(() => playSound(400, "sine", 0.2, 0.3), 200);
        }

        function playEagleWingsSound() {
            playSound(300, "sine", 0.1, 0.2);
            setTimeout(() => playSound(350, "sine", 0.1, 0.2), 150);
            setTimeout(() => playSound(300, "sine", 0.1, 0.2), 300);
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ŸÜŸÖŸàÿ∞ÿ¨ ÿßŸÑŸÑÿßÿπÿ® =====
        function createPlayerModel() {
            const playerGroup = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169e1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            playerGroup.add(body);

            const neckGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 16);
            const neckMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const neck = new THREE.Mesh(neckGeometry, neckMaterial);
            neck.position.y = 0.7;
            body.add(neck);

            const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac, roughness: 0.8 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.2;
            neck.add(head);

            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.12, 0.05, 0.28);
            head.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.12, 0.05, 0.28);
            head.add(rightEye);

            const pupilGeometry = new THREE.SphereGeometry(0.04, 16, 16);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(0, 0, 0.06);
            leftEye.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0, 0, 0.06);
            rightEye.add(rightPupil);

            const mouthGeometry = new THREE.TorusGeometry(0.1, 0.02, 16, 100, Math.PI);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: 0xff4d4d });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -0.1, 0.25);
            mouth.rotation.x = Math.PI / 2;
            head.add(mouth);

            const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const hatCrownGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.2, 16);
            const hatCrown = new THREE.Mesh(hatCrownGeometry, hatMaterial);
            hatCrown.position.y = 0.3;
            head.add(hatCrown);
            const hatBrimGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 32);
            const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
            hatBrim.position.y = 0.2;
            head.add(hatBrim);

            const leftArmGroup = new THREE.Group();
            leftArmGroup.position.set(-0.6, 0.3, 0);
            body.add(leftArmGroup);
            const rightArmGroup = new THREE.Group();
            rightArmGroup.position.set(0.6, 0.3, 0);
            body.add(rightArmGroup);

            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 16);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x4169e1 });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.rotation.z = Math.PI / 4;
            leftArmGroup.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.rotation.z = -Math.PI / 4;
            rightArmGroup.add(rightArm);

            const handGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const handMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(0, 0.4, 0);
            leftArm.add(leftHand);
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0, 0.4, 0);
            rightArm.add(rightHand);

            const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3.5, 8);
            const stickMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const stick = new THREE.Mesh(stickGeometry, stickMaterial);
            stick.position.set(0, 0, 1.75);
            stick.rotation.x = Math.PI / 2;
            leftHand.add(stick);

            const leftLegGroup = new THREE.Group();
            leftLegGroup.position.set(-0.2, -0.6, 0);
            body.add(leftLegGroup);
            const rightLegGroup = new THREE.Group();
            rightLegGroup.position.set(0.2, -0.6, 0);
            body.add(rightLegGroup);

            const legGeometry = new THREE.CylinderGeometry(0.12, 0.12, 1.0, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x00008b });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.y = -0.5;
            leftLegGroup.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.y = -0.5;
            rightLegGroup.add(rightLeg);

            const shoeGeometry = new THREE.BoxGeometry(0.25, 0.15, 0.3);
            const shoeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.y = -0.6;
            leftLeg.add(leftShoe);
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.y = -0.6;
            rightLeg.add(rightShoe);

            playerGroup.scale.set(1, 1, 1);
            playerGroup.position.y = 1;
            playerGroup.userData = {
                leftArm: leftArmGroup,
                rightArm: rightArmGroup,
                leftLeg: leftLegGroup,
                rightLeg: rightLegGroup,
                stick: stick,
                isAttacking: false,
                attackProgress: 0,
                walkCycle: 0,
            };
            return playerGroup;
        }

        // ===== ÿØŸàÿßŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸàÿßŸÑÿ™ÿ≠ÿ±ŸäŸÉ =====
        function animateWalking(playerModel, deltaTime) {
            if (!playerModel.userData) return;
            const { leftArm, rightArm } = playerModel.userData;
            const walkSpeed = 5;
            playerModel.userData.walkCycle += deltaTime * walkSpeed;
            const armSwing = Math.sin(playerModel.userData.walkCycle) * 0.3;
            leftArm.rotation.z = Math.PI / 4 + armSwing;
            rightArm.rotation.z = -Math.PI / 4 - armSwing;
        }

        function animateLegs(playerModel, deltaTime) {
            if (!playerModel.userData) return;
            const { leftLeg, rightLeg } = playerModel.userData;
            const walkSpeed = 5;
            playerModel.userData.walkCycle += deltaTime * walkSpeed;
            const legSwing = Math.sin(playerModel.userData.walkCycle) * 0.5;
            leftLeg.rotation.x = legSwing;
            rightLeg.rotation.x = -legSwing;
        }

        function animateStickAttack(playerModel, deltaTime) {
            if (!playerModel.userData || !playerModel.userData.isAttacking) return;
            const { leftArm, stick } = playerModel.userData;
            playerModel.userData.attackProgress += deltaTime * 10;
            if (playerModel.userData.attackProgress < 1) {
                const swingAngle = (Math.sin(playerModel.userData.attackProgress * Math.PI) * Math.PI) / 1.5;
                leftArm.rotation.z = Math.PI / 4 + swingAngle;
                if (stick) {
                    stick.rotation.x = Math.PI / 2 + swingAngle * 0.5;
                }
            } else {
                playerModel.userData.isAttacking = false;
                playerModel.userData.attackProgress = 0;
                leftArm.rotation.z = Math.PI / 4;
                if (stick) {
                    stick.rotation.x = Math.PI / 2;
                }
            }
        }

        function triggerStickAttack(playerModel) {
            if (playerModel.userData) {
                playerModel.userData.isAttacking = true;
                playerModel.userData.attackProgress = 0;
            }
        }

        // ===== ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸàÿßŸÑŸÇŸÅÿ≤ ÿßŸÑŸÖÿ≠ÿ≥ŸÜÿ© =====
        let isJumping = false;
        let jumpVelocity = 0;
        const gravity = 0.008;
        const jumpPower = 0.4;
        let isOnGround = true;
        let isOnAnySurface = false;
        let isOnHill = false;
        let currentHillHeight = 0;

        // ===== ÿßŸÑÿ™ÿπÿØŸäŸÑ: ÿ™ŸÇŸÑŸäŸÑ ÿ≥ÿ±ÿπÿ© ÿßŸÑŸÑÿßÿπÿ® =====
        let playerSpeed = 0.5; // ÿ™ÿ∫ŸäŸäÿ± ŸÖŸÜ 1.0 ÿ•ŸÑŸâ 0.5
        let acceleration = 0.02; // ÿ™ÿ∫ŸäŸäÿ± ŸÖŸÜ 0.05 ÿ•ŸÑŸâ 0.02
        let deceleration = 0.95;
        let maxSpeed = 0.5; // ÿ™ÿ∫ŸäŸäÿ± ŸÖŸÜ 1.0 ÿ•ŸÑŸâ 0.5
        let velocity = new THREE.Vector3();

        // ===== ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÑÿßŸÑ =====
        function isInsideHill(position, heightCheck = true) {
            for (const hill of hills) {
                const hillPos = hill.position;
                const hillData = hill.userData;
                const distanceToHillCenter = Math.sqrt(
                    Math.pow(position.x - hillPos.x, 2) + 
                    Math.pow(position.z - hillPos.z, 2)
                );
                if (distanceToHillCenter < hillData.radius) {
                    const normalizedDistance = distanceToHillCenter / hillData.radius;
                    const hillHeight = hillData.height * (1 - normalizedDistance);
                    if (!heightCheck || position.y < hillHeight + 2.5) { // Adjusted height check
                        return { 
                            hill, 
                            terrainHeight: hillHeight,
playerSurfaceY: hillHeight + 2.0, 
                            distanceToHillCenter, 
                            normalizedDistance,
                            targetHeight: hillHeight + 1
                        };
                    }
                }
            }
            return null;
        }

        // ===== ÿØŸàÿßŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÖÿ≠ÿ≥ŸÜÿ© =====
        function movePlayer() {
            if (isRoundTransition) return;
            
            updatePlayerMovementFromJoystick();
            updatePlayerMovementFromKeyboard();
            
            let newPosition = player.position.clone().add(velocity);
            newPosition = checkWorldBounds(newPosition);
            
            let collisionDetected = false;
            _sphere.set(newPosition, 2); const playerBoundingSphere = _sphere;
            
            
                        for (const mountain of mountains) {
                            const mountainPos = mountain.position;
                            const distToMountain = Math.sqrt(Math.pow(newPosition.x - mountainPos.x, 2) + Math.pow(newPosition.z - mountainPos.z, 2));
                            if (distToMountain < 25) { 
                                if (!mountain.userData.boundingBox) {
                                    mountain.userData.boundingBox = new THREE.Box3().setFromObject(mountain);
                                }
                                if (mountain.userData.boundingBox.intersectsSphere(playerBoundingSphere)) {
                                    collisionDetected = true;
                                    break;
                                }
                            }
                        }
            
            // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≥ÿ∑ÿ≠ ŸÅŸä ÿ®ÿØÿßŸäÿ© ŸÉŸÑ ÿ•ÿ∑ÿßÿ±
            const wasOnSurface = isOnAnySurface || isOnGround;
            isOnAnySurface = false;
            isOnGround = false;
            isOnHill = false;
            currentHillHeight = 0;
            
            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖŸÜÿµÿßÿ™ ÿ£ŸàŸÑÿßŸã
            if (!collisionDetected) {
                for (const platform of platforms) {
                    const platformBox = new THREE.Box3().setFromObject(platform);
                    if (platformBox.intersectsSphere(playerBoundingSphere)) {
                        collisionDetected = true;
                        if (newPosition.y < platform.position.y + platform.geometry.parameters.height / 2 + 1) {
                            newPosition.y = platform.position.y + platform.geometry.parameters.height / 2;
                            if (!isJumping || jumpVelocity <= 0) {
                                isOnGround = true;
                                isOnAnySurface = true;
                            }
                        }
                    }
                }
            }
            
            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÑÿßŸÑ - ŸÖÿ≠ÿ≥ŸëŸÜ
            let targetHillHeight = 0;
            let hillCollision = null;

            for (const hill of hills) {
                const hillPos = hill.position;
                const hillData = hill.userData;
                const distanceToHillCenter = Math.sqrt(
                    Math.pow(newPosition.x - hillPos.x, 2) + 
                    Math.pow(newPosition.z - hillPos.z, 2)
                );
                
                if (distanceToHillCenter < hillData.radius) {
                    const normalizedDistance = distanceToHillCenter / hillData.radius;
                    const currentHillHeightVal = hillData.height * (1 - normalizedDistance);
                    targetHillHeight = currentHillHeightVal + 1;
                    
                    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÑÿßÿπÿ® ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ© ÿ£Ÿà ŸÅŸàŸÇŸáÿß
                    const playerBottomY = newPosition.y;
                    const hillTopY = currentHillHeightVal + 1;
                    
                    // ŸÅŸÇÿ∑ ÿßÿπÿ™ÿ®ÿßÿ± ÿßŸÑŸÑÿßÿπÿ® ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÇÿ±Ÿäÿ®ÿßŸã ŸÖŸÜ ÿ≥ÿ∑ÿ≠Ÿáÿß
                    if (playerBottomY <= hillTopY + 1) {
                        hillCollision = {
                            hill: hill,
                            hillHeight: currentHillHeightVal,
                            targetHeight: targetHillHeight,
                            distanceToHillCenter: distanceToHillCenter,
                            normalizedDistance: normalizedDistance
                        };
                        break;
                    }
                }
            }

            if (hillCollision) {
                isOnHill = true;
                currentHillHeight = hillCollision.hillHeight;
                
                const { targetHeight, normalizedDistance, hill } = hillCollision;
                const hillData = hill.userData;
                
                // ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑÿ™ÿ≥ŸÑŸÇ ÿπŸÜÿØ ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÑŸÑÿ£ŸÖÿßŸÖ
                const isMovingForward = (keys.w || keys.arrowup || joystickDirection.y < -0.3);
                const isOnSlope = normalizedDistance > 0.2;
                
                // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿ™ÿ≥ŸÑŸÇ ŸÅŸÇÿ∑ ÿπŸÜÿØ ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÑŸÑÿ£ŸÖÿßŸÖ ŸàÿπŸÑŸâ ÿßŸÑŸÖŸÜÿ≠ÿØÿ± ŸàŸÑŸäÿ≥ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÇŸÅÿ≤
                if (isMovingForward && isOnSlope && !isJumping) {
                    const climbFactor = hillData.climbSlope * (1 - normalizedDistance);
                    velocity.y = Math.max(velocity.y, 0.05 * climbFactor);
                }
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑŸÑÿßÿπÿ® ÿ®ÿßŸÑŸÜÿ≥ÿ®ÿ© ŸÑŸÑÿ™ŸÑÿ©
                const groundThreshold = 0.3;
                const playerBottom = newPosition.y;
                
                if (playerBottom <= targetHeight + groundThreshold) {
                    if (playerBottom > targetHeight) {
                        // ÿßŸÑŸÑÿßÿπÿ® ŸÅŸàŸÇ ÿ≥ÿ∑ÿ≠ ÿßŸÑÿ™ŸÑÿ© ŸÇŸÑŸäŸÑÿßŸã - ŸÑÿß ŸÜÿπŸäŸÇ ÿßŸÑŸÇŸÅÿ≤
                        if (!isJumping) {
                            velocity.y -= gravity * 1.2;
                        }
                    } else {
                        // ÿßŸÑŸÑÿßÿπÿ® ÿπŸÑŸâ ÿ£Ÿà ÿ™ÿ≠ÿ™ ÿ≥ÿ∑ÿ≠ ÿßŸÑÿ™ŸÑÿ©
                        newPosition.y = targetHeight;
                        
                        // ŸÅŸÇÿ∑ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÇŸÅÿ≤ ÿ•ÿ∞ÿß ŸÉÿßŸÜ Ÿáÿßÿ®ÿ∑ÿßŸã (ŸÑŸäÿ≥ ŸÅŸä ŸÇŸÅÿ≤ ÿµÿßÿπÿØ)
                        if (!isJumping || jumpVelocity <= 0) {
                            isOnGround = true;
                            isOnAnySurface = true;
                            isJumping = false;
                            jumpVelocity = 0;
                        }
                    }
                } else {
                    // ÿßŸÑŸÑÿßÿπÿ® ŸÅŸàŸÇ ÿßŸÑÿ™ŸÑÿ© - Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≥ŸÇÿ∑
                    isOnGround = false;
                    isOnAnySurface = false;
                }
            }
            
            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ£ÿ±ÿ∂ (ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ÿπŸÑŸâ ÿ™ŸÑÿ© ÿ£Ÿà ŸÖŸÜÿµÿ©)
            if (!isOnHill && !isOnAnySurface) {
                let onRiverRock = false;
                if (typeof riverRocks !== 'undefined') {
                    for (let r of riverRocks) {
                        const d = Math.sqrt((newPosition.x - r.position.x)**2 + (newPosition.z - r.position.z)**2);
                        if (d < 6) { 
                            onRiverRock = true; 
                            if (newPosition.y <= 0.2) {
                                newPosition.y = 0.2;
                                if (!isJumping || jumpVelocity <= 0) {
                                    isOnGround = true;
                                    isOnAnySurface = true;
                                    isJumping = false;
                                    jumpVelocity = 0;
                                }
                            }
                            break;
                        }
                    }
                }

                if (!onRiverRock) {
                    const hillCenterX = -50;
                    const hillCenterZ = -50;
                    const riverInnerRadius = 40;
                    const riverOuterRadius = 180;
                    const valleyRadius = 230;
                    
                    const distanceToHillCenter = Math.sqrt(
                        Math.pow(newPosition.x - hillCenterX, 2) + 
                        Math.pow(newPosition.z - hillCenterZ, 2)
                    );
                    
                    if (distanceToHillCenter > valleyRadius) {
                        if (newPosition.y <= 0.5) {
                            newPosition.y = 0;
                            if (!isJumping || jumpVelocity <= 0) {
                                isOnGround = true;
                                isOnAnySurface = true;
                                isJumping = false;
                                jumpVelocity = 0;
                            }
                        }
                    } else if (distanceToHillCenter >= riverInnerRadius && distanceToHillCenter <= riverOuterRadius) {
                        // ÿØÿßÿÆŸÑ ÿßŸÑŸÜŸáÿ± ÿ™ŸÖÿßŸÖÿßŸã
                        isOnGround = false;
                    } else if (distanceToHillCenter < riverInnerRadius) {
                        // ÿØÿßÿÆŸÑ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ™ŸÑÿ© ÿßŸÑŸÖÿ±ŸÉÿ≤Ÿäÿ©
                        const normalizedDistance = distanceToHillCenter / riverInnerRadius;
                        const groundHeight = 1.2; // ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿ™ŸÑÿ© ÿßŸÑŸÖÿ±ŸÉÿ≤Ÿäÿ©
                        if (newPosition.y <= groundHeight + 0.5) {
                            newPosition.y = groundHeight;
                            if (!isJumping || jumpVelocity <= 0) {
                                isOnGround = true;
                                isOnAnySurface = true;
                                isJumping = false;
                                jumpVelocity = 0;
                            }
                        }
                    } else {
                        // ŸÅŸä ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸàÿßÿØŸä ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© - ÿßÿ±ÿ™ŸÅÿßÿπ ÿ™ÿØÿ±Ÿäÿ¨Ÿä
                        const normalizedDistance = (distanceToHillCenter - riverOuterRadius) / (valleyRadius - riverOuterRadius);
                        const groundHeight = Math.max(0, normalizedDistance * 2);
                        
                        if (newPosition.y <= groundHeight + 0.5) {
                            newPosition.y = groundHeight;
                            if (!isJumping || jumpVelocity <= 0) {
                                isOnGround = true;
                                isOnAnySurface = true;
                                isJumping = false;
                                jumpVelocity = 0;
                            }
                        }
                    }
                }
            }
            
            if (!collisionDetected) {
                player.position.x = newPosition.x;
                player.position.z = newPosition.z;
                player.position.y = newPosition.y;
            } else {
                velocity.set(0, 0, 0);
            }
            
            updateJumpAndGravity();
            
            if (velocity.length() > 0.1) {
                const targetAngle = Math.atan2(velocity.x, velocity.z);
                playerModel.rotation.y = targetAngle;
            }
        }

        function updateJumpAndGravity() {
            if (isJumping) {
                // ŸÜÿ∏ÿßŸÖ ŸÇŸÅÿ≤ ÿ™ÿ±ÿ®ŸäÿπŸä Ÿàÿ£ŸÉÿ´ÿ± ÿÆŸÅÿ© ÿπŸÑŸâ ÿßŸÑŸäÿßÿ®ÿ≥ÿ©
                // ÿßŸÑŸÇŸÅÿ≤ÿ© ÿßŸÑÿ™ÿ±ÿ®ŸäÿπŸäÿ© ÿ™ÿπŸÜŸä ÿ£ŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ© ÿ™ÿ™ŸÜÿßŸÇÿµ ÿ®ÿ¥ŸÉŸÑ ÿÆÿ∑Ÿä ŸÖŸÖÿß ŸäŸÜÿ™ÿ¨ ŸÖÿ≥ÿßÿ±ÿßŸã ŸÖŸÉÿßŸÅÿ¶ÿßŸã (parabolic)
                // ŸÑÿ¨ÿπŸÑŸáÿß ÿ£ŸÉÿ´ÿ± ÿÆŸÅÿ©ÿå ÿ≥ŸÜÿ≤ŸäÿØ ŸÇŸàÿ© ÿßŸÑŸÇŸÅÿ≤ ŸÇŸÑŸäŸÑÿßŸã ŸàŸÜÿ≤ŸäÿØ ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ© ŸÑÿ≥ÿ±ÿπÿ© ÿßŸÑŸáÿ®Ÿàÿ∑
                player.position.y += jumpVelocity;
                jumpVelocity -= gravity * 1.5; // ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ© ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÇŸÅÿ≤ ŸÑŸäŸÉŸàŸÜ ÿ£ŸÉÿ´ÿ± ÿÆŸÅÿ© (Snappy)
                
                // ÿ•ÿ∞ÿß ÿ£ÿµÿ®ÿ≠ ÿßŸÑŸÑÿßÿπÿ® ŸäŸáÿ®ÿ∑ÿå ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜŸá ŸÑŸÖ ŸäÿπÿØ ÿπŸÑŸâ ÿ≥ÿ∑ÿ≠
                if (jumpVelocity < 0) {
                    isOnGround = false;
                    isOnAnySurface = false;
                }
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ™ŸÑÿßŸÑ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑŸÇŸÅÿ≤
                if (jumpVelocity <= 0.1) { // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ŸÇŸÅÿ≤ ÿ£ÿπŸÑŸâ ŸÇŸÑŸäŸÑÿßŸã
                    for (const hill of hills) {
                        const hillPos = hill.position;
                        const hillData = hill.userData;
                        const distanceToHillCenter = Math.sqrt(
                            Math.pow(player.position.x - hillPos.x, 2) + 
                            Math.pow(player.position.z - hillPos.z, 2)
                        );
                        
                        if (distanceToHillCenter < hillData.radius) {
                            const normalizedDistance = distanceToHillCenter / hillData.radius;
                            const hillSurfaceHeight = hillCheck.playerSurfaceY; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿØŸÇŸäŸÇ ŸÖŸÜ isInsideHill
                            
                            if (player.position.y <= hillSurfaceHeight || (jumpVelocity < 0 && player.position.y < hillSurfaceHeight + 0.5)) { // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÑÿßÿπÿ® ŸÑŸÖ ŸäÿÆÿ™ÿ±ŸÇ ÿßŸÑÿ≥ÿ∑ÿ≠ ÿ£Ÿà ÿ£ŸÜŸá ŸÅŸä ÿ≠ÿßŸÑÿ© Ÿáÿ®Ÿàÿ∑ ŸàŸÇÿ±Ÿäÿ® ŸÖŸÜ ÿßŸÑÿ≥ÿ∑ÿ≠
                                player.position.y = hillSurfaceHeight;
                                isJumping = false;
                                jumpVelocity = 0;
                                isOnGround = true;
                                isOnAnySurface = true;
                                // FIX: Reset horizontal velocity to prevent sliding
                                velocity.x = 0;
                                velocity.z = 0;
                                // return; // Removed to allow other collision checks to run
                            }
                        }
                    }
                }
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ£ÿ±ÿ∂ ÿßŸÑÿπÿßÿØŸäÿ©
                let onRiverRock = false;
                if (typeof riverRocks !== 'undefined') {
                    for (let r of riverRocks) {
                        const d = Math.sqrt((player.position.x - r.position.x)**2 + (player.position.z - r.position.z)**2);
                        if (d < 6) { 
                            onRiverRock = true; 
                            if (player.position.y <= 0.2 && jumpVelocity <= 0) {
                                player.position.y = 0.2;
                                isJumping = false;
                                jumpVelocity = 0;
                                isOnGround = true;
                                isOnAnySurface = true;
                            }
                            break;
                        }
                    }
                }
                
                if (!onRiverRock && jumpVelocity <= 0) {
                    const hillCenterX = -50;
                    const hillCenterZ = -50;
                    const riverInnerRadius = 40
                    const riverOuterRadius = 180;
                    const valleyRadius = 230;
                    
                    const distanceToHillCenter = Math.sqrt(
                        Math.pow(player.position.x - hillCenterX, 2) + 
                        Math.pow(player.position.z - hillCenterZ, 2)
                    );
                    
                    if (distanceToHillCenter > valleyRadius) {
                        if (player.position.y <= 0) {
                            player.position.y = 0;
                            isJumping = false;
                            jumpVelocity = 0;
                            isOnGround = true;
                            isOnAnySurface = true;
                        }
                    } else if (distanceToHillCenter >= riverInnerRadius && distanceToHillCenter <= riverOuterRadius) {
                        isOnGround = false;
                    } else if (distanceToHillCenter < riverInnerRadius) {
                        const groundHeight = 1.2;
                        if (player.position.y <= groundHeight) {
                            player.position.y = groundHeight;
                            isJumping = false;
                            jumpVelocity = 0;
                            isOnGround = true;
                            isOnAnySurface = true;
                        }
                    } else {
                        const normalizedDistance = (distanceToHillCenter - riverOuterRadius) / (valleyRadius - riverOuterRadius);
                        const groundHeight = Math.max(0, normalizedDistance * 2);
                        
                        if (player.position.y <= groundHeight) {
                            player.position.y = groundHeight;
                            isJumping = false;
                            jumpVelocity = 0;
                            isOnGround = true;
                            isOnAnySurface = true;
                        }
                    }
                }
            } else if (!isOnGround && !isOnAnySurface) {
                // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ© ŸÅŸÇÿ∑ ÿπŸÜÿØŸÖÿß ŸÑÿß ŸäŸÉŸàŸÜ ÿπŸÑŸâ ÿ≥ÿ∑ÿ≠
                // ÿ®ÿØÿ° ÿßŸÑÿ≥ŸÇŸàÿ∑ ÿ®ÿ≥ÿ±ÿπÿ© ŸÖÿ™ÿ≤ÿßŸäÿØÿ©
                if (!isJumping) {
                    isJumping = true;
                    jumpVelocity = 0; // ÿßŸÑÿ®ÿØÿ° ÿ®ÿ≥ÿ±ÿπÿ© ÿµŸÅÿ± ŸÑŸÑÿ≥ŸÇŸàÿ∑
                }
                player.position.y -= gravity * 1.5;
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸáÿ®Ÿàÿ∑ ÿπŸÑŸâ ÿ™ŸÑÿ© ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ≥ŸÇŸàÿ∑
                let onRiverRock = false;
                if (typeof riverRocks !== 'undefined') {
                    for (let r of riverRocks) {
                        const d = Math.sqrt((player.position.x - r.position.x)**2 + (player.position.z - r.position.z)**2);
                        if (d < 6) { 
                            onRiverRock = true; 
                            if (player.position.y <= 0.2) {
                                player.position.y = 0.2;
                                isOnGround = true;
                                isOnAnySurface = true;
                            }
                            break;
                        }
                    }
                }
                
                if (!onRiverRock && player.position.y <= 0 && !(player.position.z < -25 && player.position.z > -115)) {
                    if (!(player.position.z < -25 && player.position.z > -115)) player.position.y = 0;
                    isOnGround = true;
                    isOnAnySurface = true;
                } else {
                    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÑÿßŸÑ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ≥ŸÇŸàÿ∑
                    for (const hill of hills) {
                        const hillPos = hill.position;
                        const hillData = hill.userData;
                        const distanceToHillCenter = Math.sqrt(
                            Math.pow(player.position.x - hillPos.x, 2) + 
                            Math.pow(player.position.z - hillPos.z, 2)
                        );
                        
                        if (distanceToHillCenter < hillData.radius) {
                            const normalizedDistance = distanceToHillCenter / hillData.radius;
                            const hillSurfaceHeight = hillCheck.playerSurfaceY; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿØŸÇŸäŸÇ ŸÖŸÜ isInsideHill
                            
                            if (player.position.y <= hillSurfaceHeight || (jumpVelocity < 0 && player.position.y < hillSurfaceHeight + 0.5)) { // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÑÿßÿπÿ® ŸÑŸÖ ŸäÿÆÿ™ÿ±ŸÇ ÿßŸÑÿ≥ÿ∑ÿ≠ ÿ£Ÿà ÿ£ŸÜŸá ŸÅŸä ÿ≠ÿßŸÑÿ© Ÿáÿ®Ÿàÿ∑ ŸàŸÇÿ±Ÿäÿ® ŸÖŸÜ ÿßŸÑÿ≥ÿ∑ÿ≠
                                player.position.y = hillSurfaceHeight;
                                isOnGround = true;
                                isOnAnySurface = true;
                                // FIX: Reset horizontal velocity to prevent sliding
                                velocity.x = 0;
                                velocity.z = 0;
                                // return; // Removed to allow other collision checks to run
                            }
                        }
                    }
                }
            }
        }

        function jump() {
            // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑŸÇŸÅÿ≤ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿπŸÑŸâ ÿ£Ÿä ÿ≥ÿ∑ÿ≠ ŸàŸÑŸÖ ŸäŸÉŸÜ ŸÅŸä ÿ≠ÿßŸÑÿ© ŸÇŸÅÿ≤ ÿ≠ÿßŸÑŸäÿ©
            if ((isOnGround || isOnAnySurface) && !isJumping && !isRoundTransition) {
                isJumping = true;
                isOnGround = false;
                isOnAnySurface = false;
                // ÿ≤ŸäÿßÿØÿ© ŸÇŸàÿ© ÿßŸÑŸÇŸÅÿ≤ ÿßŸÑÿßÿ®ÿ™ÿØÿßÿ¶Ÿäÿ© ŸÑÿ™ÿ™ŸÜÿßÿ≥ÿ® ŸÖÿπ ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ© ÿßŸÑÿ£ÿπŸÑŸâ Ÿàÿ™ŸÉŸàŸÜ ÿ£ŸÉÿ´ÿ± ÿÆŸÅÿ©
                const jumpPowerMultiplier = 1.4; 
                jumpVelocity = jumpPower * jumpPowerMultiplier;
                
                // ÿ™ÿ£ÿ´Ÿäÿ± ÿ®ÿµÿ±Ÿä ŸÑŸÑŸÇŸÅÿ≤
                const jumpEffect = document.createElement("div");
                jumpEffect.className = "jump-effect";
                
                const playerPos = new THREE.Vector3();
                player.getWorldPosition(playerPos);
                const vector = new THREE.Vector3(
                    playerPos.x,
                    playerPos.y,
                    playerPos.z
                );
                vector.project(camera);

                jumpEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                jumpEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
                document.querySelector(".scene-container").appendChild(jumpEffect);

                setTimeout(() => {
                    jumpEffect.remove();
                }, 500);
                
                playJumpSound();
            }
        }

        // ===== ÿØŸàÿßŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÖŸÜ ÿßŸÑÿ¨ŸàŸäÿ≥ÿ™ŸäŸÉ ŸàŸÑŸàÿ≠ÿ© ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ =====
        function updatePlayerMovementFromJoystick() {
            if (!joystickActive) {
                velocity.multiplyScalar(deceleration);
                return;
            }

            const speed = Math.sqrt(joystickDirection.x ** 2 + joystickDirection.y ** 2);
            const normalizedSpeed = Math.min(speed, 1);

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const forward = new THREE.Vector3()
                .copy(direction)
                .setY(0)
                .normalize();
            const right = new THREE.Vector3().crossVectors(
                forward,
                new THREE.Vector3(0, 1, 0)
            );

            const moveVector = new THREE.Vector3();
            moveVector.addScaledVector(right, joystickDirection.x * normalizedSpeed * maxSpeed);
            moveVector.addScaledVector(forward, -joystickDirection.y * normalizedSpeed * maxSpeed);

            velocity.x = moveVector.x;
            velocity.z = moveVector.z;
        }

        function updatePlayerMovementFromKeyboard() {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const forward = new THREE.Vector3()
                .copy(direction)
                .setY(0)
                .normalize();
            const right = new THREE.Vector3().crossVectors(
                forward,
                new THREE.Vector3(0, 1, 0)
            );

            const moveVector = new THREE.Vector3();

            if (keys.w || keys.arrowup) {
                moveVector.add(forward);
            }
            if (keys.s || keys.arrowdown) {
                moveVector.sub(forward);
            }
            if (keys.a || keys.arrowleft) {
                moveVector.sub(right);
            }
            if (keys.d || keys.arrowright) {
                moveVector.add(right);
            }

            if (moveVector.length() > 0) {
                moveVector.normalize();
                velocity.x = moveVector.x * maxSpeed;
                velocity.z = moveVector.z * maxSpeed;
            } else {
                velocity.multiplyScalar(deceleration);
            }
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ™ŸÖÿ≥ÿßÿ≠ =====
        function createCrocodileAtOasis(x, z) {
            const crocGroup = new THREE.Group();
            const COLORS = { SKIN: 0x387042, BELLY: 0x939d89, TEETH: 0xffffff, EYES: 0xffc400 };
            const HEAD_WIDTH = 1.8;
            const HEAD_LENGTH = 4.5;
            const HEAD_HEIGHT = 1.2;
            const LOWER_JAW_HEIGHT = 0.6;
            const BODY_LENGTH = 7;
            const PIVOT_X = BODY_LENGTH / 2;
            const HEAD_PROTRUSION_OFFSET = 0.5;
            const UPPER_JAW_PROTRUSION_OFFSET = 0.3;

            const skinMaterial = new THREE.MeshPhongMaterial({ color: COLORS.SKIN, flatShading: true });
            const bellyMaterial = new THREE.MeshPhongMaterial({ color: COLORS.BELLY, flatShading: true });
            const teethMaterial = new THREE.MeshPhongMaterial({ color: COLORS.TEETH, flatShading: true });
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: COLORS.EYES, flatShading: true });

            const bodyGeometry = new THREE.BoxGeometry(BODY_LENGTH, 1.5, 3);
            const body = new THREE.Mesh(bodyGeometry, skinMaterial);
            body.position.y = 1.5;
            body.castShadow = true;
            crocGroup.add(body);

            const bellyGeometry = new THREE.BoxGeometry(BODY_LENGTH + 0.1, 0.2, 3.1);
            const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
            belly.position.y = 0.75;
            crocGroup.add(belly);

            const headGroup = new THREE.Group();
            headGroup.position.set(PIVOT_X + HEAD_PROTRUSION_OFFSET, 0, 0);
            crocGroup.add(headGroup);
            
            const movingJawGroup = new THREE.Group();
            movingJawGroup.position.set(0, 0, 0);
            headGroup.add(movingJawGroup);

            const upperSnoutGeometry = new THREE.BoxGeometry(HEAD_LENGTH, HEAD_HEIGHT, HEAD_WIDTH);
            const upperSnout = new THREE.Mesh(upperSnoutGeometry, skinMaterial);
            upperSnout.position.set(HEAD_LENGTH / 2 + UPPER_JAW_PROTRUSION_OFFSET, 1.5 + HEAD_HEIGHT/2, 0);
            upperSnout.castShadow = true;
            movingJawGroup.add(upperSnout);

            const fixedLowerJawGroup = new THREE.Group();
            headGroup.add(fixedLowerJawGroup);
            const jawGeometry = new THREE.BoxGeometry(HEAD_LENGTH, LOWER_JAW_HEIGHT, HEAD_WIDTH);
            const jaw = new THREE.Mesh(jawGeometry, skinMaterial);
            jaw.position.set(HEAD_LENGTH / 2, 1.1 + LOWER_JAW_HEIGHT/2, 0);
            jaw.castShadow = true;
            fixedLowerJawGroup.add(jaw);

            function createTooth(isLower = false) {
                const toothGeometry = new THREE.ConeGeometry(0.1, 0.4, 8);
                const tooth = new THREE.Mesh(toothGeometry, teethMaterial);
                tooth.castShadow = true;
                if (!isLower) tooth.rotation.x = Math.PI;
                return tooth;
            }
            
            const toothCount = 8;
            for (let i = 0; i < toothCount; i++) {
                const x = HEAD_LENGTH * (0.05 + i * 0.12);
                const zOffset = HEAD_WIDTH / 2 - 0.05;
                const upperToothY = 1.5;
                const rightUpperTooth = createTooth(false);
                rightUpperTooth.position.set(x + UPPER_JAW_PROTRUSION_OFFSET, upperToothY, zOffset);
                movingJawGroup.add(rightUpperTooth);
                const leftUpperTooth = createTooth(false);
                leftUpperTooth.position.set(x + UPPER_JAW_PROTRUSION_OFFSET, upperToothY, -zOffset);
                movingJawGroup.add(leftUpperTooth);
                const lowerToothY = 1.1 + LOWER_JAW_HEIGHT;
                const rightLowerTooth = createTooth(true);
                rightLowerTooth.position.set(x, lowerToothY, zOffset);
                fixedLowerJawGroup.add(rightLowerTooth);
                const leftLowerTooth = createTooth(true);
                leftLowerTooth.position.set(x, lowerToothY, -zOffset);
                fixedLowerJawGroup.add(leftLowerTooth);
            }
            
            const socketLengthX = 1.5;
            const socketHeightY = 0.8;
            const socketWidthZ = HEAD_WIDTH + 1.2;
            const eyeSocketGeometry = new THREE.BoxGeometry(socketLengthX, socketHeightY, socketWidthZ);
            const eyeSocket = new THREE.Mesh(eyeSocketGeometry, skinMaterial);
            const eyeSocketYCenter = 1.5 + socketHeightY / 2;
            eyeSocket.position.set(-0.3, eyeSocketYCenter, 0);
            eyeSocket.castShadow = true;
            headGroup.add(eyeSocket);

            const eyeY = eyeSocketYCenter + socketHeightY / 2 + 0.3;
            const eyeZOffset = socketWidthZ / 2 - 0.3;
            const eyeX = eyeSocket.position.x + 0.3;
            const rightEyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const rightEye = new THREE.Mesh(rightEyeGeometry, eyeMaterial);
            rightEye.position.set(eyeX, eyeY, eyeZOffset);
            headGroup.add(rightEye);
            const rightPupilGeometry = new THREE.BoxGeometry(0.05, 0.4, 0.05);
            const rightPupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const rightPupil = new THREE.Mesh(rightPupilGeometry, rightPupilMaterial);
            rightPupil.position.set(eyeX + 0.28, eyeY, eyeZOffset);
            headGroup.add(rightPupil);
            const leftEyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const leftEye = new THREE.Mesh(leftEyeGeometry, eyeMaterial);
            leftEye.position.set(eyeX, eyeY, -eyeZOffset);
            headGroup.add(leftEye);
            const leftPupil = new THREE.Mesh(rightPupilGeometry, rightPupilMaterial);
            leftPupil.position.set(eyeX + 0.28, eyeY, -eyeZOffset);
            headGroup.add(leftPupil);
            
            function createScute() {
                const scuteGeometry = new THREE.BoxGeometry(0.3, 0.5, 0.8);
                const scute = new THREE.Mesh(scuteGeometry, skinMaterial);
                scute.castShadow = true;
                scute.rotation.x = -Math.PI / 16;
                return scute;
            }
            
            const scuteHeight = 0.5;
            const tailSegments = 6;
            let currentTailPos = -(BODY_LENGTH / 2) + 0.1;
            let currentWidth = 3;
            const segmentLength = 1.5;

            for (let i = 0; i < tailSegments; i++) {
                const segmentHeight = 1.5 * (1 - i * 0.1);
                const tailGeometry = new THREE.BoxGeometry(segmentLength, segmentHeight, currentWidth);
                const tailSegment = new THREE.Mesh(tailGeometry, skinMaterial);
                const segmentCenterY = segmentHeight / 2;
                const segmentCenterX = currentTailPos - segmentLength / 2;
                tailSegment.position.set(segmentCenterX, segmentCenterY, 0);
                tailSegment.castShadow = true;
                crocGroup.add(tailSegment);
                const scute = createScute();
                const scuteY = segmentCenterY + segmentHeight / 2 + scuteHeight / 2;
                scute.position.set(segmentCenterX, scuteY, 0);
                crocGroup.add(scute);
                currentTailPos -= segmentLength;
                currentWidth *= 0.8;
            }

            const bodyScuteCount = 3;
            const bodyTopY = 1.5 + 1.5 / 2;
            const bodyScuteY = bodyTopY + scuteHeight / 2;
            const scuteStartPos = PIVOT_X - 1.5;
            const scuteEndPos = -(BODY_LENGTH / 2) + 0.5;
            const scuteRange = scuteStartPos - scuteEndPos;
            const bodyScuteStep = scuteRange / (bodyScuteCount + 1);

            for (let i = 0; i < bodyScuteCount; i++) {
                const scute = createScute();
                const scuteX = scuteStartPos - (i + 1) * bodyScuteStep;
                scute.position.set(scuteX, bodyScuteY, 0);
                crocGroup.add(scute);
            }

            const legGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.6);
            const legMaterial = new THREE.MeshPhongMaterial({ color: COLORS.SKIN * 0.8 });
            const legSeparationX = BODY_LENGTH * 0.3;

            const addLeg = (x, z, rotationZ) => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(x, 0.5, z);
                leg.rotation.z = rotationZ;
                leg.castShadow = true;
                crocGroup.add(leg);
            };

            addLeg(legSeparationX, 1.5, Math.PI / 16);
            addLeg(legSeparationX, -1.5, -Math.PI / 16);
            addLeg(-legSeparationX, 1.5, Math.PI / 16);
            addLeg(-legSeparationX, -1.5, -Math.PI / 16);

            crocGroup.position.set(x, 0, z);
            crocGroup.rotation.y = Math.PI;
            
            crocGroup.userData = {
                movingJaw: movingJawGroup,
                mouthSpeed: 0.04,
                mouthDirection: 1,
                maxRotation: Math.PI / 4,
                type: 'crocodile',
                health: 100,
                damage: 20,
                detectionRange: 60, // ÿ≤ŸäÿßÿØÿ© ŸÖÿØŸâ ŸÖŸÑÿßÿ≠ŸÇÿ© ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ÿ®ÿ¥ŸÉŸÑ ŸÉÿ®Ÿäÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                attackRange: 15,
                isAggressive: true,
                isChasing: false,
                speed: 0.95, // ÿ™ŸÖÿ™ ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ≥ÿ±ÿπÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ÿ®ÿ¥ŸÉŸÑ ŸÉÿ®Ÿäÿ± ŸÑÿ™ÿµÿ®ÿ≠ ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ÿ≥ÿ±Ÿäÿπÿ© ÿ¨ÿØÿßŸã
                lastAttackTime: 0,
                attackCooldown: 1500, // ÿ™ŸÇŸÑŸäŸÑ ŸàŸÇÿ™ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ®ŸäŸÜ ÿßŸÑŸáÿ¨ŸÖÿßÿ™
                collisionDamage: 30, // ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ∂ÿ±ÿ± ŸÇŸÑŸäŸÑÿßŸã
                lastCollisionTime: 0,
                collisionCooldown: 1000, // ÿ™ŸÇŸÑŸäŸÑ ŸàŸÇÿ™ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ÿ®ŸäŸÜ ÿßŸÑÿ™ÿµÿßÿØŸÖÿßÿ™
                walkCycle: 0,
                rotationSpeed: 0.15, // ÿ≤ŸäÿßÿØÿ© ÿ≥ÿ±ÿπÿ© ÿßŸÑÿØŸàÿ±ÿßŸÜ ŸÑÿ™ŸÑÿßÿ≠ŸÇ ÿßŸÑŸÑÿßÿπÿ® ÿ®ŸÖÿ±ŸàŸÜÿ© ÿ£ŸÉÿ®ÿ±
                oasisCenterX: 100,
                oasisCenterZ: 100,
                oasisRadius: 40,
                moveTimer: 0,
                currentDirection: new THREE.Vector3(0, 0, 1),
                changeDirectionTime: 0
            };

            scene.add(crocGroup);
            return crocGroup;
        }

        function animateCrocodileJaw(crocodile, deltaTime) {
            if (!crocodile.userData.movingJaw) return;
            const { movingJaw, mouthSpeed, mouthDirection, maxRotation } = crocodile.userData;
            movingJaw.rotation.z += mouthSpeed * mouthDirection;
            if (movingJaw.rotation.z > maxRotation) {
                crocodile.userData.mouthDirection = -1;
            } else if (movingJaw.rotation.z < 0) {
                movingJaw.rotation.z = 0;
                crocodile.userData.mouthDirection = 1;
            }
        }

        function animateCrocodileLegs(crocodile, deltaTime) {
            if (crocodile.userData.isChasing) {
                crocodile.userData.walkCycle += deltaTime * 8;
                const legSwing = Math.sin(crocodile.userData.walkCycle) * 0.3;
                for (let i = 2; i < 6; i++) {
                    if (crocodile.children[i]) {
                        if (i % 2 === 0) {
                            crocodile.children[i].rotation.x = legSwing;
                        } else {
                            crocodile.children[i].rotation.x = -legSwing;
                        }
                    }
                }
            }
        }

        function showCrocodileDamageEffect(x, y, z, damage) {
            const damageDiv = document.createElement("div");
            damageDiv.className = "crocodile-damage-effect";
            damageDiv.textContent = `-${damage}`;
            damageDiv.style.color = "#ff0000";
            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);
            damageDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            damageDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(damageDiv);
            setTimeout(() => { damageDiv.remove(); }, 1000);
        }

        function checkCrocodileDamageFromStick() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            const attackRadius = 6;
            const damage = 50;
            const crocsToDamage = [];
            for (let i = crocodiles.length - 1; i >= 0; i--) {
                const croc = crocodiles[i];
                const crocPos = new THREE.Vector3();
                croc.getWorldPosition(crocPos);
                const distance = crocPos.distanceTo(playerPos);
                if (distance < attackRadius) {
                    crocsToDamage.push(croc);
                }
            }
            for (const croc of crocsToDamage) {
                croc.userData.health -= damage;
                if (croc.userData.health <= 0) {
                    scene.remove(croc);
                    const index = crocodiles.indexOf(croc);
                    if (index > -1) crocodiles.splice(index, 1);
                    coins.push(createCoin(croc.position.x, croc.position.z, 30));
                    score += 30;
                    playMonsterExplosionSound();
                    if (Math.random() < 0.4) {
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 20);
                        showHealthGainEffect(croc.position.x, croc.position.y + 2, croc.position.z, 20);
                    }
                }
            }
            if (crocsToDamage.length > 0) {
                effects.push({
                    particles: createStickSwingEffect(playerPos),
                    createdAt: Date.now(),
                });
                updateUI();
            }
        }

        function checkCrocodileDamageFromBomb(explosionRadius, damage) {
            player.getWorldPosition(_v1); const playerPos = _v1;
            const crocsToDamage = [];
            for (let i = crocodiles.length - 1; i >= 0; i--) {
                const croc = crocodiles[i];
                const crocPos = new THREE.Vector3();
                croc.getWorldPosition(crocPos);
                const distance = crocPos.distanceTo(playerPos);
                if (distance < explosionRadius) {
                    crocsToDamage.push(croc);
                }
            }
            for (const croc of crocsToDamage) {
                croc.userData.health -= damage;
                if (croc.userData.health <= 0) {
                    scene.remove(croc);
                    const index = crocodiles.indexOf(croc);
                    if (index > -1) crocodiles.splice(index, 1);
                    coins.push(createCoin(croc.position.x, croc.position.z, 30));
                    score += 30;
                    playMonsterExplosionSound();
                    if (Math.random() < 0.5) {
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 25);
                        showHealthGainEffect(croc.position.x, croc.position.y + 2, croc.position.z, 25);
                    }
                }
            }
        }

        function addCrocodilesToOasis() {
            // ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ÿ™ÿ∏Ÿáÿ± ŸÅŸÇÿ∑ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 3 ŸàŸÖÿß ŸÅŸàŸÇÿå ŸàŸÑŸÉŸÜ ŸÑŸäÿ≥ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4 ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            if (round < 3 || round === 4) return;

            // ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 3ÿå ÿ™ÿ∏Ÿáÿ± 5 ÿ®ÿ≠Ÿäÿ±ÿßÿ™ ÿ™ŸÖÿßÿ≥Ÿäÿ≠ ŸÖÿ™ÿ®ÿßÿπÿØÿ© ÿ¨ÿØÿßŸãÿå ŸàŸÅŸä ŸÉŸÑ ÿ®ÿ≠Ÿäÿ±ÿ© ÿÆÿ±ŸàŸÅ ÿ®ŸäŸÜ ÿ™ŸÖÿ≥ÿßÿ≠ŸäŸÜ
            const oasisPositions = [
                { x: 380, z: 380 },
                { x: -380, z: -380 },
                { x: 380, z: -380 },
                { x: -380, z: 380 },
                { x: 0, z: 420 }
            ];

            const lakesToSpawn = round === 3 ? 5 : 2;
            
            for (let i = 0; i < Math.min(lakesToSpawn, oasisPositions.length); i++) {
                if (round === 3) {
                    // ŸÖŸÜÿ∑ŸÇ ÿÆÿßÿµ ŸÑŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÑÿ´: ÿÆÿ±ŸàŸÅ ÿ®ŸäŸÜ ÿ™ŸÖÿ≥ÿßÿ≠ŸäŸÜ
                    const pos = oasisPositions[i];
                    
                    // 1. ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿÆÿ±ŸàŸÅ ŸÅŸä ÿßŸÑŸÖÿ±ŸÉÿ≤
                    const sheep = createSheep(pos.x, 2, pos.z);
                    sheeps.push(sheep);
                    totalSheeps++;
                    
                    // 2. ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÖÿ≥ÿßÿ≠ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ¨ÿßŸÜÿ®ŸäŸÜ
                    const crocDist = 12;
                    const croc1 = createCrocodileAtOasis(pos.x + crocDist, pos.z);
                    croc1.userData.oasisCenterX = pos.x;
                    croc1.userData.oasisCenterZ = pos.z;
                    crocodiles.push(croc1);
                    
                    const croc2 = createCrocodileAtOasis(pos.x - crocDist, pos.z);
                    croc2.userData.oasisCenterX = pos.x;
                    croc2.userData.oasisCenterZ = pos.z;
                    crocodiles.push(croc2);
                } else {
                    spawnOasisWithCrocodiles(oasisPositions[i].x, oasisPositions[i].z, 2);
                }
            }
        }

        function spawnOasisWithCrocodiles(x, z, baseCrocCount) {
            // ÿ•ŸÜÿ¥ÿßÿ° ÿ™ÿ¨ŸÖÿπ ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ÿ≠ŸàŸÑ ÿßŸÑŸàÿßÿ≠ÿ© ÿ®ŸÖÿ≥ÿßŸÅÿßÿ™ ŸÖÿ™ÿ®ÿßÿπÿØÿ© ÿ¨ÿØÿßŸã ÿπŸÑŸâ ÿßŸÑÿ£ÿ∑ÿ±ÿßŸÅ
            const crocodileCount = baseCrocCount; 
            for (let i = 0; i < crocodileCount; i++) {
                const angle = (i / crocodileCount) * Math.PI * 2 + (Math.random() * 0.5);
                const distance = 10 + Math.random() * 10; // ÿ™ŸÇÿ±Ÿäÿ® ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ŸÖŸÜ ÿßŸÑÿÆÿ±ŸàŸÅ ŸÅŸä ÿßŸÑŸÖÿ±ŸÉÿ≤
                const crocX = x + Math.cos(angle) * distance;
                const crocZ = z + Math.sin(angle) * distance;
                const crocodile = createCrocodileAtOasis(crocX, crocZ);
                
                crocodile.userData.oasisCenterX = x;
                crocodile.userData.oasisCenterZ = z;
                
                crocodiles.push(crocodile);
            }

            // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿÆÿ±ŸàŸÅ ŸÅŸä ŸÖÿ±ŸÉÿ≤ ÿßŸÑŸàÿßÿ≠ÿ© ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉŸÜ ÿØÿßÿÆŸÑ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ±
            const hillCenterX = -50;
            const hillCenterZ = -50;
            const riverInnerRadius = 40;
            let riverOuterRadius = 180;
            if (typeof round !== 'undefined' && round === 2) {
                riverOuterRadius = 180;
            }
            
            const distanceToRiverCenter = Math.sqrt(
                Math.pow(x - hillCenterX, 2) + 
                Math.pow(z - hillCenterZ, 2)
            );
            
            // ŸÅŸÇÿ∑ ÿ£ÿ∂ŸÅ ÿßŸÑÿÆÿ±ŸàŸÅ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸàÿßÿ≠ÿ© ÿÆÿßÿ±ÿ¨ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ± (ÿ™ŸÖ ÿßŸÑÿ™ÿπÿ∑ŸäŸÑ ŸÅŸä 3 Ÿà 4 ŸÑÿ∂ŸÖÿßŸÜ ÿ®ŸÇÿßÿ° 5 ÿÆÿ±ÿßŸÅ ŸÅŸÇÿ∑)
            if (round !== 3 && round !== 4) {
                if (distanceToRiverCenter < riverInnerRadius || distanceToRiverCenter > riverOuterRadius) {
                    const sheep = createSheep(x, 2, z);
                    sheeps.push(sheep);
                    totalSheeps++;
                }
            }

            // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ≠ÿ±ÿßÿ≥ ÿßŸÑŸÖŸÇÿ±ÿ®ŸäŸÜ ÿ™ŸÖÿßŸÖÿßŸã ŸÑÿ¨ÿπŸÑ ÿßŸÑŸÜÿ¨ÿßÿ© ÿ£ÿ≥ŸáŸÑ
            // ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ŸÉŸàÿØ guardCount ŸÑÿ∂ŸÖÿßŸÜ ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ ÿ™ŸÖÿßÿ≥Ÿäÿ≠ ŸÖŸÑÿ™ÿµŸÇÿ© ÿ®ÿßŸÑÿÆÿ±ŸàŸÅ
        }

         function moveCrocodiles() {
            const now = Date.now();
            player.getWorldPosition(_v1); const playerPos = _v1;

            crocodiles.forEach((croc) => {
                const crocData = croc.userData;
                const crocPos = new THREE.Vector3();
                croc.getWorldPosition(crocPos);
                
                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ŸÅŸÇÿ∑ (ÿ™ŸÖÿ™ ÿ≤ŸäÿßÿØÿ© ÿßŸÑŸÜÿ∑ÿßŸÇ ŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿ≥ÿ±ÿπÿ© ŸàÿßŸÑŸÖÿØŸâ ÿßŸÑÿ¨ÿØŸäÿØŸäŸÜ)
                const distToPlayer = crocPos.distanceTo(playerPos);
                if (distToPlayer > 300 && !crocData.isChasing) return;
                
                const distanceToPlayer = crocPos.distanceTo(playerPos);
                const distanceToOasisCenter = Math.sqrt(
                    Math.pow(playerPos.x - crocData.oasisCenterX, 2) + 
                    Math.pow(playerPos.z - crocData.oasisCenterZ, 2)
                );
                
                const checkHillCollision = (newPos) => {
                    const hillCheck = isInsideHill(newPos, false);
                    if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.9) {
                        return true;
                    }
                    return false;
                };
                
                // ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ÿ™Ÿáÿßÿ¨ŸÖ ÿßŸÑŸÑÿßÿπÿ® ÿ•ÿ∞ÿß ÿßŸÇÿ™ÿ±ÿ® ŸÖŸÜ ÿßŸÑŸàÿßÿ≠ÿ© ÿ£Ÿà ÿßŸÇÿ™ÿ±ÿ® ŸÖŸÜ ÿßŸÑÿ™ŸÖÿ≥ÿßÿ≠ ŸÜŸÅÿ≥Ÿá
                const isPlayerNearOasis = distanceToOasisCenter < crocData.oasisRadius;
                const isPlayerNearCroc = distanceToPlayer < crocData.detectionRange;

                if (isPlayerNearOasis || isPlayerNearCroc) {
                    crocData.isChasing = true;
                    const directionToPlayer = new THREE.Vector3().subVectors(playerPos, crocPos);
                    directionToPlayer.y = 0;
                    directionToPlayer.normalize();
                    
                    // ÿ™ÿØŸàŸäÿ± ÿßŸÑÿ™ŸÖÿ≥ÿßÿ≠ ÿ®ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸÑÿßÿπÿ®
                    const targetAngle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    const currentAngle = croc.rotation.y;
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    croc.rotation.y += angleDiff * crocData.rotationSpeed;

                    // ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿ®ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸÑÿßÿπÿ®
                    const forwardDirection = new THREE.Vector3(
                        Math.sin(croc.rotation.y),
                        0,
                        Math.cos(croc.rotation.y)
                    );
                    
                    // ÿ≥ÿ±ÿπÿ© ŸÖÿ∑ÿßÿ±ÿØÿ© ÿ£ÿπŸÑŸâ ŸÇŸÑŸäŸÑÿßŸã
                    const chaseSpeed = crocData.speed * 1.5;
                    const newPosition = crocPos.clone().add(forwardDirection.multiplyScalar(chaseSpeed));
                    
                    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ÿµÿßÿØŸÖ ŸÖÿπ ÿßŸÑÿ™ŸÑÿßŸÑ ÿ£Ÿà ÿßŸÑÿÆÿ±Ÿàÿ¨ ŸÖŸÜ ÿ≠ÿØŸàÿØ ÿßŸÑÿπÿßŸÑŸÖ
                    if (!checkHillCollision(newPosition)) {
                        croc.position.x = newPosition.x;
                        croc.position.z = newPosition.z;
                    }
                    
                    // ÿ•ÿ≠ÿØÿßÿ´ ÿ∂ÿ±ÿ± ÿπŸÜÿØ ÿßŸÑÿ™ÿµÿßÿØŸÖ ÿßŸÑŸÇÿ±Ÿäÿ® ÿ¨ÿØÿßŸã
                    if (distanceToPlayer < 4) {
                        if (now - crocData.lastCollisionTime > crocData.collisionCooldown) {
                            playerHealth -= crocData.collisionDamage;
                            crocData.lastCollisionTime = now;
                            
                            // ÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿßŸÑÿ∂ÿ±ÿ±
                            showPlayerDamageEffect();
                            playMonsterExplosionSound(); // ÿµŸàÿ™ Ÿáÿ¨ŸàŸÖ ŸÇŸàŸä
                            updateUI();
                            showCrocodileDamageEffect(crocPos.x, crocPos.y + 3, crocPos.z, crocData.collisionDamage);
                            
                            // ÿØŸÅÿπ ÿßŸÑŸÑÿßÿπÿ® ŸÇŸÑŸäŸÑÿßŸã ŸÑŸÑÿÆŸÑŸÅ ÿπŸÜÿØ Ÿáÿ¨ŸàŸÖ ÿßŸÑÿ™ŸÖÿ≥ÿßÿ≠
                            const pushBack = directionToPlayer.clone().negate().multiplyScalar(5);
                            player.position.add(pushBack);
                        }
                    }
                } else {
                    crocData.isChasing = false;
                    if (now - crocData.changeDirectionTime > 3000) {
                        const randomAngle = Math.random() * Math.PI * 2;
                        crocData.currentDirection.set(
                            Math.sin(randomAngle),
                            0,
                            Math.cos(randomAngle)
                        );
                        crocData.changeDirectionTime = now;
                    }
                    const targetAngle = Math.atan2(crocData.currentDirection.x, crocData.currentDirection.z);
                    const currentAngle = croc.rotation.y;
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    croc.rotation.y += angleDiff * 0.02;
                    const forwardDirection = new THREE.Vector3(
                        Math.sin(croc.rotation.y),
                        0,
                        Math.cos(croc.rotation.y)
                    );
                    const newPosition = crocPos.clone().add(forwardDirection.multiplyScalar(crocData.speed * 0.3));
                    
                    if (!checkHillCollision(newPosition)) {
                        const newDistanceToOasisCenter = Math.sqrt(
                            Math.pow(newPosition.x - crocData.oasisCenterX, 2) + 
                            Math.pow(newPosition.z - crocData.oasisCenterZ, 2)
                        );
                        if (newDistanceToOasisCenter < crocData.oasisRadius) {
                            croc.position.x = newPosition.x;
                            croc.position.z = newPosition.z;
                        }
                    }
                }
            });
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÜÿ≥ÿ± ÿßŸÑŸÖÿ≠ÿ≥ŸÜ =====
        function createEnhancedEagle(x, y, z) {
            const eagle = new THREE.Group();

            // ÿÆÿßŸÖÿßÿ™ ŸÖÿ≠ÿ≥ŸÜÿ©
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.7,
                metalness: 0.1,
                flatShading: true
            });

            const featherMaterial = new THREE.MeshStandardMaterial({
                color: 0x5C4033,
                roughness: 0.8,
                metalness: 0.0,
                flatShading: true
            });

            const whiteFeatherMaterial = new THREE.MeshStandardMaterial({
                color: 0xeaeaea,
                roughness: 0.9,
                metalness: 0.0,
                flatShading: true
            });

            const beakMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFC107,
                roughness: 0.3,
                metalness: 0.4,
            });

            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.0,
                metalness: 0.9
            });

            // 1. ÿßŸÑÿ¨ÿ≥ŸÖ
            const chestGeo = new THREE.IcosahedronGeometry(0.8, 1);
            const chest = new THREE.Mesh(chestGeo, bodyMaterial);
            chest.position.y = 0.2;
            chest.scale.set(0.9, 1.1, 0.9);
            chest.castShadow = true;
            eagle.add(chest);

            // 2. ÿßŸÑÿ±ÿ£ÿ≥ ŸàÿßŸÑÿ±ŸÇÿ®ÿ©
            const neckGeo = new THREE.CylinderGeometry(0.35, 0.6, 0.7, 7);
            const neck = new THREE.Mesh(neckGeo, bodyMaterial);
            neck.position.set(0, 0.9, 0.3);
            neck.rotation.x = -0.3;
            neck.castShadow = true;
            eagle.add(neck);

            // ÿ±ÿ£ÿ≥ ÿ£ÿ®Ÿäÿ∂
            const headGeo = new THREE.IcosahedronGeometry(0.48, 1);
            const head = new THREE.Mesh(headGeo, whiteFeatherMaterial);
            head.position.set(0, 1.4, 0.55);
            head.castShadow = true;
            eagle.add(head);

            // 3. ÿßŸÑŸÖŸÜŸÇÿßÿ± ÿßŸÑŸÖÿ≠ÿ≥ŸÜ
            const beakGeo = new THREE.ConeGeometry(0.14, 0.65, 8);
            const beak = new THREE.Mesh(beakGeo, beakMaterial);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 1.35, 1.0);
            beak.castShadow = true;
            eagle.add(beak);

            // 4. ÿßŸÑÿπŸäŸàŸÜ
            function addEye(x) {
                const eyeGroup = new THREE.Group();
                
                const eyeGeo = new THREE.SphereGeometry(0.12, 12, 12);
                const eye = new THREE.Mesh(eyeGeo, eyeMaterial);
                eye.scale.set(0.8, 1.0, 1.3); 
                eye.rotation.y = x > 0 ? -0.4 : 0.4;
                eye.position.z = 0.01;
                eyeGroup.add(eye);

                const shineGeo = new THREE.SphereGeometry(0.02, 8, 8);
                const shine = new THREE.Mesh(shineGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                shine.position.set(x > 0 ? 0.04 : -0.04, 0.04, 0.1);
                eyeGroup.add(shine);
                
                eyeGroup.position.set(x, 1.45, 0.82);
                eagle.add(eyeGroup);
            }
            addEye(0.26);
            addEye(-0.26);

            // 5. ÿßŸÑÿ£ÿ¨ŸÜÿ≠ÿ© ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ©
            function createWing(isLeft) {
                const wingGroup = new THREE.Group();
                const sign = isLeft ? 1 : -1;

                // ÿßŸÑÿ∞ÿ±ÿßÿπ ÿßŸÑÿπŸÑŸàŸäÿ©
                const armGeo = new THREE.BoxGeometry(1.2, 0.2, 0.7);
                const arm = new THREE.Mesh(armGeo, bodyMaterial);
                arm.position.set(sign * 0.6, 0, 0);
                wingGroup.add(arm);

                // ÿ±Ÿäÿ¥ ÿßŸÑÿ∑Ÿäÿ±ÿßŸÜ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä
                const featherCount = 7;
                for (let i = 0; i < featherCount; i++) {
                    const fGeo = new THREE.BoxGeometry(2.0, 0.04, 0.35);
                    const feather = new THREE.Mesh(fGeo, featherMaterial);
                    
                    feather.position.set(sign * (1.1 + i * 0.32), -0.05, -i * 0.22); 
                    feather.rotation.y = sign * (-0.15 - (i * 0.12)); 
                    feather.rotation.z = sign * (0.05); 
                    feather.castShadow = true;
                    wingGroup.add(feather);
                }

                // ÿ±Ÿäÿ¥ ÿßŸÑÿ™ÿ∫ÿ∑Ÿäÿ©
                for (let i = 0; i < 5; i++) {
                    const fGeo = new THREE.BoxGeometry(1.1, 0.06, 0.25);
                    const feather = new THREE.Mesh(fGeo, bodyMaterial);
                    feather.position.set(sign * (0.8 + i * 0.25), 0.08, 0.15 - i * 0.15); 
                    feather.rotation.y = sign * (-0.1 - (i * 0.1));
                    wingGroup.add(feather);
                }

                wingGroup.position.set(sign * 0.65, 0.8, 0);
                wingGroup.rotation.z = sign * (Math.PI / 6);
                wingGroup.rotation.x = Math.PI / 10;
                eagle.add(wingGroup);
                
                return wingGroup;
            }

            const leftWing = createWing(true);
            const rightWing = createWing(false);

            // 6. ÿßŸÑÿ∞ŸäŸÑ
            const tailGroup = new THREE.Group();
            for(let i = -2; i <= 2; i++) {
                const tGeo = new THREE.BoxGeometry(0.35, 0.04, 1.3);
                const tailFeather = new THREE.Mesh(tGeo, whiteFeatherMaterial);
                tailFeather.position.set(i * 0.16, 0, 0);
                tailFeather.rotation.y = i * 0.12;
                tailGroup.add(tailFeather);
            }
            tailGroup.position.set(0, -0.1, -1.0);
            tailGroup.rotation.x = -0.2;
            eagle.add(tailGroup);

            // 7. ÿßŸÑŸÖÿÆÿßŸÑÿ®
            function createClaw(xPos) {
                const clawGroup = new THREE.Group();
                const legGeo = new THREE.CylinderGeometry(0.09, 0.06, 0.45);
                const leg = new THREE.Mesh(legGeo, beakMaterial);
                leg.rotation.x = 0.4;
                clawGroup.add(leg);

                for(let i=-1; i<=1; i+=2) {
                   const talonGeo = new THREE.ConeGeometry(0.03, 0.18, 8);
                   const talon = new THREE.Mesh(talonGeo, new THREE.MeshStandardMaterial({color: 0x050505, roughness: 0.1}));
                   talon.position.set(i*0.1, -0.22, 0.12);
                   talon.rotation.x = -1.2;
                   clawGroup.add(talon);
                }
                
                clawGroup.position.set(xPos, -0.45, 0.25);
                eagle.add(clawGroup);
            }
            createClaw(0.3);
            createClaw(-0.3);

            eagle.rotation.x = Math.PI / 7;
            eagle.position.set(x, y, z);
            
            // ÿÆÿµÿßÿ¶ÿµ ÿßŸÑŸÜÿ≥ÿ± ÿßŸÑŸÖÿ≠ÿ≥ŸÜÿ©
            eagle.userData = {
                type: 'eagle',
                health: 240,
                maxHealth: 240,
                damage: 8,
                speed: 0.15,
                isAttacking: false,
                isFlying: true,
                flyHeight: y,
                flyRadius: 8,
                flyAngle: Math.random() * Math.PI * 2,
                target: null,
                lastAttackTime: 0,
                attackCooldown: 3000,
                collisionDamage: 10,
                lastCollisionTime: 0,
                collisionCooldown: 2000,
                value: 40,
                leftWing: leftWing,
                rightWing: rightWing,
                wingFlapSpeed: 0.02,
                wingFlapAngle: 0,
                detectionRange: 180, // ÿ≤ŸäÿßÿØÿ© ŸÖÿØŸâ ŸÖŸÑÿßÿ≠ŸÇÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿ®ÿ¥ŸÉŸÑ ÿ•ÿ∂ÿßŸÅŸä ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                attackRange: 10,
                isAggressive: true,
                isChasing: false,
                rotationSpeed: 0.05,
                homeX: x,
                homeY: y,
                homeZ: z,
                swarmId: Math.floor(Math.random() * 3),
                swarmOffset: new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 3
                ),
                attackPattern: Math.floor(Math.random() * 3),
                lastSoundTime: 0,
                soundCooldown: 5000 + Math.random() * 5000
            };

            return eagle;
        }

        // ===== ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿ•ŸÑŸâ ÿßŸÑÿ™ŸÑÿ© =====
        function addEaglesToHill(hill) {
            // ÿßŸÑŸÜÿ≥Ÿàÿ± ÿ™ÿ∏Ÿáÿ± ŸÅŸÇÿ∑ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4 ŸàŸÖÿß ŸÅŸàŸÇÿå ŸàŸÑŸÉŸÜ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4 ÿ™ŸàŸÑÿØ ÿ≠ŸàŸÑ ÿßŸÑÿÆÿ±ÿßŸÅ ŸÅŸÇÿ∑
            if (round < 4 || round === 4) return;

            const hillPos = hill.position;
            const hillHeight = hill.userData.height;
            const hillRadius = hill.userData.radius;
            
            const eagleCount = 3 + Math.floor(Math.random() * 2);
            
            for (let i = 0; i < eagleCount; i++) {
                const angle = (i / eagleCount) * Math.PI * 2 + Math.random() * 0.5;
                const distance = hillRadius * 0.6 + Math.random() * 5;
                const eagleX = hillPos.x + Math.cos(angle) * distance;
                const eagleZ = hillPos.z + Math.sin(angle) * distance;
                const eagleY = hillHeight + 5 + Math.random() * 3;
                
                const eagle = createEnhancedEagle(eagleX, eagleY, eagleZ);
                
                eagle.userData.flyRadius = distance;
                eagle.userData.flyHeight = eagleY;
                eagle.userData.flyAngle = angle;
                eagle.userData.homeX = hillPos.x;
                eagle.userData.homeY = eagleY;
                eagle.userData.homeZ = hillPos.z;
                eagle.userData.hill = hill;
                eagle.userData.swarmId = i % 3;
                
                eagles.push(eagle);
                scene.add(eagle);
            }
        }

        // ===== ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑŸÖÿ≠ÿ≥ŸÜÿ© - ÿ™ŸÖ ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠ =====
        function moveEagles() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            const now = Date.now();

            eagles.forEach((eagle) => {
                const eagleData = eagle.userData;
                const eaglePos = new THREE.Vector3();
                eagle.getWorldPosition(eaglePos);
                
                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ŸÅŸÇÿ∑ ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿßÿ≥ÿ©
                const distToPlayer = eaglePos.distanceTo(playerPos);
                if (distToPlayer > 200 && !eagleData.isChasing) return;
                
                // ÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑÿ£ÿ¨ŸÜÿ≠ÿ©
                eagleData.wingFlapAngle += eagleData.wingFlapSpeed;
                const wingFlap = Math.sin(eagleData.wingFlapAngle) * 0.3;
                
                if (eagleData.leftWing && eagleData.rightWing) {
                    eagleData.leftWing.rotation.z = (Math.PI / 6) + wingFlap;
                    eagleData.rightWing.rotation.z = (-Math.PI / 6) - wingFlap;
                }
                
                const distanceToPlayer = eaglePos.distanceTo(playerPos);
                const distanceToHome = Math.sqrt(
                    Math.pow(eaglePos.x - eagleData.homeX, 2) + 
                    Math.pow(eaglePos.z - eagleData.homeZ, 2)
                );
                
                // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿ™ÿ≠ŸÑŸäŸÇ ÿßŸÑŸÜÿ≥ÿ±
                if (now - eagleData.lastSoundTime > eagleData.soundCooldown && distanceToPlayer < 60) {
                    playEagleWingsSound();
                    eagleData.lastSoundTime = now;
                    eagleData.soundCooldown = 3000 + Math.random() * 7000;
                }
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ™ŸÑÿßŸÑ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ≠ÿ±ŸÉÿ©
                const checkHillCollision = (newPos) => {
                    const hillCheck = isInsideHill(newPos, false);
                    if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.8) {
                        return true;
                    }
                    return false;
                };
                
                // ÿ™ÿ≠ÿØŸäÿØ ŸÜŸÖÿ∑ ÿßŸÑŸáÿ¨ŸàŸÖ
                let attackBehavior = 'direct';
                switch(eagleData.attackPattern) {
                    case 0:
                        attackBehavior = 'direct';
                        break;
                    case 1:
                        attackBehavior = 'circular';
                        break;
                    case 2:
                        attackBehavior = 'dive';
                        break;
                }
                
                // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ£ŸÇÿ±ÿ® ÿÆÿ±ŸàŸÅ ŸÑŸÑŸÜÿ≥ÿ± ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4 ŸàŸÖÿß ŸÅŸàŸÇ
                let nearestSheep = null;
                let minSheepDist = Infinity;
                if (round >= 4 && sheeps.length > 0) {
                    sheeps.forEach(s => {
                        const sPos = new THREE.Vector3();
                        s.getWorldPosition(sPos);
                        const d = eaglePos.distanceTo(sPos);
                        if (d < minSheepDist) {
                            minSheepDist = d;
                            nearestSheep = sPos;
                        }
                    });
                }

                if (nearestSheep && minSheepDist < 150 && !eagleData.isChasing) {
                    // ÿßŸÑÿ™ÿ¨ŸÖÿπ ÿ≠ŸàŸÑ ÿßŸÑÿÆÿ±ŸàŸÅ
                    let targetPosition = nearestSheep.clone();
                    targetPosition.y += 10 + Math.sin(now * 0.001 + eagleData.swarmId) * 5;
                    
                    const directionToTarget = new THREE.Vector3().subVectors(targetPosition, eaglePos);
                    const targetAngle = Math.atan2(directionToTarget.x, directionToTarget.z);
                    const angleDiff = targetAngle - eagle.rotation.y;
                    const normalizedAngleDiff = ((angleDiff + Math.PI) % (Math.PI * 2)) - Math.PI;
                    eagle.rotation.y += normalizedAngleDiff * eagleData.rotationSpeed;
                    
                    const forwardDirection = new THREE.Vector3(Math.sin(eagle.rotation.y), 0, Math.cos(eagle.rotation.y));
                    eagle.position.add(forwardDirection.multiplyScalar(eagleData.speed * 0.5));
                    eagle.position.y += (targetPosition.y - eagle.position.y) * 0.02;
                } else if (distanceToPlayer < eagleData.detectionRange && distanceToHome < 80) {
                    eagleData.isChasing = true;
                    eagleData.isFlying = true;
                    
                    let targetPosition = new THREE.Vector3();
                    const directionToPlayer = new THREE.Vector3().subVectors(playerPos, eaglePos);
                    directionToPlayer.normalize();
                    
                    // ÿ™ÿ∑ÿ®ŸäŸÇ ŸÜŸÖÿ∑ ÿßŸÑŸáÿ¨ŸàŸÖ - ÿ™ÿ≠ÿ≥ŸäŸÜ ŸÑÿ¨ÿπŸÑ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿ™ŸÜÿÆŸÅÿ∂ ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÑÿßÿπÿ®
                    switch(attackBehavior) {
                        case 'direct':
                            // ÿßŸÑŸáÿ¨ŸàŸÖ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± - ÿßŸÑÿßŸÜÿÆŸÅÿßÿ∂ ÿ™ÿØÿ±Ÿäÿ¨ŸäÿßŸã ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÑÿßÿπÿ®
                            if (distanceToPlayer < 20) {
                                targetPosition.copy(playerPos);
                                targetPosition.y = playerPos.y + 2; // ÿßŸÜÿÆŸÅÿßÿ∂ ŸÑŸÖÿ≥ÿ™ŸàŸâ ŸÇÿ±Ÿäÿ® ŸÖŸÜ ÿßŸÑŸÑÿßÿπÿ®
                            } else {
                                targetPosition.copy(playerPos);
                                targetPosition.y = playerPos.y + 5;
                            }
                            break;
                            
                        case 'circular':
                            const circularAngle = now * 0.001 + eagleData.swarmId * Math.PI * 0.66;
                            const circularRadius = 10;
                            // ÿßŸÑÿØŸàÿ±ÿßŸÜ ÿ≠ŸàŸÑ ÿßŸÑŸÑÿßÿπÿ® ŸÖÿπ ÿßŸÑÿßŸÜÿÆŸÅÿßÿ∂ ÿßŸÑÿ™ÿØÿ±Ÿäÿ¨Ÿä
                            if (distanceToPlayer < 15) {
                                targetPosition.set(
                                    playerPos.x + Math.cos(circularAngle) * circularRadius,
                                    playerPos.y + 2 + Math.sin(now * 0.002) * 1,
                                    playerPos.z + Math.sin(circularAngle) * circularRadius
                                );
                            } else {
                                targetPosition.set(
                                    playerPos.x + Math.cos(circularAngle) * circularRadius,
                                    playerPos.y + 8 + Math.sin(now * 0.002) * 3,
                                    playerPos.z + Math.sin(circularAngle) * circularRadius
                                );
                            }
                            break;
                            
                        case 'dive':
                            // ÿßŸÑÿßŸÜŸÇÿ∂ÿßÿ∂ - Ÿäÿ®ÿØÿ£ ŸÖŸÜ ÿßŸÑÿ£ÿπŸÑŸâ ŸàŸäŸÜÿÆŸÅÿ∂ ÿ®ÿ≥ÿ±ÿπÿ©
                            if (distanceToPlayer < 15) {
                                targetPosition.set(
                                    playerPos.x,
                                    playerPos.y + 1, // ÿßŸÜÿÆŸÅÿßÿ∂ ÿ¥ÿØŸäÿØ ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÑÿßÿπÿ®
                                    playerPos.z
                                );
                            } else {
                                targetPosition.set(
                                    playerPos.x,
                                    playerPos.y + 15,
                                    playerPos.z
                                );
                            }
                            break;
                    }
                    
                    // ÿ•ÿ∂ÿßŸÅÿ© ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑÿ≥ÿ±ÿ®
                    targetPosition.add(eagleData.swarmOffset);
                    
                    // ÿ≠ÿ≥ÿßÿ® ÿ≤ÿßŸàŸäÿ© ÿßŸÑÿØŸàÿ±ÿßŸÜ - ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿßÿ™ÿ¨ÿßŸá
                    const directionToTarget = new THREE.Vector3().subVectors(targetPosition, eaglePos);
                    const targetAngle = Math.atan2(directionToTarget.x, directionToTarget.z);
                    
                    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ™ÿØÿ±ÿ¨ ŸÅŸä ÿßŸÑÿØŸàÿ±ÿßŸÜ
                    const angleDiff = targetAngle - eagle.rotation.y;
                    const normalizedAngleDiff = ((angleDiff + Math.PI) % (Math.PI * 2)) - Math.PI;
                    
                    eagle.rotation.y += normalizedAngleDiff * eagleData.rotationSpeed;
                    
                    // ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÜÿ≠Ÿà ÿßŸÑŸáÿØŸÅ
                    const forwardDirection = new THREE.Vector3(
                        Math.sin(eagle.rotation.y),
                        0,
                        Math.cos(eagle.rotation.y)
                    );
                    
                    let speedMultiplier = 1.0;
                    // ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ≥ÿ±ÿπÿ© ÿπŸÜÿØ ÿßŸÑŸáÿ¨ŸàŸÖ
                    if (attackBehavior === 'dive' && distanceToPlayer < 20) {
                        speedMultiplier = 2.5; // ÿ≥ÿ±ÿπÿ© ÿ£ŸÉÿ®ÿ± ŸÑŸÑÿßŸÜŸÇÿ∂ÿßÿ∂
                    } else if (distanceToPlayer < 15) {
                        speedMultiplier = 1.8; // ÿ≥ÿ±ÿπÿ© ŸÖÿ™Ÿàÿ≥ÿ∑ÿ© ÿπŸÜÿØ ÿßŸÑÿßŸÇÿ™ÿ±ÿßÿ®
                    }
                    
                    const newPosition = eaglePos.clone().add(forwardDirection.multiplyScalar(eagleData.speed * speedMultiplier));
                    
                    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ™ŸÑÿßŸÑ
                    if (checkHillCollision(newPosition)) {
                        newPosition.y = Math.max(newPosition.y, eagleData.homeY + 10);
                    }
                    
                    // ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßÿ±ÿ™ŸÅÿßÿπ ŸÖŸÜÿßÿ≥ÿ® ÿ≠ÿ≥ÿ® ŸÜŸÖÿ∑ ÿßŸÑŸáÿ¨ŸàŸÖ - ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿßŸÜÿÆŸÅÿßÿ∂ ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÑÿßÿπÿ®
                    if (attackBehavior === 'dive' && distanceToPlayer < 25) {
                        // ÿßŸÜŸÇÿ∂ÿßÿ∂ ÿ≥ÿ±Ÿäÿπ ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÑÿßÿπÿ®
                        newPosition.y = playerPos.y + 1.5;
                    } else if (distanceToPlayer < 20) {
                        // ÿπŸÜÿØ ÿßŸÑÿßŸÇÿ™ÿ±ÿßÿ®ÿå ÿßŸÑÿßŸÜÿÆŸÅÿßÿ∂ ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÑÿßÿπÿ® ŸÑŸÑŸÖŸÜÿßŸàÿ±ÿ©
                        newPosition.y = playerPos.y + 2;
                    } else {
                        newPosition.y = targetPosition.y + Math.sin(now * 0.002 + eagleData.swarmId) * 2;
                    }
                    
                    eagle.position.x = newPosition.x;
                    eagle.position.y = newPosition.y;
                    eagle.position.z = newPosition.z;
                    
                    // ÿßŸÑŸáÿ¨ŸàŸÖ ÿπŸÑŸâ ÿßŸÑŸÑÿßÿπÿ® - ÿ™ÿ≠ÿ≥ŸäŸÜ ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿ∂ÿ±ÿ± ŸÅÿπŸÑŸä ŸàŸÖŸÜÿßŸàÿ±ÿ©
                    if (distanceToPlayer < eagleData.attackRange) {
                        if (now - eagleData.lastAttackTime > eagleData.attackCooldown) {
                            eagleData.lastAttackTime = now;
                            playEagleSound();
                            
                            // ÿ•ŸÑÿ≠ÿßŸÇ ÿßŸÑÿ∂ÿ±ÿ± ÿ®ÿßŸÑŸÑÿßÿπÿ® (ÿÆŸÅÿ∂ ÿßŸÑÿµÿ≠ÿ© ŸÇŸÑŸäŸÑÿßŸã)
                            const damageAmount = 5; // ÿ∂ÿ±ÿ± ÿ®ÿ≥Ÿäÿ∑ ŸÉŸÖÿß ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                            playerHealth -= damageAmount;
                            showPlayerDamageEffect();
                            playBeeAttackSound();
                            updateUI();
                            
                            // ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑŸÖŸÜÿßŸàÿ±ÿ© ÿ®ÿπÿØ ÿßŸÑŸáÿ¨ŸàŸÖ: ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿ®ÿ≥ÿ±ÿπÿ© ŸÑŸÑÿ£ÿπŸÑŸâ
                            eagleData.isChasing = false; // ÿßŸÑÿ™ŸàŸÇŸÅ ÿπŸÜ ÿßŸÑŸÖÿ∑ÿßÿ±ÿØÿ© ŸÖÿ§ŸÇÿ™ÿßŸã ŸÑŸÑŸÖŸÜÿßŸàÿ±ÿ©
                            setTimeout(() => { eagleData.isChasing = true; }, 2000);
                            
                            const attackEffect = document.createElement("div");
                            attackEffect.className = "crocodile-damage-effect";
                            attackEffect.textContent = `Ÿáÿ¨ŸàŸÖ ÿßŸÑŸÜÿ≥ÿ±! -${damageAmount}`;
                            attackEffect.style.color = "#ff3300";
                            attackEffect.style.fontSize = "22px";
                            attackEffect.style.fontWeight = "bold";
                            
                            const vector = new THREE.Vector3(eaglePos.x, eaglePos.y + 2, eaglePos.z);
                            vector.project(camera);
                            attackEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                            attackEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
                            document.querySelector(".scene-container").appendChild(attackEffect);
                            
                            setTimeout(() => {
                                attackEffect.remove();
                            }, 1500);
                        }
                    }
                    
                    // ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑŸÑÿßÿπÿ®
                    if (distanceToPlayer < 4) {
                        if (now - eagleData.lastCollisionTime > eagleData.collisionCooldown) {
                            // playerHealth -= eagleData.collisionDamage; // Damage removed as requested
                            eagleData.lastCollisionTime = now;
                            showPlayerDamageEffect();
                            playBeeAttackSound();
                            updateUI();
                            
                            const damageEffect = document.createElement("div");
                            damageEffect.className = "wolf-health-effect";
                            damageEffect.textContent = `-${eagleData.collisionDamage}`;
                            damageEffect.style.color = "#ff5500";
                            
                            const vector = new THREE.Vector3(eaglePos.x, eaglePos.y + 3, eaglePos.z);
                            vector.project(camera);
                            damageEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                            damageEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
                            document.querySelector(".scene-container").appendChild(damageEffect);
                            
                            setTimeout(() => {
                                damageEffect.remove();
                            }, 1000);
                        }
                    }
                } else {
                    eagleData.isChasing = false;
                    
                    // ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÇ ÿ≠ŸàŸÑ ÿßŸÑÿ™ŸÑÿ© ÿ®ÿ¥ŸÉŸÑ ÿ¨ŸÖÿßÿπŸä
                    eagleData.flyAngle += 0.01;
                    
                    // ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ≥ÿ±ÿ®
                    const swarmOffsetX = Math.sin(now * 0.001 + eagleData.swarmId * 2) * 2;
                    const swarmOffsetZ = Math.cos(now * 0.001 + eagleData.swarmId * 2) * 2;
                    const swarmOffsetY = Math.sin(now * 0.002 + eagleData.swarmId) * 1.5;
                    
                    const targetX = eagleData.homeX + Math.cos(eagleData.flyAngle) * eagleData.flyRadius + swarmOffsetX;
                    const targetZ = eagleData.homeZ + Math.sin(eagleData.flyAngle) * eagleData.flyRadius + swarmOffsetZ;
                    const targetY = eagleData.homeY + Math.sin(now * 0.001 + eagleData.flyAngle) * 1.5 + swarmOffsetY;
                    
                    // ÿßŸÑÿ™ÿ≠ÿ±ŸÉ ŸÜÿ≠Ÿà ŸÖŸàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÇ
                    eagle.position.x += (targetX - eagle.position.x) * 0.05;
                    eagle.position.y += (targetY - eagle.position.y) * 0.05;
                    eagle.position.z += (targetZ - eagle.position.z) * 0.05;
                    
                    // ÿßŸÑÿ™Ÿàÿ¨Ÿá ŸÜÿ≠Ÿà ÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ≠ÿ±ŸÉÿ© - ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿßÿ™ÿ¨ÿßŸá
                    const lookDirection = new THREE.Vector3(
                        -Math.sin(eagleData.flyAngle + Math.PI/2),
                        0,
                        Math.cos(eagleData.flyAngle + Math.PI/2)
                    );
                    
                    const targetRotationY = Math.atan2(lookDirection.x, lookDirection.z);
                    const currentRotation = eagle.rotation.y;
                    let rotationDiff = targetRotationY - currentRotation;
                    
                    while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
                    while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
                    
                    eagle.rotation.y += rotationDiff * 0.1;
                }
            });
        }

        // ===== ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ÿµÿßÿ®ÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿ®ÿßŸÑÿπÿµÿß =====
        function checkEagleDamageFromStick() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            const attackRadius = 8;
            const damage = 60;
            
            const eaglesToDamage = [];
            
            for (let i = eagles.length - 1; i >= 0; i--) {
                const eagle = eagles[i];
                const eaglePos = new THREE.Vector3();
                eagle.getWorldPosition(eaglePos);
                
                const horizontalDistance = Math.sqrt(
                    Math.pow(eaglePos.x - playerPos.x, 2) + 
                    Math.pow(eaglePos.z - playerPos.z, 2)
                );
                
                const verticalDistance = Math.abs(eaglePos.y - playerPos.y);
                
                if (horizontalDistance < attackRadius && verticalDistance < 15) {
                    eaglesToDamage.push(eagle);
                }
            }
            
            for (const eagle of eaglesToDamage) {
                eagle.userData.health -= damage;
                
                if (eagle.userData.health <= 0) {
                    scene.remove(eagle);
                    const index = eagles.indexOf(eagle);
                    if (index > -1) eagles.splice(index, 1);
                    coins.push(createCoin(eagle.position.x, eagle.position.z, eagle.userData.value));
                    score += eagle.userData.value;
                    playMonsterExplosionSound();
                    
                    if (Math.random() < 0.4) {
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 15);
                        showHealthGainEffect(eagle.position.x, eagle.position.y + 2, eagle.position.z, 15);
                    }
                    
                    const killEffect = document.createElement("div");
                    killEffect.className = "success-message";
                    killEffect.style.fontSize = "20px";
                    killEffect.textContent = "ÿ™ŸÖ ŸÇÿ™ŸÑ ÿßŸÑŸÜÿ≥ÿ±! +" + eagle.userData.value + " ŸÜŸÇÿ∑ÿ©";
                    document.body.appendChild(killEffect);
                    
                    setTimeout(() => {
                        killEffect.remove();
                    }, 2000);
                } else {
                    const damageEffect = document.createElement("div");
                    damageEffect.className = "wolf-health-effect";
                    damageEffect.textContent = `-${damage}`;
                    damageEffect.style.color = "#ff3333";
                    
                    const vector = new THREE.Vector3(eagle.position.x, eagle.position.y + 3, eagle.position.z);
                    vector.project(camera);
                    damageEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                    damageEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
                    document.querySelector(".scene-container").appendChild(damageEffect);
                    
                    setTimeout(() => {
                        damageEffect.remove();
                    }, 1000);
                }
            }
            
            return eaglesToDamage.length;
        }

        // ===== ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ÿµÿßÿ®ÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿ®ÿßŸÑŸÇŸÜÿ®ŸÑÿ© =====
        function checkEagleDamageFromBomb(explosionRadius, damage) {
            player.getWorldPosition(_v1); const playerPos = _v1;
            
            const eaglesToDamage = [];
            
            for (let i = eagles.length - 1; i >= 0; i--) {
                const eagle = eagles[i];
                const eaglePos = new THREE.Vector3();
                eagle.getWorldPosition(eaglePos);
                
                const distance = eaglePos.distanceTo(playerPos);
                if (distance < explosionRadius) {
                    eaglesToDamage.push(eagle);
                }
            }
            
            for (const eagle of eaglesToDamage) {
                eagle.userData.health -= damage * 1.5;
                
                if (eagle.userData.health <= 0) {
                    scene.remove(eagle);
                    const index = eagles.indexOf(eagle);
                    if (index > -1) eagles.splice(index, 1);
                    coins.push(createCoin(eagle.position.x, eagle.position.z, eagle.userData.value));
                    score += eagle.userData.value;
                    playMonsterExplosionSound();
                    
                    if (Math.random() < 0.5) {
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 20);
                        showHealthGainEffect(eagle.position.x, eagle.position.y + 2, eagle.position.z, 20);
                    }
                }
            }
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÜÿ≥ÿ± ÿßŸÑÿÆÿßÿ∑ŸÅ =====
        function createSnatchingEagle(x, z) {
            const eagle = createEnhancedEagle(x, 8, z); // ÿßÿ±ÿ™ŸÅÿßÿπ ŸÖŸÜÿÆŸÅÿ∂ 8 ÿ®ÿØŸÑÿßŸã ŸÖŸÜ 15+
            
            // ÿ™ÿπÿØŸäŸÑ ÿÆÿµÿßÿ¶ÿµ ÿßŸÑŸÜÿ≥ÿ± ÿßŸÑÿÆÿßÿ∑ŸÅ
            eagle.userData = {
                ...eagle.userData,
                type: 'snatchingEagle',
                isSnatching: false,
                hasSheep: false,
                stolenSheep: null,
                snatchRange: 10,
                collisionDamage: 5, // Minor damage on collision with player
                swoopHeight: 1.5, // New property for swoop height (player level)
                snatchCooldown: 0,
                escapeSpeed: 0.25,
                escapeDirection: new THREE.Vector3(),
                escapeTimer: 0,
                maxEscapeTime: 10000, // 10 ÿ´ŸàÿßŸÜŸä ŸÑŸÑŸáÿ±Ÿàÿ®
                returnSheepValue: 20, // ŸÜŸÇÿßÿ∑ ÿπŸÜÿØ ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑÿÆÿ±ŸàŸÅ
                flyHeight: 4, // ÿßÿ±ÿ™ŸÅÿßÿπ ŸÖŸÜÿÆŸÅÿ∂ ÿ¨ÿØÿßŸã ŸÑŸÑÿ∑Ÿäÿ±ÿßŸÜ ŸÉŸÖÿß ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                minFlyHeight: 5,
                maxFlyHeight: 12,
                homeX: x,
                homeZ: z,
                flyAngle: Math.random() * Math.PI * 2,
                flyRadius: 20 + Math.random() * 20
            };
            
            return eagle;
        }

        // ===== ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖ =====
        function spawnSnatchingEagles() {
            const eagleCount = 2 + Math.floor(round / 2); // ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿπÿØÿØ ŸÖÿπ ÿßŸÑÿ¨ŸàŸÑÿßÿ™
            
            for (let i = 0; i < eagleCount; i++) {
                // Ÿàÿ∂ÿπ ÿßŸÑŸÜÿ≥Ÿàÿ± ŸÅŸä ŸÖŸÜÿßÿ∑ŸÇ ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ© ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖ (ŸÑŸäÿ≥ ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ©)
                const angle = Math.random() * Math.PI * 2;
                const distance = 150 + Math.random() * 200; // ÿ®ÿπŸäÿØ ÿπŸÜ ÿßŸÑŸÖÿ±ŸÉÿ≤
                const eagleX = Math.cos(angle) * distance;
                const eagleZ = Math.sin(angle) * distance;
                
                // ÿ™ÿ¨ŸÜÿ® Ÿàÿ∂ÿπŸáÿß ÿ®ÿßŸÑŸÇÿ±ÿ® ŸÖŸÜ ÿßŸÑÿ™ŸÑÿ©
                let tooCloseToHill = false;
                for (const hill of hills) {
                    const hillPos = hill.position;
                    const distanceToHill = Math.sqrt(
                        Math.pow(eagleX - hillPos.x, 2) + 
                        Math.pow(eagleZ - hillPos.z, 2)
                    );
                    if (distanceToHill < 50) {
                        tooCloseToHill = true;
                        break;
                    }
                }
                
                if (!tooCloseToHill) {
                    const eagle = createSnatchingEagle(eagleX, eagleZ);
                    snatchingEagles.push(eagle);
                    scene.add(eagle);
                }
            }
        }

        // ===== ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© =====
        function moveSnatchingEagles() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            const now = Date.now();
            
            snatchingEagles.forEach((eagle, index) => {
                const eagleData = eagle.userData;
                const eaglePos = new THREE.Vector3();
                eagle.getWorldPosition(eaglePos);
                
                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ŸÅŸÇÿ∑
                const distToPlayer = eaglePos.distanceTo(playerPos);
                if (distToPlayer > 250 && !eagleData.isSnatching) return;
                
                // ÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑÿ£ÿ¨ŸÜÿ≠ÿ©
                eagleData.wingFlapAngle += eagleData.wingFlapSpeed;
                const wingFlap = Math.sin(eagleData.wingFlapAngle) * 0.3;
                
                if (eagleData.leftWing && eagleData.rightWing) {
                    eagleData.leftWing.rotation.z = (Math.PI / 6) + wingFlap;
                    eagleData.rightWing.rotation.z = (-Math.PI / 6) - wingFlap;
                }
                
                const distanceToPlayer = eaglePos.distanceTo(playerPos);
                
                if (eagleData.isSnatching && eagleData.hasSheep) {
                    // If the eagle is swooping, check for collision with the player
                    if (eagleData.isSwooping) {
                        const distanceToPlayer = eaglePos.distanceTo(playerPos);
                        if (distanceToPlayer < 2) { // Collision check
                            // playerHealth -= eagleData.collisionDamage; // Damage removed as requested
                            eagleData.isSwooping = false; // Stop swooping after hitting

                            // Show damage effect
                            const damageEffect = document.createElement('div');
                            damageEffect.className = 'damage-effect';
                            damageEffect.textContent = `-${eagleData.collisionDamage}`;
                            document.body.appendChild(damageEffect);
                            
                            const vector = new THREE.Vector3(playerPos.x, playerPos.y + 2, playerPos.z);
                            vector.project(camera);
                            vector.x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                            vector.y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                            damageEffect.style.left = `${vector.x}px`;
                            damageEffect.style.top = `${vector.y}px`;

                            setTimeout(() => {
                                damageEffect.remove();
                            }, 1000);
                        }
                    }
                    // ÿ≠ÿßŸÑÿ© ÿßŸÑŸáÿ±Ÿàÿ® ÿ®ÿßŸÑÿÆÿ±ŸàŸÅ
                    eagleData.escapeTimer += 16; // ÿ™ŸÇÿ±Ÿäÿ®ÿßŸã ŸÉŸÑ ÿ•ÿ∑ÿßÿ±
                    
                    if (eagleData.escapeTimer >= eagleData.maxEscapeTime) {
                        // Manus Fix: ÿßŸÑÿ™Ÿàÿ¨Ÿá ŸÜÿ≠Ÿà ÿßŸÑÿ™ŸÑÿ© ŸÇÿ®ŸÑ ÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ
                        const hillX = -50;
                        const hillZ = -50;
                        const distToHill = Math.sqrt(Math.pow(eagle.position.x - hillX, 2) + Math.pow(eagle.position.z - hillZ, 2));
                        
                        if (distToHill < 5) {
                            // ÿ•ÿ∞ÿß ŸàÿµŸÑ ŸÑŸÑÿ™ŸÑÿ©ÿå ÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ ŸàÿßŸÑÿπŸàÿØÿ©
                            eagleData.isSnatching = false;
                            eagleData.isSwooping = false;
                            eagleData.hasSheep = false;
                            eagleData.escapeTimer = 0;
                            
                            if (eagleData.stolenSheep) {
                                eagle.remove(eagleData.stolenSheep);
                                eagleData.stolenSheep = null;
                            }
                            
                            const droppedSheep = createSheep(eagle.position.x, 0, eagle.position.z);
                            sheeps.push(droppedSheep);
                            totalSheeps++;
                            showEscapeMessage(eagle.position.x, eagle.position.y + 5, eagle.position.z, "ÿ£ÿ≥ŸÇÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ©!");
                        } else {
                            // ÿßŸÑÿ™Ÿàÿ¨Ÿá ŸÜÿ≠Ÿà ÿßŸÑÿ™ŸÑÿ©
                            const dirToHill = new THREE.Vector3(hillX - eagle.position.x, 0, hillZ - eagle.position.z).normalize();
                            eagle.position.x += dirToHill.x * eagleData.escapeSpeed;
                            eagle.position.z += dirToHill.z * eagleData.escapeSpeed;
                            
                            let targetY = eagleData.flyHeight + 10; // ÿ∑Ÿäÿ±ÿßŸÜ ŸÖÿ±ÿ™ŸÅÿπ ŸÇŸÑŸäŸÑÿßŸã ÿπŸÜÿØ ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ™ŸÑÿ©
                            eagle.position.y += (targetY - eagle.position.y) * 0.1;
                            
                            eagle.lookAt(hillX, eagle.position.y, hillZ);
                        }
                    } else {
                        // ÿßŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ± ŸÅŸä ÿßŸÑŸáÿ±Ÿàÿ® ŸÖÿπ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ≠ÿØŸàÿØ
                        const worldLimit = 450;
                        const nextX = eagle.position.x + eagleData.escapeDirection.x * eagleData.escapeSpeed;
                        const nextZ = eagle.position.z + eagleData.escapeDirection.z * eagleData.escapeSpeed;

                        if (Math.abs(nextX) > worldLimit) eagleData.escapeDirection.x *= -1;
                        if (Math.abs(nextZ) > worldLimit) eagleData.escapeDirection.z *= -1;

                        eagle.position.x += eagleData.escapeDirection.x * eagleData.escapeSpeed;
                        eagle.position.z += eagleData.escapeDirection.z * eagleData.escapeSpeed;
                        
                        let targetY = eagleData.flyHeight + Math.sin(now * 0.002) * 2;
                        if (eagleData.isSwooping) targetY = playerPos.y + 1;
                        eagle.position.y += (targetY - eagle.position.y) * 0.1;
                        
                        eagle.lookAt(
                            eagle.position.x + eagleData.escapeDirection.x,
                            eagle.position.y,
                            eagle.position.z + eagleData.escapeDirection.z
                        );
                        
                        return;
                    }
                }
                
                 // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ£ŸÇÿ±ÿ® ÿÆÿ±ŸàŸÅ ŸÑŸÑŸÜÿ≥ÿ± ÿßŸÑÿÆÿßÿ∑ŸÅ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4 ŸàŸÖÿß ŸÅŸàŸÇ
                let nearestSheep = null;
                let minSheepDist = Infinity;
                if (round >= 4 && sheeps.length > 0) {
                    sheeps.forEach(s => {
                        const sPos = new THREE.Vector3();
                        s.getWorldPosition(sPos);
                        const d = eaglePos.distanceTo(sPos);
                        if (d < minSheepDist) {
                            minSheepDist = d;
                            nearestSheep = sPos;
                        }
                    });
                }

                if (nearestSheep && minSheepDist < 150 && !eagleData.isSnatching && distanceToPlayer >= eagleData.detectionRange) {
                    // ÿßŸÑÿ™ÿ¨ŸÖÿπ ÿ≠ŸàŸÑ ÿßŸÑÿÆÿ±ŸàŸÅ
                    let targetPosition = nearestSheep.clone();
                    targetPosition.y += 15 + Math.sin(now * 0.001 + index) * 5;
                    
                    const directionToTarget = new THREE.Vector3().subVectors(targetPosition, eaglePos);
                    const targetAngle = Math.atan2(directionToTarget.x, directionToTarget.z);
                    const angleDiff = targetAngle - eagle.rotation.y;
                    const normalizedAngleDiff = ((angleDiff + Math.PI) % (Math.PI * 2)) - Math.PI;
                    eagle.rotation.y += normalizedAngleDiff * eagleData.rotationSpeed;
                    
                    const forwardDirection = new THREE.Vector3(Math.sin(eagle.rotation.y), 0, Math.cos(eagle.rotation.y));
                    eagle.position.add(forwardDirection.multiplyScalar(eagleData.speed * 0.7));
                    eagle.position.y += (targetPosition.y - eagle.position.y) * 0.05;
                } else if (distanceToPlayer < eagleData.detectionRange && !eagleData.isSnatching) {
                    // Chase the player
                    const directionToPlayer = new THREE.Vector3().subVectors(playerPos, eaglePos).normalize();;
                    const targetAngle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    
                    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ™ÿØÿ±ÿ¨ ŸÅŸä ÿßŸÑÿØŸàÿ±ÿßŸÜ
                    const angleDiff = targetAngle - eagle.rotation.y;
                    const normalizedAngleDiff = ((angleDiff + Math.PI) % (Math.PI * 2)) - Math.PI;
                    eagle.rotation.y += normalizedAngleDiff * eagleData.rotationSpeed;
                    
                    // ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÜÿ≠Ÿà ÿßŸÑŸÑÿßÿπÿ®
                    const forwardDirection = new THREE.Vector3(
                        Math.sin(eagle.rotation.y),
                        0,
                        Math.cos(eagle.rotation.y)
                    );
                    
                    const newPosition = eaglePos.clone().add(forwardDirection.multiplyScalar(eagleData.speed));
                    
                    // ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßÿ±ÿ™ŸÅÿßÿπ ŸÖŸÜÿÆŸÅÿ∂
                    let targetY = eagleData.flyHeight + Math.sin(now * 0.002 + index) * 1.5;
                    if (eagleData.isSwooping) {
                        targetY = playerPos.y + 1; // Swoop down to player's height
                    }
                    newPosition.y = eagle.position.y + (targetY - eagle.position.y) * 0.1; // Smooth transition
                    
                    eagle.position.x = newPosition.x;
                    eagle.position.y = newPosition.y;
                    eagle.position.z = newPosition.z;
                    
                    // ŸÖÿ≠ÿßŸàŸÑÿ© ÿÆÿ∑ŸÅ ÿßŸÑÿÆÿ±ŸàŸÅ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÑÿßÿπÿ® ŸÑÿØŸäŸá ÿÆÿ±ŸàŸÅ
                    if (distanceToPlayer < eagleData.snatchRange && sheepCollected > 0 && 
                        now - eagleData.snatchCooldown > 5000) {
                        
                        eagleData.isSnatching = true;
                        eagleData.hasSheep = true;
                        eagleData.snatchCooldown = now;
                        
                        // ÿ•ŸÜÿ¥ÿßÿ° ÿÆÿ±ŸàŸÅ ŸÖÿ±ÿ¶Ÿä Ÿàÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸÑŸÑŸÜÿ≥ÿ±
                        const stolenSheep = createSheep(0, 0, 0);
                        stolenSheep.scale.set(0.3, 0.3, 0.3); // ÿ™ÿµÿ∫Ÿäÿ± ÿ≠ÿ¨ŸÖ ÿßŸÑÿÆÿ±ŸàŸÅ
                        stolenSheep.position.set(0, -2, 0); // Ÿàÿ∂ÿπŸá ÿ™ÿ≠ÿ™ ÿßŸÑŸÜÿ≥ÿ±
                        eagle.add(stolenSheep);
                        eagleData.stolenSheep = stolenSheep;
                        
                        // ÿ™ÿ≠ÿØŸäÿØ ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸáÿ±Ÿàÿ® ÿπÿ¥Ÿàÿßÿ¶ŸäÿßŸã
                        const escapeAngle = Math.random() * Math.PI * 2;
                        eagleData.escapeDirection.set(
                            Math.sin(escapeAngle),
                            0,
                            Math.cos(escapeAngle)
                        ).normalize();
                        
                        eagleData.escapeTimer = 0;
                        
                        // ÿÆÿµŸÖ ÿÆÿ±ŸàŸÅ ŸÖŸÜ ÿßŸÑŸÑÿßÿπÿ®
                        sheepCollected--;
                        updateUI();
                        
                        // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿÆÿ∑ŸÅ
                        showSnatchMessage(eaglePos.x, eaglePos.y + 3, eaglePos.z, "ÿ™ŸÖ ÿÆÿ∑ŸÅ ÿÆÿ±ŸàŸÅ!"); // Updated message as requested and confirmed

                    // After snatching, the eagle will swoop down and try to hit the player
                    eagleData.isSwooping = true;
                        playEagleSound();
                        
                        // ÿ™ÿ£ÿ´Ÿäÿ± ÿ®ÿµÿ±Ÿä
                        const snatchEffect = document.createElement("div");
                        snatchEffect.className = "crocodile-damage-effect";
                        snatchEffect.textContent = "‚ö†Ô∏è ÿÆÿ∑ŸÅ ÿßŸÑÿÆÿ±ŸàŸÅ!";
                        snatchEffect.style.color = "#ff0000";
                        snatchEffect.style.fontSize = "24px";
                        
                        const vector = new THREE.Vector3(eaglePos.x, eaglePos.y + 2, eaglePos.z);
                        vector.project(camera);
                        snatchEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                        snatchEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
                        document.querySelector(".scene-container").appendChild(snatchEffect);
                        
                        setTimeout(() => {
                            snatchEffect.remove();
                        }, 2000);
                    }
                } else if (!eagleData.isSnatching) {
                    // ÿßŸÑÿ∑Ÿäÿ±ÿßŸÜ ÿßŸÑÿπÿ¥Ÿàÿßÿ¶Ÿä ŸÅŸä ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©
                    eagleData.flyAngle += 0.005;
                    const flyRadius = eagleData.flyRadius;
                    
                    const targetX = eagleData.homeX + Math.cos(eagleData.flyAngle) * flyRadius;
                    const targetZ = eagleData.homeZ + Math.sin(eagleData.flyAngle) * flyRadius;
                    let targetY = eagleData.flyHeight + Math.sin(now * 0.001 + eagleData.flyAngle) * 2;
                    if (eagleData.isSwooping) {
                        targetY = playerPos.y + 1; // Swoop down to player's height
                    }
                    eagle.position.y += (targetY - eagle.position.y) * 0.05;                 
                    // ÿßŸÑÿ™ÿ≠ÿ±ŸÉ ŸÜÿ≠Ÿà ŸÖŸàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÇ
                    eagle.position.x += (targetX - eagle.position.x) * 0.02;
                    eagle.position.y += (targetY - eagle.position.y) * 0.02;
                    eagle.position.z += (targetZ - eagle.position.z) * 0.02;
                    
                    // ÿßŸÑÿ™Ÿàÿ¨Ÿá ŸÜÿ≠Ÿà ÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ≠ÿ±ŸÉÿ©
                    const lookDirection = new THREE.Vector3(
                        -Math.sin(eagleData.flyAngle + Math.PI/2),
                        0,
                        Math.cos(eagleData.flyAngle + Math.PI/2)
                    );
                    
                    const targetRotationY = Math.atan2(lookDirection.x, lookDirection.z);
                    const currentRotation = eagle.rotation.y;
                    let rotationDiff = targetRotationY - currentRotation;
                    
                    while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
                    while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
                    
                    eagle.rotation.y += rotationDiff * 0.05;
                }
            });
        }

        // ===== ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ÿµÿßÿ®ÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© ÿ®ÿßŸÑÿπÿµÿß =====
        function checkSnatchingEagleDamageFromStick() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            const attackRadius = 8;
            const damage = 60;
            
            const eaglesToDamage = [];
            
            for (let i = snatchingEagles.length - 1; i >= 0; i--) {
                const eagle = snatchingEagles[i];
                const eaglePos = new THREE.Vector3();
                eagle.getWorldPosition(eaglePos);
                
                const horizontalDistance = Math.sqrt(
                    Math.pow(eaglePos.x - playerPos.x, 2) + 
                    Math.pow(eaglePos.z - playerPos.z, 2)
                );
                
                const verticalDistance = Math.abs(eaglePos.y - playerPos.y);
                
                if (horizontalDistance < attackRadius && verticalDistance < 10) {
                    eaglesToDamage.push(eagle);
                }
            }
            
            for (const eagle of eaglesToDamage) {
                const eagleData = eagle.userData;
                eagleData.health -= damage;
                
                if (eagleData.health <= 0) {
                    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÜÿ≥ÿ± Ÿäÿ≠ŸÖŸÑ ÿÆÿ±ŸàŸÅÿßŸãÿå ÿßÿ≥ÿ™ÿπÿßÿØÿ™Ÿá
                    if (eagleData.hasSheep) {
                        sheepCollected++;
                        score += eagleData.returnSheepValue;
                        showReturnSheepMessage(eagle.position.x, eagle.position.y + 3, eagle.position.z, "ÿ™ŸÖ ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑÿÆÿ±ŸàŸÅ!");
                        updateUI();
                        
                        // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿÆÿ±ŸàŸÅ ÿßŸÑŸÖÿ±ÿ¶Ÿä ŸÖŸÜ ÿßŸÑŸÜÿ≥ÿ±
                        if (eagleData.stolenSheep) {
                            eagle.remove(eagleData.stolenSheep);
                            eagleData.stolenSheep = null;
                        }
                    }
                    
                    scene.remove(eagle);
                    const index = snatchingEagles.indexOf(eagle);
                    if (index > -1) snatchingEagles.splice(index, 1);
                    coins.push(createCoin(eagle.position.x, eagle.position.z, eagleData.value));
                    score += eagleData.value;
                    playMonsterExplosionSound();
                    
                    if (Math.random() < 0.4) {
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 15);
                        showHealthGainEffect(eagle.position.x, eagle.position.y + 2, eagle.position.z, 15);
                    }
                    
                    const killEffect = document.createElement("div");
                    killEffect.className = "success-message";
                    killEffect.style.fontSize = "20px";
                    killEffect.textContent = "ÿ™ŸÖ ŸÇÿ™ŸÑ ÿßŸÑŸÜÿ≥ÿ± ÿßŸÑÿÆÿßÿ∑ŸÅ! +" + eagleData.value + " ŸÜŸÇÿ∑ÿ©";
                    document.body.appendChild(killEffect);
                    
                    setTimeout(() => {
                        killEffect.remove();
                    }, 2000);
                } else {
                    const damageEffect = document.createElement("div");
                    damageEffect.className = "wolf-health-effect";
                    damageEffect.textContent = `-${damage}`;
                    damageEffect.style.color = "#ff3333";
                    
                    const vector = new THREE.Vector3(eagle.position.x, eagle.position.y + 3, eagle.position.z);
                    vector.project(camera);
                    damageEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
                    damageEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
                    document.querySelector(".scene-container").appendChild(damageEffect);
                    
                    setTimeout(() => {
                        damageEffect.remove();
                    }, 1000);
                    
                    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ Ÿäÿ≠ŸÖŸÑ ÿÆÿ±ŸàŸÅÿßŸãÿå ÿ•ÿ≥ŸÇÿßÿ∑Ÿá ÿπŸÜÿØ ÿßŸÑÿ•ÿµÿßÿ®ÿ©
                    if (eagleData.hasSheep) {
                        eagleData.isSnatching = false;
                    eagleData.isSwooping = false;
                        eagleData.hasSheep = false;
                        eagleData.escapeTimer = 0;
                        
                        // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿÆÿ±ŸàŸÅ ÿßŸÑŸÖÿ±ÿ¶Ÿä ŸÖŸÜ ÿßŸÑŸÜÿ≥ÿ±
                        if (eagleData.stolenSheep) {
                            eagle.remove(eagleData.stolenSheep);
                            eagleData.stolenSheep = null;
                        }
                        
                        // ÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ ŸÅŸä ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ≠ÿßŸÑŸä
                        const droppedSheep = createSheep(eagle.position.x, 0, eagle.position.z);
                        sheeps.push(droppedSheep);
                        totalSheeps++;
                        
                        // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ©
                        showReturnSheepMessage(eagle.position.x, eagle.position.y + 3, eagle.position.z, "ÿ£ÿ≥ŸÇÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ!");
                    }
                }
            }
            
            return eaglesToDamage.length;
        }

        // ===== ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ÿµÿßÿ®ÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© ÿ®ÿßŸÑŸÇŸÜÿ®ŸÑÿ© =====
        function checkSnatchingEagleDamageFromBomb(explosionRadius, damage) {
            player.getWorldPosition(_v1); const playerPos = _v1;
            
            const eaglesToDamage = [];
            
            for (let i = snatchingEagles.length - 1; i >= 0; i--) {
                const eagle = snatchingEagles[i];
                const eaglePos = new THREE.Vector3();
                eagle.getWorldPosition(eaglePos);
                
                const distance = eaglePos.distanceTo(playerPos);
                if (distance < explosionRadius) {
                    eaglesToDamage.push(eagle);
                }
            }
            
            for (const eagle of eaglesToDamage) {
                const eagleData = eagle.userData;
                eagleData.health -= damage * 1.5;
                
                if (eagleData.health <= 0) {
                    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÜÿ≥ÿ± Ÿäÿ≠ŸÖŸÑ ÿÆÿ±ŸàŸÅÿßŸãÿå ÿßÿ≥ÿ™ÿπÿßÿØÿ™Ÿá
                    if (eagleData.hasSheep) {
                        sheepCollected++;
                        score += eagleData.returnSheepValue;
                        showReturnSheepMessage(eagle.position.x, eagle.position.y + 3, eagle.position.z, "ÿ™ŸÖ ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑÿÆÿ±ŸàŸÅ!");
                        updateUI();
                        
                        // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿÆÿ±ŸàŸÅ ÿßŸÑŸÖÿ±ÿ¶Ÿä ŸÖŸÜ ÿßŸÑŸÜÿ≥ÿ±
                        if (eagleData.stolenSheep) {
                            eagle.remove(eagleData.stolenSheep);
                            eagleData.stolenSheep = null;
                        }
                    }
                    
                    scene.remove(eagle);
                    const index = snatchingEagles.indexOf(eagle);
                    if (index > -1) snatchingEagles.splice(index, 1);
                    coins.push(createCoin(eagle.position.x, eagle.position.z, eagleData.value));
                    score += eagleData.value;
                    playMonsterExplosionSound();
                    
                    if (Math.random() < 0.5) {
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 20);
                        showHealthGainEffect(eagle.position.x, eagle.position.y + 2, eagle.position.z, 20);
                    }
                } else if (eagleData.hasSheep) {
                    // ÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ ÿπŸÜÿØ ÿßŸÑÿ•ÿµÿßÿ®ÿ©
                    eagleData.isSnatching = false;
                    eagleData.isSwooping = false;
                    eagleData.hasSheep = false;
                    eagleData.escapeTimer = 0;
                    
                    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿÆÿ±ŸàŸÅ ÿßŸÑŸÖÿ±ÿ¶Ÿä ŸÖŸÜ ÿßŸÑŸÜÿ≥ÿ±
                    if (eagleData.stolenSheep) {
                        eagle.remove(eagleData.stolenSheep);
                        eagleData.stolenSheep = null;
                    }
                    
                    // ÿ•ÿ≥ŸÇÿßÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ ŸÅŸä ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ≠ÿßŸÑŸä
                    const droppedSheep = createSheep(eagle.position.x, 0, eagle.position.z);
                    sheeps.push(droppedSheep);
                    totalSheeps++;
                    
                    // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ©
                    showReturnSheepMessage(eagle.position.x, eagle.position.y + 3, eagle.position.z, "ÿ£ÿ≥ŸÇÿ∑ ÿßŸÑÿÆÿ±ŸàŸÅ!");
                }
            }
        }

        // ===== ÿØŸàÿßŸÑ ÿßŸÑÿπÿ±ÿ∂ ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ =====
        function showSnatchMessage(x, y, z, message) {
            const msgDiv = document.createElement("div");
            msgDiv.className = "crocodile-damage-effect";
            msgDiv.textContent = message;
            msgDiv.style.color = "#ff0000";
            msgDiv.style.fontSize = "28px";
            msgDiv.style.fontWeight = "bold";
            
            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);
            msgDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            msgDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(msgDiv);
            
            setTimeout(() => {
                msgDiv.remove();
            }, 2000);
        }

        function showReturnSheepMessage(x, y, z, message) {
            const msgDiv = document.createElement("div");
            msgDiv.className = "success-message";
            msgDiv.style.fontSize = "24px";
            msgDiv.style.padding = "15px 30px";
            msgDiv.textContent = message;
            msgDiv.style.background = "linear-gradient(45deg, #4caf50, #8bc34a)";
            
            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);
            msgDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            msgDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(msgDiv);
            
            setTimeout(() => {
                msgDiv.remove();
            }, 2000);
        }

        function showEscapeMessage(x, y, z, message) {
            const msgDiv = document.createElement("div");
            msgDiv.className = "wolf-health-effect";
            msgDiv.textContent = message;
            msgDiv.style.color = "#ff9900";
            msgDiv.style.fontSize = "22px";
            
            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);
            msgDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            msgDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(msgDiv);
            
            setTimeout(() => {
                msgDiv.remove();
            }, 1500);
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÑÿ© ŸÑŸÑÿ™ÿ≥ŸÑŸÇ ŸÖÿπ ÿßŸÑŸÜÿ≥Ÿàÿ± =====
        function createClimbingHill(x, z, height = 15) {
            const hillGroup = new THREE.Group();
            const baseGeometry = new THREE.ConeGeometry(20, height, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = height / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            hillGroup.add(base);
            
            const grassGeometry = new THREE.ConeGeometry(19, height - 2, 32);
            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.8,
                metalness: 0.05
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.position.y = (height - 2) / 2 + 1;
            grass.castShadow = true;
            grass.receiveShadow = true;
            hillGroup.add(grass);
            
            const pathGeometry = new THREE.PlaneGeometry(5, height - 5);
            const pathMaterial = new THREE.MeshStandardMaterial({
                color: 0xA0522D,
                side: THREE.DoubleSide
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = Math.PI / 2;
            path.rotation.z = Math.PI / 4;
            path.position.y = (height - 5) / 2 + 2.5;
            path.position.z = -8;
            path.receiveShadow = true;
            hillGroup.add(path);
            
            const treeTrunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 3, 8);
            const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const treeTrunk = new THREE.Mesh(treeTrunkGeometry, treeTrunkMaterial);
            treeTrunk.position.y = height + 1.5;
            treeTrunk.castShadow = true;
            hillGroup.add(treeTrunk);
            
            const treeLeavesGeometry = new THREE.ConeGeometry(2, 4, 8);
            const treeLeavesMaterial = new THREE.MeshStandardMaterial({ color: 0x2E8B57 });
            const treeLeaves = new THREE.Mesh(treeLeavesGeometry, treeLeavesMaterial);
            treeLeaves.position.y = height + 4;
            treeLeaves.castShadow = true;
            hillGroup.add(treeLeaves);
            
            hillGroup.position.set(x, 0, z);
            scene.add(hillGroup);
            
            // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿÆÿ±ÿßŸÅ ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ
            let sheepCount = 1; // ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ£ŸàŸÑ: ŸÑÿß ÿÆÿ±ÿßŸÅ ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ©
            if (round === 1) {
                sheepCount = 0; // ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ£ŸàŸÑ: ŸÑÿß ÿÆÿ±ÿßŸÅ
            } else if (round === 2) {
                sheepCount = 5; // ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÜŸä: 5 ÿÆÿ±ÿßŸÅ
            }
            
            const hillSheeps = [];
            for (let i = 0; i < sheepCount; i++) {
                const angle = (i / sheepCount) * Math.PI * 2;
                const radius = 5;
                const sheepX = x + Math.cos(angle) * radius;
                const sheepZ = z + Math.sin(angle) * radius;
                const sheep = createSheep(sheepX, height + 0.5, sheepZ);
                sheep.userData.isOnHill = true;
                hillSheeps.push(sheep);
                sheeps.push(sheep);
                totalSheeps++;
            }
            
            hillGroup.userData = {
                isHill: true,
                height: height,
                radius: 20,
                sheep: hillSheeps.length > 0 ? hillSheeps[0] : null,
                allSheeps: hillSheeps,
                climbable: true,
                climbSlope: 0.7
            };
            
            hills.push(hillGroup);
            
            if (round > 1) {
                addEaglesToHill(hillGroup);
            }
            
            return hillGroup;
        }

        // ===== ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÖÿ¥ŸáÿØ ŸàÿßŸÑŸÉÿßŸÖŸäÿ±ÿß =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const canvas = document.getElementById("gameScene");
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true
        });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setPixelRatio(window.devicePixelRatio);

        const palette = {
            ground: 0x388E3C,
            grass: 0x689F38,
            tree: 0x2d5016,
            trunk: 0x3d2817
        };

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(1000, 1000, 60, 60);
            const simplex = new SimplexNoise();
            const posAttribute = geometry.attributes.position;
            
            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i);
                // ÿ™ŸÇŸÑŸäŸÑ ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿ™ÿ∂ÿßÿ±Ÿäÿ≥ ŸÑÿ™ŸÉŸàŸÜ ÿ£ŸÇŸÑ ŸÖŸÜ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÜŸáÿ± (-0.4)
                                // ÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜŸáÿ±
                const hillCenterX = -50;
                const hillCenterZ = -50;
                const riverOuterRadius = 180; // ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (180 ŸÇÿ∑ÿ±)
                const valleyRadius = riverOuterRadius + 50; // ŸÜÿµŸÅ ŸÇÿ∑ÿ± ÿßŸÑŸàÿßÿØŸä (230 ÿßŸÑÿ¢ŸÜ)
                const valleyDepth = 5; // ÿπŸÖŸÇ ÿßŸÑŸàÿßÿØŸä ÿßŸÑÿ£ŸÇÿµŸâ

                // ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≥ÿßŸÅÿ© ŸÖŸÜ ŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜŸáÿ±
                const distance = Math.sqrt((x - hillCenterX) ** 2 + (y - hillCenterZ) ** 2);

                // ÿ≠ÿ≥ÿßÿ® ÿπÿßŸÖŸÑ ÿßŸÑÿ™ÿÆŸÅŸäÿ∂ (valleyFactor)
                let valleyFactor = 0;
                if (distance < valleyRadius) {
                    // ÿßŸÑÿ™ÿÆŸÅŸäÿ∂ Ÿäÿ®ÿØÿ£ ŸÖŸÜ ÿßŸÑÿ≠ÿßŸÅÿ© ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© ŸÑŸÑŸàÿßÿØŸä ŸàŸäÿ™ÿ≤ÿßŸäÿØ ŸÜÿ≠Ÿà ÿßŸÑŸÖÿ±ŸÉÿ≤
                    valleyFactor = 1 - (distance / valleyRadius);
                    valleyFactor = Math.pow(valleyFactor, 2); // ŸÑÿ¨ÿπŸÑ ÿßŸÑÿ™ÿÆŸÅŸäÿ∂ ÿ£ŸÉÿ´ÿ± ÿ≥ŸÑÿßÿ≥ÿ© ÿπŸÜÿØ ÿßŸÑÿ≠ŸàÿßŸÅ
                }

                // ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä ŸÑŸÑÿ™ÿ∂ÿßÿ±Ÿäÿ≥
                const baseHeight = simplex.noise2D(x * 0.05, y * 0.05) * 0.8 + simplex.noise2D(x * 0.1, y * 0.1) * 0.2 - 0.3;

                // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ™ÿÆŸÅŸäÿ∂
                const z = baseHeight - (valleyFactor * valleyDepth);
                posAttribute.setZ(i, z);
            }
            
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                color: palette.ground,
                roughness: 1,
                flatShading: true
            });

            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1.0; // ÿÆŸÅÿ∂ ÿßŸÑÿ£ÿ±ÿ∂Ÿäÿ© ŸÑÿ™ŸÉŸàŸÜ ÿ£ŸÇŸÑ ŸÖŸÜ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÜŸáÿ±
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createNature() {
            const treeMat = new THREE.MeshStandardMaterial({ color: palette.tree, flatShading: true });
            const trunkMat = new THREE.MeshStandardMaterial({ color: palette.trunk, flatShading: true });

            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 50 + Math.random() * 450;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                const s = 1.5 + Math.random() * 2;
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2*s, 0.4*s, 1*s, 5), trunkMat);
                trunk.position.set(x, 0.5*s, z);
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5*s, 4*s, 5), treeMat);
                leaves.position.set(0, 2.5*s, 0);
                trunk.add(leaves);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
            }
        }

        function createOasis() {
            const waterGeometry = new THREE.CircleGeometry(30, 32);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e90ff,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.8
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.set(250, -0.3, 250);
            water.receiveShadow = true;
            scene.add(water);

            const waterPlantMat = new THREE.MeshStandardMaterial({ 
                color: 0x228b22,
                flatShading: true 
            });
            
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 5;
                const x = Math.cos(angle) * radius + 250;
                const z = Math.sin(angle) * radius + 250;
                const plantHeight = 0.3 + Math.random() * 0.5;
                const plantGeometry = new THREE.ConeGeometry(0.2, plantHeight, 4);
                const plant = new THREE.Mesh(plantGeometry, waterPlantMat);
                plant.position.set(x, plantHeight/2, z);
                plant.castShadow = true;
                scene.add(plant);
            }

            return water;
        }

        // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿπÿßŸÑŸÖ
        createTerrain();
        createNature();
        createOasis();

        const player = new THREE.Group();
        scene.add(player);

        const playerModel = createPlayerModel();
        player.add(playerModel);

        const camera = new THREE.PerspectiveCamera(
            70,
            canvas.clientWidth / canvas.clientHeight,
            0.1,
            1000
        );
        camera.position.set(0, 6, 10);
        scene.add(camera);

        // ===== ÿßŸÑÿ•ÿ∂ÿßÿ°ÿ© =====
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 200, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        scene.add(sunLight);

        const playerLight = new THREE.DirectionalLight(0xfff0c0, 0.5);
        playerLight.position.set(0, 10, 0);
        player.add(playerLight);

        // ===== ÿ≠ÿØŸàÿØ ÿßŸÑÿπÿßŸÑŸÖ =====
        const worldBounds = {
            minX: -450,
            maxX: 450,
            minZ: -450,
            maxZ: 450,
            buffer: 30,
        };

        const quarters = [
            { minX: -450, maxX: 0, minZ: -450, maxZ: 0 },
            { minX: 0, maxX: 450, minZ: -450, maxZ: 0 },
            { minX: -450, maxX: 0, minZ: 0, maxZ: 450 },
            { minX: 0, maxX: 450, minZ: 0, maxZ: 450 }
        ];

        function checkWorldBounds(position) {
            const warningElement = document.getElementById("worldBoundaryWarning");
            let isNearBoundary = false;

            if (position.x < worldBounds.minX + worldBounds.buffer) {
                position.x = worldBounds.minX + worldBounds.buffer;
                isNearBoundary = true;
            }
            if (position.x > worldBounds.maxX - worldBounds.buffer) {
                position.x = worldBounds.maxX - worldBounds.buffer;
                isNearBoundary = true;
            }
            if (position.z < worldBounds.minZ + worldBounds.buffer) {
                position.z = worldBounds.minZ + worldBounds.buffer;
                isNearBoundary = true;
            }
            if (position.z > worldBounds.maxZ - worldBounds.buffer) {
                position.z = worldBounds.maxZ - worldBounds.buffer;
                isNearBoundary = true;
            }

            return position;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∞ÿ¶ÿßÿ® ÿßŸÑŸÖŸÅÿµŸÑÿ© =====
        function createDetailedWolf(x, z, type) {
            const wolfGroup = new THREE.Group();
            let furMain, furLight, furHighlight;
            let scaleFactor = 1;
            
            switch(type) {
                case 'giant':
                    furMain = 0x990000;
                    furLight = 0xbb3333;
                    furHighlight = 0xff6666;
                    scaleFactor = 1.5;
                    break;
                case 'aggressive':
                    furMain = 0x8b4513;
                    furLight = 0xa0522d;
                    furHighlight = 0xd2691e;
                    scaleFactor = 0.96;
                    break;
                case 'strong':
                    furMain = 0x2f4f4f;
                    furLight = 0x4f6f6f;
                    furHighlight = 0x6f8f6f;
                    scaleFactor = 1.1;
                    break;
                case 'fast':
                    furMain = 0x696969;
                    furLight = 0x808080;
                    furHighlight = 0x999999;
                    scaleFactor = 0.9;
                    break;
                case 'normal':
                default:
                    furMain = 0x505050;
                    furLight = 0x777777;
                    furHighlight = 0x999999;
                    scaleFactor = 0.77;
            }
            
            const matBody = new THREE.MeshStandardMaterial({ 
                color: furMain, 
                flatShading: true,
                roughness: 0.8 
            });
            const matLight = new THREE.MeshStandardMaterial({ 
                color: furLight, 
                flatShading: true,
                roughness: 0.8 
            });
            const matHighlight = new THREE.MeshStandardMaterial({ 
                color: furHighlight, 
                flatShading: true,
                roughness: 0.8 
            });

            const chestGeom = new THREE.DodecahedronGeometry(1.4 * scaleFactor);
            chestGeom.scale(1, 1.1, 1.4);
            const chest = new THREE.Mesh(chestGeom, matBody);
            chest.position.y = 2.8 * scaleFactor;
            wolfGroup.add(chest);

            const bellyGeom = new THREE.DodecahedronGeometry(1.1 * scaleFactor);
            bellyGeom.scale(0.9, 1, 1.3);
            const belly = new THREE.Mesh(bellyGeom, matLight);
            belly.position.set(0, 2.9 * scaleFactor, -1.8 * scaleFactor);
            wolfGroup.add(belly);

            const headGroup = new THREE.Group();
            headGroup.position.set(0, 4.2 * scaleFactor, 1.8 * scaleFactor);

            const skull = new THREE.Mesh(new THREE.BoxGeometry(1.2 * scaleFactor, 1.2 * scaleFactor, 1.4 * scaleFactor), matBody);
            headGroup.add(skull);

            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scaleFactor, 0.7 * scaleFactor, 1.2 * scaleFactor), matLight);
            snout.position.set(0, -0.1 * scaleFactor, 1.1 * scaleFactor);
            headGroup.add(snout);

            const noseTip = new THREE.Mesh(new THREE.BoxGeometry(0.3 * scaleFactor, 0.2 * scaleFactor, 0.2 * scaleFactor), 
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, flatShading: true }));
            noseTip.position.set(0, 0.2 * scaleFactor, 1.7 * scaleFactor);
            headGroup.add(noseTip);

            const jawGroup = new THREE.Group();
            jawGroup.position.set(0, -0.4 * scaleFactor, 0.8 * scaleFactor);
            const jawMesh = new THREE.Mesh(new THREE.BoxGeometry(0.6 * scaleFactor, 0.3 * scaleFactor, 1.0 * scaleFactor), matLight);
            jawGroup.add(jawMesh);
            headGroup.add(jawGroup);

            const earGeo = new THREE.ConeGeometry(0.3 * scaleFactor, 0.8 * scaleFactor, 4);
            const earL = new THREE.Mesh(earGeo, matBody);
            earL.position.set(0.4 * scaleFactor, 0.8 * scaleFactor, -0.3 * scaleFactor);
            earL.rotation.set(-0.2, 0, -0.2);
            headGroup.add(earL);

            const earR = new THREE.Mesh(earGeo, matBody);
            earR.position.set(-0.4 * scaleFactor, 0.8 * scaleFactor, -0.3 * scaleFactor);
            earR.rotation.set(-0.2, 0, 0.2);
            headGroup.add(earR);

            const eyeGeo = new THREE.BoxGeometry(0.1 * scaleFactor, 0.15 * scaleFactor, 0.05 * scaleFactor);
            const eyeMat = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00, 
                emissive: 0xffaa00, 
                emissiveIntensity: 0.5 
            });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(0.35 * scaleFactor, 0.2 * scaleFactor, 0.7 * scaleFactor);
            eyeR.position.set(-0.35 * scaleFactor, 0.2 * scaleFactor, 0.7 * scaleFactor);
            headGroup.add(eyeL);
            headGroup.add(eyeR);

            wolfGroup.add(headGroup);

            const tailGroup = new THREE.Group();
            tailGroup.position.set(0, 3.2 * scaleFactor, -2.5 * scaleFactor);
            const tailBase = new THREE.Mesh(new THREE.CylinderGeometry(0.2 * scaleFactor, 0.5 * scaleFactor, 1.5 * scaleFactor, 5), matBody);
            tailBase.position.set(0, -0.5 * scaleFactor, -0.5 * scaleFactor);
            tailBase.rotation.x = -0.8;
            tailGroup.add(tailBase);
            const tailTip = new THREE.Mesh(new THREE.ConeGeometry(0.4 * scaleFactor, 1.5 * scaleFactor, 5), matHighlight);
            tailTip.position.set(0, -1.5 * scaleFactor, -1.0 * scaleFactor);
            tailTip.rotation.x = -0.5;
            tailGroup.add(tailTip);
            wolfGroup.add(tailGroup);

            const legs = [];
            function createLeg(x, z, isBack) {
                const legGroup = new THREE.Group();
                legGroup.position.set(x, 2.8 * scaleFactor, z);

                const thighH = isBack ? 1.4 : 1.2;
                const thigh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35 * scaleFactor, 0.5 * scaleFactor, thighH * scaleFactor, 5), 
                    matBody
                );
                thigh.position.set(0, -thighH * scaleFactor / 2, 0);
                thigh.rotation.x = isBack ? 0.3 : -0.1;
                legGroup.add(thigh);

                const shinH = 1.0;
                const shin = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2 * scaleFactor, 0.3 * scaleFactor, shinH * scaleFactor, 4), 
                    matLight
                );
                shin.position.set(0, -thighH * scaleFactor - shinH * scaleFactor / 2 + 0.1 * scaleFactor, 
                                  isBack ? -0.3 * scaleFactor : 0.1 * scaleFactor);
                shin.rotation.x = isBack ? -0.5 : 0.1;
                legGroup.add(shin);

                const paw = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4 * scaleFactor, 0.3 * scaleFactor, 0.5 * scaleFactor), 
                    matBody
                );
                paw.position.set(0, -thighH * scaleFactor - shinH * scaleFactor - 0.1 * scaleFactor, 
                                 isBack ? -0.5 * scaleFactor : 0.2 * scaleFactor);
                legGroup.add(paw);

                wolfGroup.add(legGroup);
                return legGroup;
            }

            legs.push(createLeg(0.6 * scaleFactor, 0.5 * scaleFactor, false));
            legs.push(createLeg(-0.6 * scaleFactor, 0.5 * scaleFactor, false));
            legs.push(createLeg(0.6 * scaleFactor, -2.0 * scaleFactor, true));
            legs.push(createLeg(-0.6 * scaleFactor, -2.0 * scaleFactor, true));

            wolfGroup.userData.legs = legs;
            wolfGroup.userData.head = headGroup;
            wolfGroup.userData.jaw = jawGroup;
            wolfGroup.userData.tail = tailGroup;
            wolfGroup.userData.walkCycle = 0;
            wolfGroup.userData.earL = earL;
            wolfGroup.userData.earR = earR;

            wolfGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
            wolfGroup.position.set(x, type === 'giant' ? 4 * scaleFactor : 0, z);
            
            if (type === 'aggressive') {
                const glowGeometry = new THREE.SphereGeometry(2.5 * scaleFactor, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: furMain,
                    transparent: true,
                    opacity: 0.3,
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                wolfGroup.add(glow);
            }

            return wolfGroup;
        }

        function animateWolfLegs(wolf, deltaTime) {
            if (!wolf.userData.legs) return;
            const legs = wolf.userData.legs;
            const isChasing = wolf.userData.isChasing || false;
            if (isChasing && wolf.userData.speed > 0) {
                wolf.userData.walkCycle += deltaTime * wolf.userData.speed * 10;
            }
            const walkSpeed = isChasing ? 8 : 4;
            const legSwing = Math.sin(wolf.userData.walkCycle * walkSpeed) * 0.3;
            if (legs[0]) legs[0].rotation.x = legSwing;
            if (legs[1]) legs[1].rotation.x = legSwing;
            if (legs[2]) legs[2].rotation.x = -legSwing;
            if (legs[3]) legs[3].rotation.x = -legSwing;
            if (wolf.userData.tail) {
                wolf.userData.tail.rotation.y = Math.sin(wolf.userData.walkCycle * 2) * 0.1;
            }
            if (wolf.userData.earL && wolf.userData.earR) {
                const earMove = Math.sin(wolf.userData.walkCycle * 4) * 0.1;
                wolf.userData.earL.rotation.z = -0.2 + earMove;
                wolf.userData.earR.rotation.z = 0.2 - earMove;
            }
        }

        function createWolf(x, z, type, quarter) {
            const wolfGroup = createDetailedWolf(x, z, type);
            let health, value;
            const sizeFactor = 1 + (round - 1) * 0.5;
            const healthFactor = 1 + (round - 1) * 0.8;

            switch(type) {
                case 'giant':
                    health = 500;
                    value = 50;
                    break;
                case 'aggressive':
                    health = 150 * healthFactor;
                    value = 25;
                    break;
                case 'strong':
                    health = 120;
                    value = 15;
                    break;
                case 'fast':
                    health = 80;
                    value = 10;
                    break;
                case 'normal':
                default:
                    health = 30;
                    value = 5;
            }

            let baseSpeed;
            switch(type) {
                case 'aggressive':
                    baseSpeed = 0.12;
                    break;
                case 'fast':
                    baseSpeed = 0.08;
                    break;
                case 'normal':
                    baseSpeed = 0.1;
                    break;
                default:
                    baseSpeed = 0.04;
            }

            let detectionRange;
            if (type === "aggressive") {
                detectionRange = 30;
            } else if (type === "normal") {
                detectionRange = 50;
            } else {
                detectionRange = 0;
            }

            wolfGroup.userData = {
                ...wolfGroup.userData,
                type,
                health,
                maxHealth: health,
                speed: baseSpeed,
                value,
                isAggressive: type === "aggressive" || type === "normal",
                isChasing: false,
                detectionRange: detectionRange,
                attackRange: (type === "aggressive" || type === "normal") ? 5 : 0,
                attackDamage: (type === "aggressive" || type === "normal") ? 10 : 0,
                lastAttackTime: 0,
                collisionDamage: type === "normal" ? 8 : (type === "aggressive" ? 15 : 5),
                lastCollisionTime: 0,
                collisionCooldown: 1000,
                isProtector: type === "aggressive",
                protectedSheep: null,
                guardRadius: 15,
                quarter: quarter,
                randomTarget: null,
                targetTimer: 0
            };

            scene.add(wolfGroup);
            return wolfGroup;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿÆÿ±ÿßŸÅ =====
        function createSheep(x, y, z) {
            const sheepGroup = new THREE.Group();

            const woolMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const fleshMaterial = new THREE.MeshPhongMaterial({ color: 0xf5deb3 });
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x4b4b4b });

            const bodyGeometry = new THREE.SphereGeometry(1.8, 32, 16);
            const body = new THREE.Mesh(bodyGeometry, woolMaterial);
            body.scale.set(0.7, 0.7, 1.1);
            body.castShadow = true;
            sheepGroup.add(body);

            const tailGeometry = new THREE.SphereGeometry(0.3, 32, 16);
            const tail = new THREE.Mesh(tailGeometry, woolMaterial);
            tail.position.set(0, 0, -1.8);
            tail.scale.z = 0.5;
            tail.castShadow = true;
            body.add(tail);

            const headGeometry = new THREE.SphereGeometry(0.5, 32, 16);
            const head = new THREE.Mesh(headGeometry, fleshMaterial);
            head.position.set(0, 0.75, 1.4);
            head.scale.set(0.7, 1.2, 1.1);
            head.castShadow = true;
            body.add(head);

            const earGeometry = new THREE.ConeGeometry(0.35, 0.35, 3);
            const leftEar = new THREE.Mesh(earGeometry, fleshMaterial);
            leftEar.position.set(-0.6, 0.4, 0);
            leftEar.rotation.z = Math.PI / 2;
            leftEar.rotation.y = Math.PI / 4;
            leftEar.castShadow = true;
            head.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, fleshMaterial);
            rightEar.position.set(0.6, 0.4, 0);
            rightEar.rotation.z = -Math.PI / 2;
            rightEar.rotation.y = -Math.PI / 4;
            rightEar.castShadow = true;
            head.add(rightEar);

            const eyeGeometry = new THREE.SphereGeometry(0.07, 32, 16);
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 0.25, 0.45);
            leftEye.castShadow = true;
            head.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 0.25, 0.45);
            rightEye.castShadow = true;
            head.add(rightEye);

            const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.2);

            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(-0.7, -1.2, 1);
            frontLeftLeg.castShadow = true;
            body.add(frontLeftLeg);

            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.7, -1.2, 1);
            frontRightLeg.castShadow = true;
            body.add(frontRightLeg);

            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.7, -1.2, -1);
            backLeftLeg.castShadow = true;
            body.add(backLeftLeg);

            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(0.7, -1.2, -1);
            backRightLeg.castShadow = true;
            body.add(backRightLeg);

            sheepGroup.position.set(x, y, z);
            scene.add(sheepGroup);

            return sheepGroup;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ÿ®ÿßŸÑ =====
        function createMountain(x, z, width, height, depth) {
            const mountainGroup = new THREE.Group();

            const baseGeometry = new THREE.ConeGeometry(width, height, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1,
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, height / 2, z);
            base.castShadow = true;
            base.receiveShadow = true;
            mountainGroup.add(base);

            const snowGeometry = new THREE.ConeGeometry(width * 0.4, height * 0.4, 8);
            const snowMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.7,
                metalness: 0.1,
            });
            const snow = new THREE.Mesh(snowGeometry, snowMaterial);
            snow.position.set(x, height * 0.7, z);
            snow.castShadow = true;
            snow.receiveShadow = true;
            mountainGroup.add(snow);

            const rockCount = 5;
            for (let i = 0; i < rockCount; i++) {
                const rockSize = Math.random() * 5 + 3;
                const rockGeometry = new THREE.SphereGeometry(rockSize, 6, 6);
                const rockMaterial = new THREE.MeshStandardMaterial({
                    color: 0x696969,
                    roughness: 0.8,
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);

                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * width * 0.6;
                const rockHeight = Math.random() * height * 0.4;

                rock.position.set(
                    x + Math.cos(angle) * distance,
                    rockHeight,
                    z + Math.sin(angle) * distance
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                mountainGroup.add(rock);
            }

            scene.add(mountainGroup);
            return mountainGroup;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿπŸÖŸÑÿßÿ™ =====
        function createCoin(x, z, value) {
            const coinGroup = new THREE.Group();

            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
            const coinMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 1,
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            coinGroup.add(coin);

            const haloGeometry = new THREE.RingGeometry(0.6, 0.8, 32);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.rotation.x = -Math.PI / 2;
            halo.position.y = 0.05;
            coinGroup.add(halo);

            const sparkleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const sparkleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
            });

            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.set(
                    Math.cos(angle) * 0.7,
                    0.1,
                    Math.sin(angle) * 0.7
                );
                sparkle.userData = {
                    angle: angle,
                };
                coinGroup.add(sparkle);
            }

            coinGroup.userData = {
                value,
                spinSpeed: 0.02,
                sparkleSpeed: 0.05,
            };

            // ŸÖŸÜÿπ ÿ∏ŸáŸàÿ± ÿßŸÑÿπŸÖŸÑÿßÿ™ ŸÅŸä ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ±
            const hillCenterX = -50;
            const hillCenterZ = -50;
            const riverInnerRadius = 40;
            const riverOuterRadius = 180;
            
            const distanceToRiverCenter = Math.sqrt(
                Math.pow(x - hillCenterX, 2) + 
                Math.pow(z - hillCenterZ, 2)
            );

            // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿπŸÖŸÑÿ© ÿ≥ÿ™ÿ∏Ÿáÿ± ŸÅŸä ÿßŸÑŸÜŸáÿ±ÿå ŸÜŸÇŸàŸÖ ÿ®ÿ™ÿπÿØŸäŸÑ ŸÖŸàŸÇÿπŸáÿß ŸÑÿ™ŸÉŸàŸÜ ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜŸáÿ±
            if (distanceToRiverCenter >= riverInnerRadius && distanceToRiverCenter <= riverOuterRadius) {
                const angle = Math.atan2(z - hillCenterZ, x - hillCenterX);
                const newDistance = riverOuterRadius + 5; // Ÿàÿ∂ÿπŸáÿß ÿÆÿßÿ±ÿ¨ ÿßŸÑÿ≠ÿßŸÅÿ© ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© ŸÑŸÑŸÜŸáÿ± ÿ®ŸÇŸÑŸäŸÑ
                const newX = hillCenterX + Math.cos(angle) * newDistance;
                const newZ = hillCenterZ + Math.sin(angle) * newDistance;
                coinGroup.position.set(newX, 1, newZ);
            } else {
                coinGroup.position.set(x, 1, z);
            }

            scene.add(coinGroup);
            return coinGroup;
        }

        // ===== ÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿßŸÑÿπÿµÿß =====
        function createStickSwingEffect(position) {
            const particles = [];
            const particleCount = 15;
            const colors = [0x8b4513, 0xa0522d, 0xd2691e];

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.3, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.8,
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);

                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.1 + 0.05;

                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.1,
                        Math.sin(angle) * speed
                    ),
                    createdAt: Date.now(),
                };

                scene.add(particle);
                particles.push(particle);
            }

            return particles;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖŸÜÿµÿßÿ™ =====
        function createPlatform(x, y, z, width, height, depth) {
            const platformGeometry = new THREE.BoxGeometry(width, height, depth);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x964b00,
                roughness: 0.8,
                metalness: 0.1,
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y + height / 2, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿµŸÜÿØŸàŸÇ ÿßŸÑŸÇŸÜÿßÿ®ŸÑ =====
        function createBombBox(x, z) {
            const boxGroup = new THREE.Group();

            // ÿµŸÜÿØŸàŸÇ ÿÆÿ¥ÿ®Ÿä ŸÑŸÑÿ¥ÿπŸÑÿ©
            const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513, // ŸÑŸàŸÜ ÿÆÿ¥ÿ®Ÿä
                roughness: 0.8,
                metalness: 0.1,
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.y = 1;
            box.castShadow = true;
            box.receiveShadow = true;
            boxGroup.add(box);

            // ÿ±ŸÖÿ≤ ÿßŸÑŸÜÿßÿ± ÿπŸÑŸâ ÿßŸÑÿµŸÜÿØŸàŸÇ
            const fireSymbolGeometry = new THREE.ConeGeometry(0.5, 1, 8);
            const fireSymbolMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4500 // ŸÑŸàŸÜ ÿ®ÿ±ÿ™ŸÇÿßŸÑŸä ŸÖÿ≠ŸÖÿ±
            });
            const fireSymbol = new THREE.Mesh(fireSymbolGeometry, fireSymbolMaterial);
            fireSymbol.position.set(0, 1, 1.1);
            fireSymbol.rotation.x = Math.PI / 2;
            boxGroup.add(fireSymbol);

            // ŸÖŸÇÿ®ÿ∂ ÿßŸÑÿ¥ÿπŸÑÿ©
            const handleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8);
            const handleMaterial = new THREE.MeshStandardMaterial({
                color: 0x4b2d1a
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0, 2.2, 0);
            boxGroup.add(handle);

            // ŸÑŸáÿ® ÿßŸÑÿ¥ÿπŸÑÿ©
            const flameGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({
                color: 0xffa500
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(0, 2.8, 0);
            boxGroup.add(flame);

            boxGroup.position.set(x, 0, z);
            scene.add(boxGroup);

            boxGroup.userData = {
                isBombBox: true,
                flame: flame,
                flameTimer: 0,
            };

            return boxGroup;
        }

        // ===== ÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿßŸÜŸÅÿ¨ÿßÿ± ÿßŸÑŸÇŸÜÿ®ŸÑÿ© =====
        function createBombExplosionEffect(position) {
            const particles = [];
            const particleCount = 60;
            const colors = [0xff4500, 0xff8c00, 0xffd700, 0xff0000]; // ÿ£ŸÑŸàÿßŸÜ ÿßŸÑŸÜÿßÿ±

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.8, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.9,
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);

                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.6 + 0.3;

                particle.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.8 + 0.2, // ÿ≠ÿ±ŸÉÿ© ŸÑŸÑÿ£ÿπŸÑŸâ ÿ£ŸÉÿ´ÿ± ŸÖÿ´ŸÑ ÿßŸÑŸÜÿßÿ±
                        Math.sin(angle) * speed
                    ),
                    createdAt: Date.now(),
                    lifeTime: 1000 + Math.random() * 1000,
                };

                scene.add(particle);
                particles.push(particle);
            }

            const fireEffect = document.createElement("div");
            fireEffect.className = "bomb-effect";
            fireEffect.style.width = "250px";
            fireEffect.style.height = "250px";
            fireEffect.style.background = "radial-gradient(circle, rgba(255,69,0,0.8) 0%, rgba(255,140,0,0.4) 50%, rgba(255,215,0,0) 70%)";
            fireEffect.style.borderRadius = "50%";

            const vector = new THREE.Vector3(position.x, position.y, position.z);
            vector.project(camera);

            fireEffect.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            fireEffect.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(fireEffect);

            setTimeout(() => {
                fireEffect.remove();
            }, 800);

            return particles;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÜÿ≠ŸÑ =====
        function createBee(x, z) {
            const beeGroup = new THREE.Group();

            const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                roughness: 0.7,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            beeGroup.add(body);

            const stripeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.6, 8);
            const stripeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, -0.6 + i * 0.6, 0);
                stripe.rotation.z = Math.PI / 2;
                body.add(stripe);
            }

            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.8, 0);
            beeGroup.add(head);

            const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 0.9, 0.3);
            beeGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 0.9, 0.3);
            beeGroup.add(rightEye);

            const antennaGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8);
            const antennaMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000
            });
            
            const leftAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            leftAntenna.position.set(-0.2, 1.1, 0.1);
            leftAntenna.rotation.z = -Math.PI / 6;
            beeGroup.add(leftAntenna);
            
            const rightAntenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            rightAntenna.position.set(0.2, 1.1, 0.1);
            rightAntenna.rotation.z = Math.PI / 6;
            beeGroup.add(rightAntenna);

            const wingGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.8, 0.5, 0);
            leftWing.scale.set(0.1, 0.5, 1);
            beeGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.8, 0.5, 0);
            rightWing.scale.set(0.1, 0.5, 1);
            beeGroup.add(rightWing);

            const stingerGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
            const stingerMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333
            });
            const stinger = new THREE.Mesh(stingerGeometry, stingerMaterial);
            stinger.position.set(0, -0.8, 0);
            stinger.rotation.x = Math.PI;
            beeGroup.add(stinger);

            beeGroup.position.set(x, 3, z);

            beeGroup.userData = {
                type: 'bee',
                health: 80,
                speed: 0.25,
                damage: 6,
                isChasing: false,
                detectionRange: 50,
                attackRange: 6,
                lastAttackTime: 0,
                attackCooldown: 3000,
                collisionDamage: 6,
                lastCollisionTime: 0,
                collisionCooldown: 1000,
                wingFlapSpeed: 30,
                wingFlapAngle: 0,
                lastDetectedTime: 0,
                targetHeight: 3,
                minAttackHeight: 1,
                maxHeight: 10,
                heightChangeSpeed: 0.1,
                chaseDuration: 10000,
                isAggressive: true,
                attackWave: 0,
                attackDelay: 0
            };

            scene.add(beeGroup);
            return beeGroup;
        }

        // ===== ÿ•ŸÜÿ¥ÿßÿ° ÿÆŸÑŸäÿ© ÿßŸÑÿπÿ≥ŸÑ =====
        function createHoneyHive(x, z) {
            const hiveGroup = new THREE.Group();
            
            const hiveBaseGeometry = new THREE.CylinderGeometry(2, 3, 4, 8);
            const hiveBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const hiveBase = new THREE.Mesh(hiveBaseGeometry, hiveBaseMaterial);
            hiveBase.position.y = 2;
            hiveBase.castShadow = true;
            hiveGroup.add(hiveBase);
            
            const hiveTopGeometry = new THREE.ConeGeometry(2.5, 2, 8);
            const hiveTopMaterial = new THREE.MeshStandardMaterial({
                color: 0xA0522D,
                roughness: 0.8
            });
            const hiveTop = new THREE.Mesh(hiveTopGeometry, hiveTopMaterial);
            hiveTop.position.y = 5;
            hiveGroup.add(hiveTop);
            
            for (let i = 0; i < 4; i++) {
                const stripeGeometry = new THREE.TorusGeometry(2.2, 0.2, 8, 32, Math.PI * 2);
                const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.y = 1 + i * 1.5;
                stripe.rotation.x = Math.PI / 2;
                hiveGroup.add(stripe);
            }
            
            const entranceGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 8);
            const entranceMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
            entrance.position.set(1.5, 0.5, 1.5);
            hiveGroup.add(entrance);
            
            const hiveLight = new THREE.PointLight(0xFFD700, 1, 10);
            hiveLight.position.set(0, 3, 0);
            hiveGroup.add(hiveLight);
            
            const honeyParticles = new THREE.Group();
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 1.5;
                const height = Math.random() * 2;
                
                particle.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                particle.userData = {
                    angle: angle,
                    radius: radius,
                    speed: 0.01 + Math.random() * 0.02,
                    height: height,
                    floatSpeed: 0.02 + Math.random() * 0.03
                };
                
                honeyParticles.add(particle);
            }
            hiveGroup.add(honeyParticles);
            
            hiveGroup.position.set(x, 0, z);
            scene.add(hiveGroup);
            
            hiveGroup.userData = {
                isHoneyHive: true,
                honeyCollected: false,
                honeyValue: 50 + round * 10,
                particles: honeyParticles,
                particleTimer: 0,
                bees: []
            };
            
            return hiveGroup;
        }

        function createHiveBees(hive, beeCount) {
            const bees = [];
            const hivePos = new THREE.Vector3();
            hive.getWorldPosition(hivePos);
            const waveCount = 3;
            const beesPerWave = Math.ceil(beeCount / waveCount);
            
            for (let wave = 0; wave < waveCount; wave++) {
                for (let i = 0; i < beesPerWave && bees.length < beeCount; i++) {
                    const angle = ((wave * beesPerWave + i) / beeCount) * Math.PI * 2;
                    const distance = 2 + Math.random() * 1;
                    const beeX = hivePos.x + Math.cos(angle) * distance;
                    const beeZ = hivePos.z + Math.sin(angle) * distance;
                    const bee = createBee(beeX, beeZ);
                    bee.userData.isHiveGuard = true;
                    bee.userData.hive = hive;
                    bee.userData.orbitAngle = angle;
                    bee.userData.orbitDistance = distance;
                    bee.userData.orbitSpeed = 0.05 + Math.random() * 0.02;
                    bee.userData.speed = 0.3;
                    bee.userData.attackWave = wave;
                    bee.userData.attackDelay = wave * 2000;
                    bees.push(bee);
                }
            }
            
            hive.userData.bees = bees;
            return bees;
        }

        function createBeeSting(fromPos, toPos) {
            const stingGroup = new THREE.Group();
            const stingGeometry = new THREE.CylinderGeometry(0.05, 0.02, 1, 8);
            const stingMaterial = new THREE.MeshBasicMaterial({
                color: 0x333333
            });
            const sting = new THREE.Mesh(stingGeometry, stingMaterial);
            sting.rotation.x = Math.PI / 2;
            stingGroup.add(sting);
            stingGroup.position.copy(fromPos);
            const direction = new THREE.Vector3().subVectors(toPos, fromPos).normalize();
            stingGroup.lookAt(toPos);
            scene.add(stingGroup);
            stingGroup.userData = {
                type: 'beeSting',
                direction: direction,
                speed: 0.5,
                damage: 6,
                distanceTraveled: 0,
                maxDistance: 30
            };
            beeStings.push(stingGroup);
            playSound(800, 'sawtooth', 0.1, 0.2);
        }

        // ===== ÿßŸÑŸÖÿµŸÅŸàŸÅÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© =====
        const sheeps = [];
        const wolves = [];
        const coins = [];
        const effects = [];
        const mountains = [];
        const wolfProjectiles = [];
        const platforms = [];
        const bombBoxes = [];
        const bees = [];
        const beeStings = [];
        const crocodiles = [];
        const beeHives = [];
        const hills = [];
        const eagles = [];
        const snatchingEagles = []; // ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©

        // ===== ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ© =====
        let score = 0;
        let coinsCollected = 0;
        let sheepCollected = 0;
        let level = 1;
        let round = 1;
        let gameOver = false;
        let gameStarted = false;

        // ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿπÿßŸÑŸÖŸäÿ© ŸÑŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÖÿ≠ŸÑŸäÿ©
        window.gameScore = score;
        window.coinsCollected = coinsCollected;
        window.sheepCollected = sheepCollected;
        window.round = round;
        let isRoundTransition = false;
        let playerHealth = 100;
        const maxPlayerHealth = 100;
        let lastHitTime = 0;
        const hitCooldown = 1000;
        let lastAttackTime = 0;
        const attackCooldown = 500;
        let bombs = 0;

        // ===== ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÉŸÖ =====
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let previousTouchX = 0;
        let previousTouchY = 0;
        const mouseSensitivity = 0.003;
        const touchSensitivity = 0.005;
        let cameraTouchId = null;
        const buttonTouchIds = new Map();
        let totalSheeps = 0;

        let cameraDistance = 10;
        let cameraHeight = 5;
        let cameraAngle = 0;

        let joystickActive = false;
        let joystickTouchId = null;
        let joystickCenterX = 0;
        let joystickCenterY = 0;
        let joystickRadius = 75;
        let joystickDirection = {
            x: 0,
            y: 0
        };

        let bombCharge = 0;
        let isChargingBomb = false;
        let bombChargeSpeed = 0.03;
        let bombMaxRadius = 80;
        let bombRangeIndicator = null;

        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            arrowup: false,
            arrowleft: false,
            arrowdown: false,
            arrowright: false
        };

        // ===== ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ™ÿ¨ŸÖŸäÿØ ÿßŸÑÿ¢ŸÖŸÜ =====
        let isGameFrozen = false;
        let lastTime = 0;
        let gameLoopId;

        // ===== ÿπŸÜÿßÿµÿ± Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ =====
        const startScreen = document.getElementById("startScreen");
        const startGameBtn = document.getElementById("startGameBtn");
        
        
        // ===== ŸÜÿ∏ÿßŸÖ ŸÑŸàÿ≠ÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ ÿßŸÑŸÖÿ∑Ÿàÿ± =====
        const API_URL = "https://script.google.com/macros/s/AKfycbx0QuA_qhDPkHDtabr1ugc_dwwRsMKTM1aP5xtRQ0Ui4J7bjrc8EhAACdc25dxHKKLsCA/exec";

        function loadLeaderboard() {
            const list = document.getElementById("leaderboardList");
            if (!list) return;
            
            fetch(API_URL)
                .then(res => res.json())
                .then(serverData => {
                    list.innerHTML = "";
                    let combinedData = [...serverData];
                    combinedData.sort((a, b) => (parseInt(b[2]) || 0) - (parseInt(a[2]) || 0));
                    
                    if (combinedData.length > 0) {
                        combinedData.slice(0, 10).forEach((row, index) => {
                            const li = document.createElement("li");
                            li.className = "leaderboard-item";
                            li.innerHTML = `<span>${index + 1}Ô∏è‚É£ ${row[0]} (${row[1]})</span><span style="color: #ffd700; font-weight: bold;">${row[2]} ŸÜŸÇÿ∑ÿ©</span>`;
                            list.appendChild(li);
                        });
                    } else {
                        list.innerHTML = "<li style='text-align: center; opacity: 0.6;'>ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨ ŸÖÿ≥ÿ¨ŸÑÿ© ÿ®ÿπÿØ</li>";
                    }
                })
                .catch(err => {
                    console.error("Error loading leaderboard:", err);
                });
        }

        window.submitScoreToLeaderboard = function() {
            console.log("üöÄ ÿ®ÿØÿ° ÿ≠ŸÅÿ∏ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©...");
            const nameInput = document.getElementById("playerName");
            const schoolInput = document.getElementById("playerSchool");
            const btn = document.getElementById("submitScoreBtn");
            
            if (!nameInput || !schoolInput || !btn) return;
            
            const name = nameInput.value.trim();
            const school = schoolInput.value.trim();
            
            if (!name || !school) {
                alert("‚ö†Ô∏è ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿßÿ≥ŸÖ ŸàÿßŸÑŸÖÿØÿ±ÿ≥ÿ©");
                return;
            }
            
            const score = window.finalScore || window.gameScore || window.score || 0;
            
            console.log("üìä ŸÇŸäŸÖ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÅŸä ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ£ŸàŸÑŸâ:");
            console.log("  - name:", name);
            console.log("  - school:", school);
            console.log("  - window.finalScore:", window.finalScore);
            console.log("  - window.gameScore:", window.gameScore);
            console.log("  - score:", score);
            
            btn.disabled = true;
            btn.textContent = "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ŸÅÿ∏... ‚è≥";
            
            // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿßŸÑŸÖÿÆŸÅŸä ŸÑŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿπÿ®ÿ± POST - ÿßŸÑÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿ£ŸÉÿ´ÿ± ÿ∂ŸÖÿßŸÜÿßŸã
            try {
                const saveForm = document.getElementById('saveForm');
                const hiddenName = document.getElementById('hiddenName');
                const hiddenSchool = document.getElementById('hiddenSchool');
                const hiddenScore = document.getElementById('hiddenScore');
                
                if (saveForm && hiddenName && hiddenSchool && hiddenScore) {
                    hiddenName.value = name;
                    hiddenSchool.value = school;
                    hiddenScore.value = score;
                    
                    saveForm.submit();
                    console.log("‚úÖ ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿ®ŸÜÿ¨ÿßÿ≠");
                    setTimeout(handleSuccess, 1500);
                } else {
                    throw new Error("Form elements not found");
                }
            } catch (error) {
                console.error("‚ùå ŸÅÿ¥ŸÑ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ÿå ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ÿπÿ®ÿ± fetch:", error);
                // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ®ÿØŸäŸÑÿ© ŸÅŸä ÿ≠ÿßŸÑ ŸÅÿ¥ŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨
                const baseUrl = "https://script.google.com/macros/s/AKfycbzQaSrbe596ppDbDdAnmaLmx3Of54-e4BTZkgL3Gf7Nfj3CwJbh8hqKUBUk7AwP-uqTEA/exec";
                const url = `${baseUrl}?name=${encodeURIComponent(name)}&school=${encodeURIComponent(school)}&score=${score}`;
                fetch(url, { method: 'GET', mode: 'no-cors' }).finally(() => handleSuccess());
            }
            
            function handleSuccess() {
                btn.textContent = "ÿ™ŸÖ ÿßŸÑÿ≠ŸÅÿ∏ ‚úÖ";
                btn.style.background = "#2e7d32";
                
                const successDiv = document.createElement("div");
                successDiv.style = "position:fixed;top:20px;left:50%;transform:translateX(-50%);background:#4CAF50;color:white;padding:15px 30px;border-radius:10px;z-index:10000;font-size:18px;box-shadow:0 5px 20px rgba(0,0,0,0.3);border:2px solid white;";
                successDiv.textContent = "‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿ®ŸÜÿ¨ÿßÿ≠!";
                document.body.appendChild(successDiv);
                
                setTimeout(() => successDiv.remove(), 3000);
                setTimeout(() => {
                    if (typeof openLeaderboard === 'function') openLeaderboard();
                }, 1000);
            }
        };

        function showSuccessMessage(msg) {
            const div = document.createElement("div");
            div.style = "position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,128,0,0.9);color:white;padding:20px;border-radius:10px;z-index:10000;text-align:center;";
            div.innerHTML = msg;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 3000);
        }

        function initializeSubmitButton() {
            const btn = document.getElementById("submitScoreBtn");
            if (btn) {
                btn.onclick = null;
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("‚úÖ Submit button clicked!");
                    window.submitScoreToLeaderboard();
                });
                console.log("‚úÖ Submit button initialized");
            }
        }

        window.showGameOver = function() {
            gameOver = true;
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿπÿßŸÑŸÖŸäÿ©
            window.gameScore = score;
            window.finalScore = score; // ÿ•ÿ∂ÿßŸÅÿ© finalScore ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©
            window.coinsCollected = coinsCollected;
            window.round = round;
            
            const panel = document.getElementById("gameOverPanel");
            if(panel) {
                panel.style.display = "block";
                
                // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
                document.getElementById("finalScore").textContent = score;
                document.getElementById("finalCoins").textContent = coinsCollected;
                
                // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ≠ŸÇŸàŸÑ ÿßŸÑÿ•ÿØÿÆÿßŸÑ
                document.getElementById("playerName").value = "";
                document.getElementById("playerSchool").value = "";
                
                // ÿ•ÿπÿßÿØÿ© ÿ™ŸáŸäÿ¶ÿ© ÿ≤ÿ± ÿßŸÑÿ≠ŸÅÿ∏
                const btn = document.getElementById("submitScoreBtn");
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = "ÿ≠ŸÅÿ∏ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© üèÜ";
                    btn.style.background = "";
                }
                
                console.log("üèÅ ŸÜŸáÿßŸäÿ© ÿßŸÑŸÑÿπÿ®ÿ© - ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©:", score, "ÿßŸÑÿπŸÖŸÑÿßÿ™:", coinsCollected);
            }
            
            // ÿ™ÿ≠ŸÖŸäŸÑ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ
            setTimeout(() => {
                if (typeof loadLeaderboard === 'function') {
                    loadLeaderboard();
                }
            }, 500);
            
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
        };

        document.addEventListener('DOMContentLoaded', () => {
            loadLeaderboard();
            const panel = document.getElementById("gameOverPanel");
            if(panel) {
                const obs = new MutationObserver(() => {
                    if(panel.style.display === 'block') setTimeout(initializeSubmitButton, 200);
                });
                obs.observe(panel, { attributes: true });
            }
        });
const finalScore = document.getElementById("finalScore");
        finalScore.textContent = "0";
        const finalCoins = document.getElementById("finalCoins");
        finalCoins.textContent = "0";
        const restartBtn = document.getElementById("restartBtn");
        const attackBtn = document.getElementById("attackBtn");
        const jumpBtn = document.getElementById("jumpBtn");
        const bombBtn = document.getElementById("bombBtn");
        const buyHealthBtn = document.getElementById("buyHealthBtn");
        const laserSight = document.getElementById("laserSight");
        const movementControls = document.getElementById("movementControls");
        const roundIndicator = document.getElementById("roundIndicator");
        const nextRoundBtn = document.getElementById("nextRoundBtn");
        const roundTransition = document.getElementById("roundTransition");
        const roundMessage = document.getElementById("roundMessage");
        const healthIndicator = document.getElementById("healthIndicator");
        const healthBar = document.getElementById("healthBar");
        const questionPanel = document.getElementById("questionPanel");
        const questionText = document.getElementById("questionText");
        const sequenceContainer = document.getElementById("sequenceContainer");
        const optionsContainer = document.getElementById("optionsContainer");
        const playerDamageEffect = document.getElementById("playerDamageEffect");
        const emergencyFixBtn = document.getElementById("emergencyFixBtn");

        const joystickBase = document.getElementById("joystickBase");
        const joystickHandle = document.getElementById("joystickHandle");

        const bombChargeIndicator = document.getElementById("bombChargeIndicator");
        const bombChargeBar = document.getElementById("bombChargeBar");

        const treasureBoxes = [];

        // ===== ÿØŸàÿßŸÑ ÿßŸÑÿ™ÿ¨ŸÖŸäÿØ ÿßŸÑÿ¢ŸÖŸÜ =====
        function freezeGame() {
            isGameFrozen = true;
            if (movementControls) movementControls.style.pointerEvents = 'none';
            if (attackBtn) attackBtn.style.pointerEvents = 'none';
            if (jumpBtn) jumpBtn.style.pointerEvents = 'none';
            if (bombBtn) bombBtn.style.pointerEvents = 'none';
            if (emergencyFixBtn) emergencyFixBtn.style.display = 'block';
            console.log("Game frozen for question");
        }

        function unfreezeGame() {
            isGameFrozen = false;
            if (movementControls) movementControls.style.pointerEvents = 'auto';
            if (attackBtn) attackBtn.style.pointerEvents = 'auto';
            if (jumpBtn) jumpBtn.style.pointerEvents = 'auto';
            if (bombBtn) bombBtn.style.pointerEvents = 'auto';
            if (emergencyFixBtn) emergencyFixBtn.style.display = 'none';
            if (questionPanel) questionPanel.style.display = "none";
            lastTime = performance.now();
            console.log("Game unfrozen");
        }

        function safeUnfreezeGame() {
            if (isGameFrozen) {
                console.log("Safe unfreeze called");
                isGameFrozen = false;
                movementControls.style.pointerEvents = 'auto';
                attackBtn.style.pointerEvents = 'auto';
                jumpBtn.style.pointerEvents = 'auto';
                bombBtn.style.pointerEvents = 'auto';
                questionPanel.style.display = "none";
                const mBtn = document.getElementById('mathHelpBtn');
                if (mBtn) mBtn.style.display = 'none'; // ÿ•ÿÆŸÅÿßÿ° ÿ≤ÿ± ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿπŸÜÿØ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ∑Ÿàÿßÿ±ÿ¶
                emergencyFixBtn.style.display = 'none';
                lastTime = performance.now();
                playSound(440, 'sine', 0.1, 0.2);
                alert('ÿ™ŸÖ ÿ•ÿµŸÑÿßÿ≠ ÿßŸÑŸÑÿπÿ®ÿ©!');
            }
        }

        // ===== ÿØŸàÿßŸÑ ÿßŸÑŸÑÿπÿ®ÿ© =====
        function getArabicNumber(num) {
            const arabicNumbers = {
                1: "ÿßŸÑÿ£ŸàŸÑ", 2: "ÿßŸÑÿ´ÿßŸÜŸä", 3: "ÿßŸÑÿ´ÿßŸÑÿ´", 4: "ÿßŸÑÿ±ÿßÿ®ÿπ", 5: "ÿßŸÑÿÆÿßŸÖÿ≥",
                6: "ÿßŸÑÿ≥ÿßÿØÿ≥", 7: "ÿßŸÑÿ≥ÿßÿ®ÿπ", 8: "ÿßŸÑÿ´ÿßŸÖŸÜ", 9: "ÿßŸÑÿ™ÿßÿ≥ÿπ", 10: "ÿßŸÑÿπÿßÿ¥ÿ±",
                11: "ÿßŸÑÿ≠ÿßÿØŸä ÿπÿ¥ÿ±", 12: "ÿßŸÑÿ´ÿßŸÜŸä ÿπÿ¥ÿ±", 13: "ÿßŸÑÿ´ÿßŸÑÿ´ ÿπÿ¥ÿ±", 14: "ÿßŸÑÿ±ÿßÿ®ÿπ ÿπÿ¥ÿ±",
                15: "ÿßŸÑÿÆÿßŸÖÿ≥ ÿπÿ¥ÿ±"
            };
            return arabicNumbers[num] || num;
        }

        // ŸÖÿ≠ÿ±ŸÉ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿπÿ™ŸÖÿØ ÿπŸÑŸâ ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑŸÖÿßÿØÿ© (ŸÜÿ∏ÿßŸÖ ÿØŸäŸÜÿßŸÖŸäŸÉŸä ŸÖÿ≠ÿ≥ŸëŸÜ)
        const questionBank = [
            {
                unit: "ÿßŸÑÿ£ÿπÿØÿßÿØ ÿßŸÑŸÜÿ≥ÿ®Ÿäÿ©",
                create: () => {
                    const val = Math.floor(Math.random() * 100) - 50;
                    const absVal = Math.abs(val);
                    return { 
                        q: `ŸÖÿß ŸáŸä ŸÇŸäŸÖÿ© ÿßŸÑŸÖŸÇÿØÿßÿ±: $|${val}|$ÿü`, 
                        ans: absVal, 
                        subTopic: "ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©",
                        wrong: [
                            -absVal, 
                            Math.floor(Math.random() * 50) + 1, 
                            Math.floor(Math.random() * 50) + 1
                        ] 
                    };
                }
            },
            {
                unit: "ÿßŸÑÿ£ÿπÿØÿßÿØ ÿßŸÑŸÜÿ≥ÿ®Ÿäÿ©",
                create: () => {
                    const nums = [
                        {n:1, d:3, t:"ÿØŸàÿ±Ÿä"}, {n:2, d:5, t:"ŸÖŸÜÿ™ŸáŸä"}, 
                        {n:4, d:9, t:"ÿØŸàÿ±Ÿä"}, {n:7, d:8, t:"ŸÖŸÜÿ™ŸáŸä"},
                        {n:3, d:7, t:"ÿØŸàÿ±Ÿä"}, {n:5, d:4, t:"ŸÖŸÜÿ™ŸáŸä"},
                        {n:1, d:6, t:"ÿØŸàÿ±Ÿä"}, {n:3, d:10, t:"ŸÖŸÜÿ™ŸáŸä"}
                    ];
                    const pick = nums[Math.floor(Math.random()*nums.length)];
                    return { 
                        q: `ÿßŸÑŸÉÿ≥ÿ± ÿßŸÑÿπÿ¥ÿ±Ÿä ÿßŸÑŸÜÿßÿ™ÿ¨ ÿπŸÜ ÿ™ÿ≠ŸàŸäŸÑ $\\frac{${pick.n}}{${pick.d}}$ ŸáŸà ŸÉÿ≥ÿ±:`, 
                        ans: pick.t, 
                        subTopic: "ÿßŸÑŸÉÿ≥Ÿàÿ± ÿßŸÑÿπÿ¥ÿ±Ÿäÿ©",
                        wrong: pick.t === "ÿØŸàÿ±Ÿä" ? ["ŸÖŸÜÿ™ŸáŸä", "ÿµÿ≠Ÿäÿ≠", "ÿ∫Ÿäÿ± ŸÜÿ≥ÿ®Ÿä"] : ["ÿØŸàÿ±Ÿä", "ÿ∫Ÿäÿ± ŸÖŸÜÿ™ŸáŸä", "ÿØÿßÿ¶ÿ±Ÿä"]
                    };
                }
            },
            {
                unit: "ÿßŸÑÿ£ÿ≥ÿ≥ ŸàÿßŸÑÿ¨ÿ∞Ÿàÿ±",
                create: () => {
                    const base = Math.floor(Math.random() * 8) + 2;
                    const p = Math.floor(Math.random() * 4) + 2;
                    const result = Math.pow(base, p);
                    return { 
                        q: `ÿ£Ÿàÿ¨ÿØ ŸÇŸäŸÖÿ© ÿßŸÑŸÇŸàÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©: $${base}^{${p}}$`, 
                        ans: result, 
                        subTopic: "ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÇŸàŸâ",
                        wrong: [
                            base * p, 
                            Math.pow(p, base), 
                            result + Math.floor(Math.random() * 20) + 5
                        ] 
                    };
                }
            },
            {
                unit: "ÿßŸÑÿ£ÿ≥ÿ≥ ŸàÿßŸÑÿ¨ÿ∞Ÿàÿ±",
                create: () => {
                    const bases = [4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169];
                    const base = bases[Math.floor(Math.random() * bases.length)];
                    const result = Math.sqrt(base);
                    return { 
                        q: `ÿ£Ÿàÿ¨ÿØ ŸÇŸäŸÖÿ© $\\sqrt{${base}}$`, 
                        ans: result, 
                        subTopic: "ÿßŸÑÿ¨ÿ∞Ÿàÿ± ÿßŸÑÿ™ÿ±ÿ®ŸäÿπŸäÿ©",
                        wrong: [
                            result + Math.floor(Math.random() * 5) + 1,
                            result - Math.floor(Math.random() * 5) - 1,
                            base / 2
                        ] 
                    };
                }
            },
            {
                unit: "ÿßŸÑÿ™ŸÜÿßÿ≥ÿ®",
                create: () => {
                    const kValues = [6, 12, 18, 24, 30];
                    const k = kValues[Math.floor(Math.random() * kValues.length)];
                    const xValues = [1, 2, 3, 4, 5, 6];
                    const x = xValues[Math.floor(Math.random() * xValues.length)];
                    const y = k / x;
                    return { 
                        q: `ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿπŸÑÿßŸÇÿ© ÿ®ŸäŸÜ $x, y$ ÿ™ŸÖÿ´ŸÑ ÿ™ŸÜÿßÿ≥ÿ®ÿßŸã ÿπŸÉÿ≥ŸäÿßŸã ÿ´ÿßÿ®ÿ™Ÿá $k=${k}$ÿå ŸÅŸÖÿß ŸÇŸäŸÖÿ© $y$ ÿπŸÜÿØŸÖÿß $x=${x}$ÿü`, 
                        ans: y, 
                        subTopic: "ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿπŸÉÿ≥Ÿä",
                        wrong: [
                            k * x, 
                            x, 
                            k + x
                        ] 
                    };
                }
            },
            {
                unit: "ÿßŸÑÿ™ŸÜÿßÿ≥ÿ®",
                create: () => {
                    const k = Math.floor(Math.random() * 8) + 2;
                    const x = Math.floor(Math.random() * 10) + 1;
                    const y = k * x;
                    return { 
                        q: `ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ $y = ${k}x$ÿå ŸÅŸÖÿß ŸÇŸäŸÖÿ© $y$ ÿπŸÜÿØŸÖÿß $x = ${x}$ÿü`, 
                        ans: y, 
                        subTopic: "ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿ∑ÿ±ÿØŸä",
                        wrong: [
                            y + Math.floor(Math.random() * 20) + 1,
                            y - Math.floor(Math.random() * 20) - 1,
                            x
                        ] 
                    };
                }
            },
            {
                unit: "ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇÿßÿ™ ÿßŸÑŸÖÿßŸÑŸäÿ©",
                create: () => {
                    const prices = [50, 100, 150, 200, 250];
                    const taxRates = [5, 10, 15, 20];
                    const price = prices[Math.floor(Math.random() * prices.length)];
                    const taxRate = taxRates[Math.floor(Math.random() * taxRates.length)];
                    const tax = (price * taxRate) / 100;
                    const final = price + tax;
                    return { 
                        q: `ÿ≥ŸÑÿπÿ© ÿ≥ÿπÿ±Ÿáÿß $${price} JD$ÿå ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ∂ÿ±Ÿäÿ®ÿ© ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™ $${taxRate}\\%$ÿå ŸÅŸÉŸÖ Ÿäÿµÿ®ÿ≠ ÿ≥ÿπÿ±Ÿáÿß ÿ®ÿπÿØ ÿßŸÑÿ∂ÿ±Ÿäÿ®ÿ©ÿü`, 
                        ans: `${final} JD`, 
                        subTopic: "ÿ∂ÿ±Ÿäÿ®ÿ© ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™",
                        wrong: [
                            `${price} JD`, 
                            `${tax} JD`, 
                            `${final + Math.floor(Math.random() * 20) + 5} JD`
                        ] 
                    };
                }
            },
            {
                unit: "ÿßŸÑŸáŸÜÿØÿ≥ÿ©",
                create: () => {
                    const angles = [
                        {n:3, sum:180, name:"ÿßŸÑŸÖÿ´ŸÑÿ´"},
                        {n:4, sum:360, name:"ÿßŸÑÿ¥ŸÉŸÑ ÿßŸÑÿ±ÿ®ÿßÿπŸä"},
                        {n:5, sum:540, name:"ÿßŸÑÿ¥ŸÉŸÑ ÿßŸÑÿÆŸÖÿßÿ≥Ÿä"},
                        {n:6, sum:720, name:"ÿßŸÑÿ¥ŸÉŸÑ ÿßŸÑÿ≥ÿØÿßÿ≥Ÿä"},
                        {n:8, sum:1080, name:"ÿßŸÑÿ¥ŸÉŸÑ ÿßŸÑÿ´ŸÖÿßŸÜŸä"}
                    ];
                    const pick = angles[Math.floor(Math.random()*angles.length)];
                    return { 
                        q: `ŸÖÿß ŸÖÿ¨ŸÖŸàÿπ ŸÇŸäÿßÿ≥ÿßÿ™ ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑÿØÿßÿÆŸÑŸäÿ© ŸÑŸÄ ${pick.name}ÿü`, 
                        ans: `${pick.sum}^\\circ`, 
                        subTopic: "ÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ∂ŸÑÿπ",
                        wrong: [
                            `$${pick.sum - 180}^\\circ$`, 
                            `$${pick.sum + 180}^\\circ$`, 
                            `$${pick.sum / 2}^\\circ$`
                        ] 
                    };
                }
            },
            {
                unit: "ÿßŸÑŸáŸÜÿØÿ≥ÿ©",
                create: () => {
                    const angle1 = Math.floor(Math.random() * 80) + 10;
                    const complementary = 90 - angle1;
                    const supplementary = 180 - angle1;
                    const type = Math.random() > 0.5;
                    
                    if (type) {
                        return {
                            q: `ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ•ÿ≠ÿØŸâ ÿßŸÑÿ≤ÿßŸàŸäÿ™ŸäŸÜ ÿßŸÑŸÖÿ™ÿ™ÿßŸÖÿ™ŸäŸÜ $${angle1}^\\circ$ÿå ŸÅŸÖÿß ŸÇŸäÿßÿ≥ ÿßŸÑÿ≤ÿßŸàŸäÿ© ÿßŸÑÿ£ÿÆÿ±Ÿâÿü`,
                            ans: complementary,
                            subTopic: "ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ÿ™ÿßŸÖÿ© ŸàÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©",
                            wrong: [supplementary, angle1, 180 - angle1 - 30]
                        };
                    } else {
                        return {
                            q: `ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ•ÿ≠ÿØŸâ ÿßŸÑÿ≤ÿßŸàŸäÿ™ŸäŸÜ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ™ŸäŸÜ $${angle1}^\\circ$ÿå ŸÅŸÖÿß ŸÇŸäÿßÿ≥ ÿßŸÑÿ≤ÿßŸàŸäÿ© ÿßŸÑÿ£ÿÆÿ±Ÿâÿü`,
                            ans: supplementary,
                            subTopic: "ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ÿ™ÿßŸÖÿ© ŸàÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©",
                            wrong: [complementary, angle1, 90 - angle1]
                        };
                    }
                }
            },
            // ÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ŸÖŸÖÿ© (ÿ≤ŸàÿßŸäÿß ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸÇŸäŸÖ Ÿàÿßÿ≠ÿØ)
            {
                unit: "ÿßŸÑŸáŸÜÿØÿ≥ÿ©",
                create: () => {
                    const angle = Math.floor(Math.random() * 80) + 40;
                    const x = 180 - angle;
                    const svg = `<svg width="280" height="160" viewBox="0 0 280 160" style="max-width:100%"><line x1="20" y1="120" x2="260" y2="120" stroke="#ffffff" stroke-width="3"/><line x1="140" y1="120" x2="${140 + 80 * Math.cos((180-angle) * Math.PI / 180)}" y2="${120 - 80 * Math.sin((180-angle) * Math.PI / 180)}" stroke="#4facfe" stroke-width="3"/><text x="170" y="105" font-size="16" font-weight="bold" fill="#ffffff">${angle}¬∞</text><text x="80" y="105" font-size="18" font-weight="bold" fill="#ff4b2b">x</text></svg>`;
                    return { 
                        q: `ÿ£Ÿàÿ¨ÿØ ŸÇŸäŸÖÿ© x ŸÅŸä ÿßŸÑÿ¥ŸÉŸÑ (ÿßŸÑÿ≤ÿßŸàŸäÿ™ÿßŸÜ ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸÇŸäŸÖ Ÿàÿßÿ≠ÿØ)`, 
                        ans: `${x}^\\circ`, 
                        subTopic: "ÿ≤ŸàÿßŸäÿß ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸÇŸäŸÖ",
                        wrong: [
                            `${angle}^\\circ`, 
                            `90^\\circ`, 
                            `100^\\circ`
                        ],
                        svg: svg
                    };
                }
            },
            // ÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ŸÇÿßÿ®ŸÑÿ© ÿ®ÿßŸÑÿ±ÿ£ÿ≥
            {
                unit: "ÿßŸÑŸáŸÜÿØÿ≥ÿ©",
                create: () => {
                    const angle = Math.floor(Math.random() * 60) + 30;
                    const svg = `<svg width="280" height="160" viewBox="0 0 280 160" style="max-width:100%"><line x1="50" y1="30" x2="230" y2="130" stroke="#ffffff" stroke-width="2"/><line x1="50" y1="130" x2="230" y2="30" stroke="#ffffff" stroke-width="2"/><text x="140" y="60" font-size="16" font-weight="bold" fill="#ffffff">${angle}¬∞</text><text x="140" y="125" font-size="18" font-weight="bold" fill="#ff4b2b">x</text></svg>`;
                    return { 
                        q: `ÿ£Ÿàÿ¨ÿØ ŸÇŸäŸÖÿ© x (ÿ≤ÿßŸàŸäÿ™ÿßŸÜ ŸÖÿ™ŸÇÿßÿ®ŸÑÿ™ÿßŸÜ ÿ®ÿßŸÑÿ±ÿ£ÿ≥)`, 
                        ans: `${angle}^\\circ`, 
                        subTopic: "ÿßŸÑÿ™ŸÇÿßÿ®ŸÑ ÿ®ÿßŸÑÿ±ÿ£ÿ≥",
                        wrong: [
                            `${180-angle}^\\circ`, 
                            `90^\\circ`, 
                            `${angle+10}^\\circ`
                        ],
                        svg: svg
                    };
                }
            },
            // ÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ŸÇŸäŸÖÿßÿ™ ÿßŸÑŸÖÿ™Ÿàÿßÿ≤Ÿäÿ© (ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ÿ®ÿßÿØŸÑÿ© ÿßŸÑÿØÿßÿÆŸÑŸäÿ©)
            {
                unit: "ÿßŸÑŸáŸÜÿØÿ≥ÿ©",
                create: () => {
                    const angle = Math.floor(Math.random() * 60) + 50;
                    const svg = `<svg width="280" height="160" viewBox="0 0 280 160" style="max-width:100%"><line x1="30" y1="40" x2="250" y2="40" stroke="#ffffff" stroke-width="2"/><line x1="30" y1="120" x2="250" y2="120" stroke="#ffffff" stroke-width="2"/><line x1="60" y1="150" x2="200" y2="10" stroke="#ff4b2b" stroke-width="2"/><text x="150" y="35" font-size="16" font-weight="bold" fill="#ffffff">${angle}¬∞</text><text x="100" y="115" font-size="18" font-weight="bold" fill="#ff4b2b">x</text></svg>`;
                    return { 
                        q: `ŸÅŸä ÿßŸÑÿ¥ŸÉŸÑ ŸÖÿ≥ÿ™ŸÇŸäŸÖÿßŸÜ ŸÖÿ™Ÿàÿßÿ≤ŸäÿßŸÜÿå ŸÖÿß ŸÇŸäŸÖÿ© x (ÿ™ÿ®ÿßÿØŸÑ ÿØÿßÿÆŸÑŸä)`, 
                        ans: `${angle}^\\circ`, 
                        subTopic: "ÿßŸÑÿ™ÿ®ÿßÿØŸÑ ÿßŸÑÿØÿßÿÆŸÑŸä",
                        wrong: [
                            `${180-angle}^\\circ`, 
                            `180^\\circ`, 
                            `90^\\circ`
                        ],
                        svg: svg
                    };
                }
            },
            // ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ£ÿ≥ÿ≥ (ÿ∂ÿ±ÿ® ÿßŸÑŸÇŸàŸâ ÿ®ŸÜŸÅÿ≥ ÿßŸÑÿ£ÿ≥ÿßÿ≥)
            {
                unit: "ÿßŸÑÿ£ÿ≥ÿ≥ ŸàÿßŸÑÿ¨ÿ∞Ÿàÿ±",
                create: () => {
                    const b = Math.floor(Math.random() * 5) + 2;
                    const p1 = Math.floor(Math.random() * 4) + 2;
                    const p2 = Math.floor(Math.random() * 4) + 2;
                    const correct = `${b}^{${p1+p2}}`;
                    return { 
                        q: `ÿ®ÿ≥ÿ∑ ÿßŸÑÿ™ÿπÿ®Ÿäÿ± ÿßŸÑÿ™ÿßŸÑŸä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ£ÿ≥ÿ≥: $${b}^{${p1}} \\times ${b}^{${p2}}$`, 
                        ans: correct, 
                        subTopic: "ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ£ÿ≥ÿ≥",
                        wrong: [
                            `${b}^{${p1*p2}}`, 
                            `${b*2}^{${p1+p2}}`, 
                            `${b}^{${Math.abs(p1-p2)}}`
                        ] 
                    };
                }
            }
        ];

        function generateMathQuestion() {
            const type = questionBank[Math.floor(Math.random() * questionBank.length)];
            const data = type.create();
            
            let options = [data.ans, ...data.wrong.slice(0, 3)];
            options = options.sort(() => Math.random() - 0.5);
            
            const formattedOptions = options.map(opt => {
                if (typeof opt === 'string' && /[ÿ£-Ÿä]/.test(opt)) {
                    return opt;
                } else {
                    return `$${opt}$`;
                }
            });

            return {
                question: data.q,
                options: formattedOptions,
                answer: (typeof data.ans === 'string' && /[ÿ£-Ÿä]/.test(data.ans)) ? data.ans : `$${data.ans}$`,
                unit: type.unit,
                subTopic: data.subTopic || type.unit,
                sequence: null,
                svg: data.svg || null
            };
        }

        function displaySequence(sequence) {
            sequenceContainer.innerHTML = '';

            sequence.forEach((term, index) => {
                const termElement = document.createElement('span');
                termElement.className = 'sequence-item';
                termElement.textContent = term;

                if (index < sequence.length - 1) {
                    termElement.textContent += 'ÿå ';
                }

                sequenceContainer.appendChild(termElement);
            });

            const dotsElement = document.createElement('span');
            dotsElement.className = 'sequence-item';
            dotsElement.textContent = '...';
            sequenceContainer.appendChild(dotsElement);
        }

        function spawnPlatforms() {
            // ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖŸÜÿµÿßÿ™ ÿßŸÑÿÆÿ¥ÿ®Ÿäÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿ™ÿ¨ŸÜÿ® ŸÖÿ¥ŸÉŸÑÿ© ÿ®ÿØÿßŸäÿ© ÿßŸÑŸÑÿπÿ® ÿØÿßÿÆŸÑŸáÿß
        }

        function spawnNewSheeps() {
            // ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÜŸäÿå ŸÑÿß ŸÜÿ∂ÿπ ÿÆÿ±ÿßŸÅ ÿ£ÿÆÿ±Ÿâ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ©
            // ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÑÿ´ÿå ÿßŸÑÿÆÿ±ÿßŸÅ ÿ™ŸàŸÑÿØ ŸÅŸä ÿßŸÑŸàÿßÿ≠ÿßÿ™ (ÿÆÿ±ŸàŸÅ ÿ®ŸäŸÜ ÿ™ŸÖÿ≥ÿßÿ≠ŸäŸÜ)
            if (typeof round !== 'undefined' && (round === 2 || round === 3)) {
                return;
            }

            // ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4ÿå ŸÜÿ∂ÿπ 5 ÿÆÿ±ÿßŸÅ ŸÅŸÇÿ∑ ŸÉŸÖÿß ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            const currentSheepCount = 5;
            totalSheeps = currentSheepCount;

            const safeAreaBuffer = 100;
            const safeMinX = worldBounds.minX + safeAreaBuffer;
            const safeMaxX = worldBounds.maxX - safeAreaBuffer;
            const safeMinZ = worldBounds.minZ + safeAreaBuffer;
            const safeMaxZ = worldBounds.maxZ - safeAreaBuffer;
            
            // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÜŸáÿ± ŸÑŸÖŸÜÿπ ÿ∏ŸáŸàÿ± ÿßŸÑÿÆÿ±ÿßŸÅ ÿØÿßÿÆŸÑŸá
            const hillCenterX = -50;
            const hillCenterZ = -50;
            const riverInnerRadius = 40;
            let riverOuterRadius = 180;
            if (typeof round !== 'undefined' && round === 2) {
                riverOuterRadius = 180;
            }

            for (let i = 0; i < currentSheepCount; i++) {
                let sheepX, sheepZ, attempts = 0;
                let validPosition = false;
                
                // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ•Ÿäÿ¨ÿßÿØ ŸÖŸàŸÇÿπ ÿµÿßŸÑÿ≠ ÿÆÿßÿ±ÿ¨ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ±
                while (!validPosition && attempts < 100) {
                    sheepX = Math.random() * (safeMaxX - safeMinX) + safeMinX;
                    sheepZ = Math.random() * (safeMaxZ - safeMinZ) + safeMinZ;
                    
                    // ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ≥ÿßŸÅÿ© ŸÖŸÜ ŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜŸáÿ±
                    const distanceToRiverCenter = Math.sqrt(
                        Math.pow(sheepX - hillCenterX, 2) + 
                        Math.pow(sheepZ - hillCenterZ, 2)
                    );
                    
                    // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿÆÿ±ŸàŸÅ ŸÑŸäÿ≥ ÿØÿßÿÆŸÑ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ± ŸàŸÑŸäÿ≥ ŸÇÿ±Ÿäÿ®ÿßŸã ÿ¨ÿØÿßŸã ŸÖŸÜ ÿßŸÑÿ™ŸÑÿ©
                    if (distanceToRiverCenter > riverOuterRadius) {
                        validPosition = true;
                    }
                    
                    attempts++;
                }
                
                // ÿ•ÿ∞ÿß ŸÑŸÖ ŸÜÿ¨ÿØ ŸÖŸàŸÇÿπ ÿµÿßŸÑÿ≠ÿå ÿ∂ÿπ ÿßŸÑÿÆÿ±ŸàŸÅ ŸÅŸä ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ÿ®ÿπŸäÿØ ÿπŸÜ ÿßŸÑŸÜŸáÿ±
                if (!validPosition) {
                    sheepX = riverOuterRadius + 50;
                    sheepZ = riverOuterRadius + 50;
                }

                const sheep = createSheep(sheepX, 2, sheepZ);
                sheeps.push(sheep);

                // ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4ÿå ÿ•ÿ≠ÿßÿ∑ÿ© ŸÉŸÑ ÿÆÿ±ŸàŸÅ ÿ®ŸÄ 3 ŸÜÿ≥Ÿàÿ± ÿπÿßÿØŸäÿ©
                if (round === 4) {
                    for (let j = 0; j < 3; j++) {
                        const angle = (j / 3) * Math.PI * 2;
                        const distance = 15;
                        const eagleX = sheepX + Math.cos(angle) * distance;
                        const eagleZ = sheepZ + Math.sin(angle) * distance;
                        const eagleY = 10 + Math.random() * 5;
                        
                        const eagle = createEnhancedEagle(eagleX, eagleY, eagleZ);
                        eagle.userData.homeX = sheepX;
                        eagle.userData.homeY = eagleY;
                        eagle.userData.homeZ = sheepZ;
                        eagle.userData.flyRadius = distance;
                        
                        eagles.push(eagle);
                        scene.add(eagle);
                    }
                }

                // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ∞ÿ¶ÿßÿ® ÿßŸÑÿ¥ÿ±ÿ≥ÿ© ÿ≠ŸàŸÑ ÿßŸÑÿÆÿ±ÿßŸÅ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ 3 Ÿà 4 ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                if (round !== 3 && round !== 4) {
                    for (let j = 0; j < 3; j++) {
                        const angle = (j / 3) * Math.PI * 2;
                        const distance = 10;
                        const wolfX = sheepX + Math.cos(angle) * distance;
                        const wolfZ = sheepZ + Math.sin(angle) * distance;

                        const wolfType = "aggressive";
                        const wolf = createWolf(wolfX, wolfZ, wolfType);
                        
                        wolf.userData.protectedSheep = sheep;
                        
                        wolves.push(wolf);
                    }
                }
            }
        }

        function spawnNormalWolvesInQuarters() {
            // ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÜŸäÿå ŸÑÿß ŸÜÿ∂ÿπ ÿ£Ÿä ÿ∞ÿ¶ÿßÿ® ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            if (typeof round !== 'undefined' && round === 2) {
                return;
            }

            let wolvesPerQuarter;
            
            if (round <= 2) {
                wolvesPerQuarter = 2;
            } else if (round <= 4) {
                wolvesPerQuarter = 3;
            } else {
                wolvesPerQuarter = 5;
            }
            
            const hillCenterX = -50;
            const hillCenterZ = -50;
            const riverInnerRadius = 40;
            const riverOuterRadius = 180;

            quarters.forEach((quarter, index) => {
                for (let i = 0; i < wolvesPerQuarter; i++) {
                    let wolfX, wolfZ, attempts = 0;
                    let validPosition = false;

                    while (!validPosition && attempts < 50) {
                        wolfX = Math.random() * (quarter.maxX - quarter.minX) + quarter.minX;
                        wolfZ = Math.random() * (quarter.maxZ - quarter.minZ) + quarter.minZ;
                        
                        const distanceToRiverCenter = Math.sqrt(
                            Math.pow(wolfX - hillCenterX, 2) + 
                            Math.pow(wolfZ - hillCenterZ, 2)
                        );

                        if (distanceToRiverCenter < riverInnerRadius || distanceToRiverCenter > riverOuterRadius) {
                            validPosition = true;
                        }
                        attempts++;
                    }
                    
                    const wolf = createWolf(wolfX, wolfZ, "normal", quarter);
                    
                    wolf.userData.randomTarget = new THREE.Vector3(
                        Math.random() * (quarter.maxX - quarter.minX) + quarter.minX,
                        0,
                        Math.random() * (quarter.maxZ - quarter.minZ) + quarter.minZ
                    );
                    
                    wolves.push(wolf);
                }
            });
        }

        function spawnWavesForRound() {
            spawnNormalWolvesInQuarters();

            // ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 2 ŸàŸÖÿß ŸÅŸàŸÇ: ÿ∏ŸáŸàÿ± ÿßŸÑŸÜÿ≠ŸÑ ÿ®ÿÆŸÑÿßŸäÿß ÿ£ŸÉÿ´ÿ± (ÿ®ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ° ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÜŸä ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ)
            // ÿ•ÿ∂ÿßŸÅÿ© 50 ŸÜÿ≠ŸÑÿ© ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÜŸä ŸÖŸàÿ≤ÿπÿ© ÿ®ÿ¥ŸÉŸÑ ÿ¨ŸäÿØ
            if (round === 2) {
                const hillCenterX = -50;
                const hillCenterZ = -50;
                const riverInnerRadius = 40; // ÿ≠ÿØŸàÿØ ÿßŸÑÿ™ŸÑÿ©
                const riverOuterRadius = 180; // ŸÜÿµŸÅ ŸÇÿ∑ÿ± ÿßŸÑŸÜŸáÿ± ÿßŸÑÿÆÿßÿ±ÿ¨Ÿä ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÜŸä
                
                // 1. Ÿàÿ∂ÿπ 5 ŸÜÿ≠ŸÑÿßÿ™ ÿπŸÑŸâ ÿßŸÑÿ™ŸÑÿ© (ÿØÿßÿÆŸÑ ŸÜÿµŸÅ ŸÇÿ∑ÿ± 40)
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * riverInnerRadius;
                    const beeX = hillCenterX + Math.cos(angle) * distance;
                    const beeZ = hillCenterZ + Math.sin(angle) * distance;
                    bees.push(createBee(beeX, beeZ));
                }

                // 2. Ÿàÿ∂ÿπ 45 ŸÜÿ≠ŸÑÿ© ŸÖŸàÿ≤ÿπÿ© ŸÅŸä ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ± ŸàŸÖÿß ÿ≠ŸàŸÑŸá
                for (let i = 0; i < 45; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = riverInnerRadius + Math.random() * (riverOuterRadius - riverInnerRadius);
                    const beeX = hillCenterX + Math.cos(angle) * distance;
                    const beeZ = hillCenterZ + Math.sin(angle) * distance;
                    bees.push(createBee(beeX, beeZ));
                }
            }

            if (round > 2) {
                // ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑŸÜÿ≠ŸÑ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 3 Ÿàÿ≤ŸäÿßÿØÿ™Ÿá ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿßŸÑÿ£ÿÆÿ±Ÿâ
                let beeCount = 15 + (round - 2) * 5;
                if (round === 3) beeCount = 8; // ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑŸÜÿ≠ŸÑ ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÑÿ´ ŸÉŸÖÿß ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                
                const hillCenterX = -50;
                const hillCenterZ = -50;
                const riverInnerRadius = 40;
                const riverOuterRadius = 180;

                for (let i = 0; i < beeCount; i++) {
                    let beeX, beeZ, attempts = 0;
                    let validPosition = false;

                    while (!validPosition && attempts < 50) {
                        beeX = Math.random() * 900 - 450;
                        beeZ = Math.random() * 900 - 450;
                        
                        const distanceToRiverCenter = Math.sqrt(
                            Math.pow(beeX - hillCenterX, 2) + 
                            Math.pow(beeZ - hillCenterZ, 2)
                        );

                        if (distanceToRiverCenter < riverInnerRadius || distanceToRiverCenter > riverOuterRadius) {
                            validPosition = true;
                        }
                        attempts++;
                    }
                    bees.push(createBee(beeX, beeZ));
                }
                
                const hiveCount = Math.min(round, 8); 
                // ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÖÿπÿ±ŸÅÿ© ÿ≥ÿßÿ®ŸÇÿßŸã ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑŸÜÿ∑ÿßŸÇ

                for (let i = 0; i < hiveCount; i++) {
                    let hiveX, hiveZ, attempts = 0;
                    let validPosition = false;

                    while (!validPosition && attempts < 50) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 80 + Math.random() * 200;
                        hiveX = Math.cos(angle) * distance;
                        hiveZ = Math.sin(angle) * distance;
                        
                        const distanceToRiverCenter = Math.sqrt(
                            Math.pow(hiveX - hillCenterX, 2) + 
                            Math.pow(hiveZ - hillCenterZ, 2)
                        );

                        if (distanceToRiverCenter < riverInnerRadius || distanceToRiverCenter > riverOuterRadius) {
                            validPosition = true;
                        }
                        attempts++;
                    }
                    
                    const hive = createHoneyHive(hiveX, hiveZ);
                    beeHives.push(hive);
                    
                    const hiveBeeCount = 10;
                    createHiveBees(hive, hiveBeeCount);
                }
            }
            
            // ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ 4 ŸàŸÖÿß ŸÅŸàŸÇ: ÿ∏ŸáŸàÿ± ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©
            if (round >= 4) {
                spawnSnatchingEagles();
            }

            // ÿ™ŸÜŸàÿπ ÿ•ÿ∂ÿßŸÅŸä ŸÑŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿ®ÿπÿØ ÿßŸÑÿ±ÿßÿ®ÿπ (ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ∞ÿ¶ÿßÿ® ÿßŸÑÿ¥ÿ±ÿ≥ÿ© ŸÅŸä 3 Ÿà 4)
            if (round > 4) {
                // ÿ≤ŸäÿßÿØÿ© ÿπÿØÿØ ÿßŸÑÿ∞ÿ¶ÿßÿ® ÿßŸÑŸáÿ¨ŸàŸÖŸäÿ© ŸÅŸÇÿ∑ ÿ®ÿπÿØ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ±ÿßÿ®ÿπ
                const extraWolves = Math.min(round - 4, 3); // ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑÿπÿØÿØ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°
                for (let i = 0; i < extraWolves; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 200 + Math.random() * 100;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    wolves.push(createWolf(x, z, "aggressive"));
                }
                
                // ÿ≤ŸäÿßÿØÿ© ÿπÿØÿØ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿπÿßÿØŸäÿ©
                if (round % 2 === 0) {
                    const hill = hills[Math.floor(Math.random() * hills.length)];
                    spawnEaglesAroundHill(hill);
                }
            }

            const treasureBoxCount = 5 + round * 2;
            const hillCenterX = -50;
            const hillCenterZ = -50;
            const riverInnerRadius = 40;
            const riverOuterRadius = 180;

            for (let i = 0; i < treasureBoxCount; i++) {
                let boxX, boxZ, attempts = 0;
                let validPosition = false;

                while (!validPosition && attempts < 50) {
                    boxX = Math.random() * 800 - 400;
                    boxZ = Math.random() * 800 - 400;
                    
                    const distanceToRiverCenter = Math.sqrt(
                        Math.pow(boxX - hillCenterX, 2) + 
                        Math.pow(boxZ - hillCenterZ, 2)
                    );

                    // ŸÖŸÜÿπ ÿßŸÑÿ∏ŸáŸàÿ± ŸÅŸä ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ± (ÿ®ŸäŸÜ 40 Ÿà 180)
                    if (distanceToRiverCenter < riverInnerRadius || distanceToRiverCenter > riverOuterRadius) {
                        validPosition = true;
                    }
                    attempts++;
                }

                if (Math.random() < 0.3) {
                    bombBoxes.push(createBombBox(boxX, boxZ));
                } else {
                    treasureBoxes.push(createHealthBox(boxX, boxZ));
                }
            }

            updateUI();
        }

        function spawnMountains() {
            const mountainCount = 5;
            for (let i = 0; i < mountainCount; i++) {
                const mountainWidth = Math.random() * 30 + 20;
                const mountainHeight = Math.random() * 40 + 30;
                const mountainDepth = Math.random() * 30 + 20;
                const mountainX = Math.random() * 800 - 400;
                const mountainZ = Math.random() * 800 - 400;

                mountains.push(createMountain(mountainX, mountainZ, mountainWidth, mountainHeight, mountainDepth));
            }
        }

        function createHealthBox(x, z) {
            const boxGroup = new THREE.Group();

            const boxBaseGeometry = new THREE.BoxGeometry(2, 1.5, 2);
            const boxBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0xd2b48c,
                roughness: 0.6,
                metalness: 0.3,
            });
            const boxBase = new THREE.Mesh(boxBaseGeometry, boxBaseMaterial);
            boxBase.position.y = 0.75;
            boxBase.castShadow = true;
            boxBase.receiveShadow = true;
            boxGroup.add(boxBase);

            const goldBandGeometry = new THREE.BoxGeometry(2.2, 0.3, 2.2);
            const goldBandMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.2,
                metalness: 0.9,
            });
            const goldBand = new THREE.Mesh(goldBandGeometry, goldBandMaterial);
            goldBand.position.y = 1.6;
            goldBand.castShadow = true;
            goldBand.receiveShadow = true;
            boxGroup.add(goldBand);

            const crossGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.2);
            const crossMaterial = new THREE.MeshBasicMaterial({
                color: 0x333333
            });
            const crossHorizontal = new THREE.Mesh(crossGeometry, crossMaterial);
            crossHorizontal.position.set(0, 1.6, 1.1);

            const crossVertical = new THREE.Mesh(crossGeometry, crossMaterial);
            crossVertical.rotation.y = Math.PI / 2;
            crossVertical.position.set(0, 1.6, 1.1);

            boxGroup.add(crossHorizontal);
            boxGroup.add(crossVertical);

            boxGroup.position.set(x, 0, z);
            scene.add(boxGroup);

            boxGroup.userData = {
                isHealthBox: true,
            };

            return boxGroup;
        }

        function updateUI() {
            scoreDisplay.textContent = `ÿßŸÑŸÜŸÇÿßÿ∑: ${score}`;
            coinsDisplay.textContent = `ÿßŸÑÿπŸÖŸÑÿßÿ™: ${coinsCollected}`;
            sheepDisplay.textContent = `ÿßŸÑÿÆÿ±ÿßŸÅ: ${sheepCollected}/5`;
            bombsDisplay.textContent = `ÿ¥ÿπŸÑÿßÿ™ ÿßŸÑŸÜÿßÿ±: ${bombs}`;
            crocodilesDisplay.textContent = `ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠: ${crocodiles.length}`;
            hivesDisplay.textContent = `ÿÆŸÑÿßŸäÿß ÿßŸÑÿπÿ≥ŸÑ: ${beeHives.filter(h => !h.userData.honeyCollected).length}`;
            eaglesDisplay.textContent = `ÿßŸÑŸÜÿ≥Ÿàÿ±: ${eagles.length}`;
            snatchingEaglesDisplay.textContent = `ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©: ${snatchingEagles.length}`;
            levelDisplay.textContent = level;
            wasteCount.textContent = wolves.length;
            coinsCount.textContent = coinsCollected;
            beesCount.textContent = bees.length;
            crocodilesCount.textContent = crocodiles.length;
            hivesCount.textContent = beeHives.filter(h => !h.userData.honeyCollected).length;
            eaglesCount.textContent = eagles.length;
            snatchingEaglesCount.textContent = snatchingEagles.length;

            const aggressiveWolves = wolves.filter(
                (w) => w.userData.isAggressive
            ).length;
            aggressiveCount.textContent = aggressiveWolves;

            roundIndicator.textContent = `ÿßŸÑÿ¨ŸàŸÑÿ©: ${round}`;

            const healthPercentage = (playerHealth / maxPlayerHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;

            if (sheepCollected >= 5 && !gameOver && !isRoundTransition && gameStarted) {
                nextRoundBtn.style.display = "block";
                nextRoundBtn.disabled = false;
            } else {
                nextRoundBtn.style.display = "none";
            }

            if (bombs <= 0) {
                bombBtn.classList.add("disabled");
            } else {
                bombBtn.classList.remove("disabled");
            }

            if (coinsCollected >= 100 && playerHealth < maxPlayerHealth) {
                buyHealthBtn.classList.remove("disabled");
            } else {
                buyHealthBtn.classList.add("disabled");
            }
        }

        function showSuccessMessage() {
            const successDiv = document.createElement("div");
            successDiv.className = "success-message";
            successDiv.textContent = "ÿ£ÿ≠ÿ≥ŸÜÿ™! ŸÑŸÇÿØ ÿ£ŸÜÿ¨ÿ≤ÿ™ ÿßŸÑŸÖŸáŸÖÿ© ÿ®ŸÜÿ¨ÿßÿ≠";
            document.body.appendChild(successDiv);

            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

        function showHealthGainEffect(x, y, z, amount) {
            const healthDiv = document.createElement("div");
            healthDiv.className = "wolf-health-effect";
            healthDiv.textContent = `+${amount} ÿµÿ≠ÿ©`;
            healthDiv.style.color = "#4caf50";

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            healthDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            healthDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(healthDiv);

            setTimeout(() => {
                healthDiv.remove();
            }, 1000);
        }

        function showHoneyCollectionMessage(x, y, z, amount) {
            const honeyDiv = document.createElement("div");
            honeyDiv.className = "coin-animation";
            honeyDiv.textContent = `+${amount} ÿπÿ≥ŸÑ üçØ`;
            honeyDiv.style.color = "#FFD700";
            honeyDiv.style.fontSize = "28px";
            honeyDiv.style.fontWeight = "bold";

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            honeyDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            honeyDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(honeyDiv);

            setTimeout(() => {
                honeyDiv.remove();
            }, 2000);
        }

        function showBeeDamageEffect(x, y, z, damage) {
            const damageDiv = document.createElement("div");
            damageDiv.className = "wolf-health-effect";
            damageDiv.textContent = `-${damage} üêù`;
            damageDiv.style.color = "#ff9900";
            damageDiv.style.fontSize = "24px";

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            damageDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            damageDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(damageDiv);

            setTimeout(() => {
                damageDiv.remove();
            }, 1000);
        }

        function playHoneyCollectSound() {
            playSound(659, 'sine', 0.1, 0.3);
            setTimeout(() => playSound(784, 'sine', 0.1, 0.3), 100);
            setTimeout(() => playSound(988, 'sine', 0.2, 0.3), 200);
        }

        function nextRound() {
            isRoundTransition = true;
            nextRoundBtn.disabled = true;
            nextRoundBtn.style.display = "none";

            // ÿ•ÿ∂ÿßŸÅÿ© ŸÜŸÇÿßÿ∑ ŸÖŸÉÿßŸÅÿ£ÿ© ŸÑÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©
            score += 500; 
            
            round++;
            playerHealth = maxPlayerHealth;
            sheepCollected = 0;

            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ±
            eagles.forEach((eagle) => scene.remove(eagle));
            eagles.length = 0;
            
            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©
            snatchingEagles.forEach((eagle) => scene.remove(eagle));
            snatchingEagles.length = 0;

            wolves.forEach((wolf) => scene.remove(wolf));
            wolves.length = 0;

            coins.forEach((coin) => scene.remove(coin));
            coins.length = 0;

            wolfProjectiles.forEach((p) => scene.remove(p));
            wolfProjectiles.length = 0;

            effects.forEach((effect) => {
                effect.particles.forEach((particle) => scene.remove(particle));
            });
            effects.length = 0;

            sheeps.forEach((sheep) => scene.remove(sheep));
            sheeps.length = 0;

            treasureBoxes.forEach((box) => scene.remove(box));
            treasureBoxes.length = 0;

            bombBoxes.forEach((box) => scene.remove(box));
            bombBoxes.length = 0;

            platforms.forEach((platform) => scene.remove(platform));
            platforms.length = 0;

            bees.forEach((bee) => scene.remove(bee));
            bees.length = 0;

            beeStings.forEach((sting) => scene.remove(sting));
            beeStings.length = 0;

            crocodiles.forEach((croc) => scene.remove(croc));
            crocodiles.length = 0;

            beeHives.forEach((hive) => scene.remove(hive));
            beeHives.length = 0;

            hills.forEach((hill) => scene.remove(hill));
            hills.length = 0;

            spawnPlatforms();
            spawnNewSheeps();
            spawnWavesForRound();
            addCrocodilesToOasis();

            // ÿ•ÿπÿßÿØÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ™ŸÑÿ© ŸÖÿπ ÿßŸÑŸÜÿ≥Ÿàÿ±
            createClimbingHill(-50, -50, 15);

            let message = `ÿßŸÑÿ¨ŸàŸÑÿ© ${round}`;
            if (beeHives.length > 0) {
                message += ` - ŸáŸÜÿßŸÉ ${beeHives.length} ÿÆŸÑŸäÿ© ÿπÿ≥ŸÑ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖ`;
            }
            if (snatchingEagles.length > 0) {
                message += ` - ÿßÿ≠ÿ∞ÿ± ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©!`;
            }
            roundMessage.textContent = message;

            roundTransition.classList.add("active");

            setTimeout(() => {
                roundTransition.classList.remove("active");
                isRoundTransition = false;
                updateUI();
            }, 2000);
        }

        function isPlayerInQuarter(quarter) {
            player.getWorldPosition(_v1); const playerPos = _v1;
            return playerPos.x >= quarter.minX && playerPos.x <= quarter.maxX &&
                   playerPos.z >= quarter.minZ && playerPos.z <= quarter.maxZ;
        }

        function generateRandomTargetInQuarter(quarter) {
            return new THREE.Vector3(
                Math.random() * (quarter.maxX - quarter.minX) + quarter.minX,
                0,
                Math.random() * (quarter.maxZ - quarter.minZ) + quarter.minZ
            );
        }

        // ===== ÿ™ÿπÿØŸäŸÑ ÿØÿßŸÑÿ© stickAttack ŸÑŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© =====
        function stickAttack() {
            if (!gameStarted || gameOver || isRoundTransition || isGameFrozen) return;

            const currentTime = Date.now();
            if (currentTime - lastAttackTime < attackCooldown) return;

            lastAttackTime = currentTime;

            playStickSound();

            triggerStickAttack(playerModel);

            player.getWorldPosition(_v1); const playerPos = _v1;

            const attackRadius = 6;
            const damage = 50;

            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑÿ∞ÿ¶ÿßÿ®
            const wolvesToDamage = [];
            for (let i = wolves.length - 1; i >= 0; i--) {
                const wolf = wolves[i];
                wolf.getWorldPosition(_v2); const wolfPos = _v2;
                const distance = wolfPos.distanceTo(playerPos);

                if (distance < attackRadius) {
                    wolvesToDamage.push(wolf);
                }
            }

            for (const wolf of wolvesToDamage) {
                wolf.userData.health -= damage;

                if (wolf.userData.health <= 0) {
                    scene.remove(wolf);
                    const index = wolves.indexOf(wolf);
                    if (index > -1) {
                        wolves.splice(index, 1);
                    }
                    coins.push(
                        createCoin(wolf.position.x, wolf.position.z, wolf.userData.value)
                    );
                    score += wolf.userData.isAggressive ? 25 : 10;
                    playMonsterExplosionSound();
                    
                    if (wolf.userData.type === 'aggressive') {
                        if (Math.random() < 0.3) {
                            playerHealth = Math.min(maxPlayerHealth, playerHealth + 15);
                            showHealthGainEffect(wolf.position.x, wolf.position.y + 2, wolf.position.z, 15);
                        }
                    }
                }
            }

            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑŸÜÿ≠ŸÑ
            const beesKilled = checkBeeDamageFromStick();
            
            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠
            checkCrocodileDamageFromStick();
            
            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑŸÜÿ≥Ÿàÿ±
            const eaglesKilled = checkEagleDamageFromStick();
            
            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©
            const snatchingEaglesKilled = checkSnatchingEagleDamageFromStick();

            if (wolvesToDamage.length > 0 || beesKilled > 0 || eaglesKilled > 0 || snatchingEaglesKilled > 0) {
                effects.push({
                    particles: createStickSwingEffect(playerPos),
                    createdAt: currentTime,
                });
            }

            updateUI();
        }

        // ===== ÿ™ÿπÿØŸäŸÑ ÿØÿßŸÑÿ© explodeBomb ŸÑŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ© =====
        function explodeBomb() {
            if (!gameStarted || gameOver || isRoundTransition || bombs <= 0 || isGameFrozen) return;

            const explosionRadius = bombMaxRadius * bombCharge;
            const damage = 150 + (bombCharge * 100);

            bombs--;
            updateUI();

            player.getWorldPosition(_v1); const playerPos = _v1;

            playBombSound();

            effects.push({
                particles: createBombExplosionEffect(playerPos),
                createdAt: Date.now(),
            });

            showBombRangeIndicator(playerPos, explosionRadius);

            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑÿ∞ÿ¶ÿßÿ®
            const wolvesToDamage = [];
            for (let i = wolves.length - 1; i >= 0; i--) {
                const wolf = wolves[i];
                wolf.getWorldPosition(_v2); const wolfPos = _v2;
                const distance = wolfPos.distanceTo(playerPos);

                if (distance < explosionRadius) {
                    wolvesToDamage.push(wolf);
                }
            }

            for (const wolf of wolvesToDamage) {
                wolf.userData.health -= damage;

                if (wolf.userData.health <= 0) {
                    scene.remove(wolf);
                    const index = wolves.indexOf(wolf);
                    if (index > -1) {
                        wolves.splice(index, 1);
                    }
                    coins.push(
                        createCoin(wolf.position.x, wolf.position.z, wolf.userData.value)
                    );
                    score += wolf.userData.isAggressive ? 25 : 10;
                    playMonsterExplosionSound();
                    
                    if (wolf.userData.type === 'aggressive') {
                        if (Math.random() < 0.3) {
                            playerHealth = Math.min(maxPlayerHealth, playerHealth + 15);
                            showHealthGainEffect(wolf.position.x, wolf.position.y + 2, wolf.position.z, 15);
                        }
                    }
                }
            }

            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑŸÜÿ≠ŸÑ
            const beesToDamage = [];
            for (let i = bees.length - 1; i >= 0; i--) {
                const bee = bees[i];
                const beePos = new THREE.Vector3();
                bee.getWorldPosition(beePos);
                const distance = beePos.distanceTo(playerPos);

                if (distance < explosionRadius) {
                    beesToDamage.push(bee);
                }
            }

            for (const bee of beesToDamage) {
                bee.userData.health -= damage * 1.2;
                
                if (bee.userData.health <= 0) {
                    scene.remove(bee);
                    const index = bees.indexOf(bee);
                    if (index > -1) {
                        bees.splice(index, 1);
                    }
                    coins.push(createCoin(bee.position.x, bee.position.z, 15));
                    score += 15;
                    playMonsterExplosionSound();
                }
            }

            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠
            checkCrocodileDamageFromBomb(explosionRadius, damage);
            
            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑŸÜÿ≥Ÿàÿ±
            checkEagleDamageFromBomb(explosionRadius, damage);
            
            // ŸÖŸáÿßÿ¨ŸÖÿ© ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©
            checkSnatchingEagleDamageFromBomb(explosionRadius, damage);

            bombCharge = 0;
            isChargingBomb = false;
            bombChargeIndicator.style.display = "none";
            bombBtn.classList.remove("charging");

            updateUI();
        }

        // ===== ÿ≠ÿ±ŸÉÿ© ŸÜÿ≠ŸÑ ÿßŸÑÿÆŸÑÿßŸäÿß =====
        function moveHiveBees() {
            player.getWorldPosition(_v1); const playerPos = _v1;

            beeHives.forEach(hive => {
                const hiveBees = hive.userData.bees || [];
                
                if (!hive.userData.honeyCollected) {
                    hive.userData.particleTimer += 0.1;
                    hive.userData.particles.children.forEach(particle => {
                        const data = particle.userData;
                        data.angle += data.speed;
                        particle.position.y = data.height + Math.sin(hive.userData.particleTimer * data.floatSpeed) * 0.5;
                        particle.position.x = Math.cos(data.angle) * data.radius;
                        particle.position.z = Math.sin(data.angle) * data.radius;
                    });
                }
                
                const hivePos = new THREE.Vector3();
                hive.getWorldPosition(hivePos);
                const distanceToPlayer = hivePos.distanceTo(playerPos);
                
                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™ÿ≠ÿØŸäÿ´ ŸÜÿ≠ŸÑ ÿßŸÑÿÆŸÑÿßŸäÿß ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ŸÅŸÇÿ∑
                if (distanceToPlayer > 350 && !hive.userData.honeyCollected) return;

                if (distanceToPlayer < 60 || hive.userData.honeyCollected) {
                    hiveBees.forEach(bee => {
                        const beeData = bee.userData;
                        const beePos = new THREE.Vector3();
                        bee.getWorldPosition(beePos);
                        
                        const distanceToPlayerFromBee = beePos.distanceTo(playerPos);
                        const currentTime = Date.now();
                        
                        if (hive.userData.honeyCollected) {
                            beeData.isChasing = true;
                            const direction = new THREE.Vector3().subVectors(playerPos, beePos).normalize();
                            const newPosition = beePos.clone().add(direction.multiplyScalar(beeData.speed * 2.0));
                            
                            const hillCheck = isInsideHill(newPosition, false);
                            if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.8) {
                                newPosition.y = hillCheck.hillHeight + 5;
                            } else {
                                beeData.targetHeight = Math.max(
                                    beeData.minAttackHeight,
                                    Math.min(beeData.maxHeight, playerPos.y + 1)
                                );
                                newPosition.y = beeData.targetHeight + Math.sin(Date.now() * 0.015) * 0.3;
                            }
                            
                            bee.position.x = newPosition.x;
                            bee.position.y = newPosition.y;
                            bee.position.z = newPosition.z;
                            
                            bee.lookAt(
                                bee.position.x + direction.x,
                                bee.position.y + direction.y,
                                bee.position.z + direction.z
                            );
                            
                            if (distanceToPlayerFromBee < beeData.attackRange * 1.5) {
                                if (currentTime - beeData.lastAttackTime > beeData.attackCooldown * 0.7) {
                                    createBeeSting(beePos, playerPos);
                                    beeData.lastAttackTime = currentTime;
                                    playBeeAttackSound();
                                }
                            }
                        } else {
                            const canAttackWave = (beeData.attackWave === 0) || 
                                                 (beeData.attackWave === 1 && distanceToPlayer < 40) ||
                                                 (beeData.attackWave === 2 && distanceToPlayer < 25);
                            
                            const timeSinceDetection = currentTime - beeData.lastDetectedTime;
                            const shouldAttack = canAttackWave && timeSinceDetection > beeData.attackDelay;
                            
                            if (distanceToPlayerFromBee < 40 && shouldAttack) {
                                beeData.isChasing = true;
                                
                                if (beeData.lastDetectedTime === 0) {
                                    beeData.lastDetectedTime = currentTime;
                                }
                                
                                const direction = new THREE.Vector3().subVectors(playerPos, beePos).normalize();
                                const newPosition = beePos.clone().add(direction.multiplyScalar(beeData.speed * 1.8));
                                
                                const hillCheck = isInsideHill(newPosition, false);
                                if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.8) {
                                    newPosition.y = hillCheck.hillHeight + 5;
                                } else {
                                    beeData.targetHeight = Math.max(
                                        beeData.minAttackHeight,
                                        Math.min(beeData.maxHeight, playerPos.y + 2 + beeData.attackWave * 1.5)
                                    );
                                    newPosition.y = beeData.targetHeight + Math.sin(Date.now() * 0.012) * 0.4;
                                }
                                
                                bee.position.x = newPosition.x;
                                bee.position.y = newPosition.y;
                                bee.position.z = newPosition.z;
                                
                                bee.lookAt(
                                    bee.position.x + direction.x,
                                    bee.position.y + direction.y,
                                    bee.position.z + direction.z
                                );
                                
                                if (distanceToPlayerFromBee < beeData.attackRange) {
                                    if (currentTime - beeData.lastAttackTime > beeData.attackCooldown) {
                                        createBeeSting(beePos, playerPos);
                                        beeData.lastAttackTime = currentTime;
                                        playBeeAttackSound();
                                    }
                                }
                            } else {
                                beeData.isChasing = false;
                                
                                if (distanceToPlayerFromBee > 50) {
                                    beeData.lastDetectedTime = 0;
                                }
                                
                                beeData.orbitAngle += beeData.orbitSpeed * (0.8 + beeData.attackWave * 0.1);
                                
                                const orbitX = hivePos.x + Math.cos(beeData.orbitAngle) * beeData.orbitDistance;
                                const orbitZ = hivePos.z + Math.sin(beeData.orbitAngle) * beeData.orbitDistance;
                                
                                const orbitPos = new THREE.Vector3(orbitX, 0, orbitZ);
                                const hillCheck = isInsideHill(orbitPos, false);
                                if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.8) {
                                    bee.position.x = orbitX;
                                    bee.position.z = orbitZ;
                                    bee.position.y = hillCheck.hillHeight + 5;
                                } else {
                                    bee.position.x = orbitX;
                                    bee.position.z = orbitZ;
                                    bee.position.y = 3 + Math.sin(Date.now() * 0.003 + beeData.orbitAngle + beeData.attackWave) * 0.3;
                                }
                                
                                bee.lookAt(hivePos);
                            }
                        }
                        
                        const wingSpeedMultiplier = hive.userData.honeyCollected ? 1.5 : 1.0;
                        beeData.wingFlapAngle += beeData.wingFlapSpeed * 0.04 * wingSpeedMultiplier;
                        const wingFlap = Math.sin(beeData.wingFlapAngle) * 0.7;
                        
                        if (bee.userData.wings) {
                            bee.userData.wings.forEach(wing => wing.rotation.x = wingFlap);
                        } else {
                            bee.userData.wings = [];
                            bee.children.forEach((child) => {
                                if (child.position.x !== 0) {
                                    child.rotation.x = wingFlap;
                                    bee.userData.wings.push(child);
                                }
                            });
                        }
                    });
                } else {
                    hiveBees.forEach(bee => {
                        const beeData = bee.userData;
                        beeData.isChasing = false;
                        beeData.lastDetectedTime = 0;
                        
                        beeData.orbitAngle += beeData.orbitSpeed * 0.5;
                        
                        const orbitX = hivePos.x + Math.cos(beeData.orbitAngle) * beeData.orbitDistance;
                        const orbitZ = hivePos.z + Math.sin(beeData.orbitAngle) * beeData.orbitDistance;
                        
                        const orbitPos = new THREE.Vector3(orbitX, 0, orbitZ);
                        const hillCheck = isInsideHill(orbitPos, false);
                        if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.8) {
                            bee.position.x = orbitX;
                            bee.position.z = orbitZ;
                            bee.position.y = hillCheck.hillHeight + 5;
                        } else {
                            bee.position.x = orbitX;
                            bee.position.z = orbitZ;
                            bee.position.y = 3 + Math.sin(Date.now() * 0.001 + beeData.orbitAngle) * 0.2;
                        }
                        
                        bee.lookAt(hivePos);
                        
                        beeData.wingFlapAngle += beeData.wingFlapSpeed * 0.01;
                        const wingFlap = Math.sin(beeData.wingFlapAngle) * 0.3;
                        
                        if (bee.userData.wings) {
                            bee.userData.wings.forEach(wing => wing.rotation.x = wingFlap);
                        } else {
                            bee.userData.wings = [];
                            bee.children.forEach((child) => {
                                if (child.position.x !== 0) {
                                    child.rotation.x = wingFlap;
                                    bee.userData.wings.push(child);
                                }
                            });
                        }
                    });
                }
            });
        }

        // ===== ÿ®ÿßŸÇŸä ÿßŸÑÿØŸàÿßŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© =====
        function moveWolves(deltaTime) {
            player.getWorldPosition(_v1); const playerPos = _v1;

            wolves.forEach((wolf) => {
                const wolfData = wolf.userData;
                wolf.getWorldPosition(_v2); const wolfPos = _v2;
                
                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ∞ÿ¶ÿßÿ® ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ŸÅŸÇÿ∑
                const distToPlayer = wolfPos.distanceTo(playerPos);
                if (distToPlayer > 250 && !wolfData.isChasing) return;

                animateWolfLegs(wolf, deltaTime);

                const distanceToPlayer = wolfPos.distanceTo(playerPos);

                if (wolfData.type === "normal") {
                    const quarter = wolfData.quarter;
                    
                    if (isPlayerInQuarter(quarter)) {
                        wolfData.isChasing = true;

                        const direction = new THREE.Vector3().subVectors(playerPos, wolfPos).normalize();
                        const newPosition = wolfPos.clone().add(direction.multiplyScalar(wolfData.speed * 1.5));

                        newPosition.x = Math.max(quarter.minX, Math.min(quarter.maxX, newPosition.x));
                        newPosition.z = Math.max(quarter.minZ, Math.min(quarter.maxZ, newPosition.z));

                        const hillCheck = isInsideHill(newPosition, false);
                        if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.9) {
                            const reverseDirection = direction.clone().multiplyScalar(-1);
                            newPosition.add(reverseDirection.multiplyScalar(wolfData.speed * 2));
                        }

                        let collisionDetected = false;
                        _sphere.set(newPosition, 2 * wolf.scale.x); const wolfBoundingSphere = _sphere;

                        
                        for (const mountain of mountains) {
                            const mountainPos = mountain.position;
                            const distToMountain = Math.sqrt(Math.pow(newPosition.x - mountainPos.x, 2) + Math.pow(newPosition.z - mountainPos.z, 2));
                            if (distToMountain < 25) { 
                                if (!mountain.userData.boundingBox) {
                                    mountain.userData.boundingBox = new THREE.Box3().setFromObject(mountain);
                                }
                                if (mountain.userData.boundingBox.intersectsSphere(wolfBoundingSphere)) {
                                    collisionDetected = true;
                                    break;
                                }
                            }
                        }

                        if (!collisionDetected) {
                            wolf.position.x = newPosition.x;
                            wolf.position.z = newPosition.z;
                        }

                        wolf.lookAt(
                            wolf.position.x + direction.x,
                            wolf.position.y,
                            wolf.position.z + direction.z
                        );

                        if (distanceToPlayer < 3) {
                            const currentTime = Date.now();
                            if (currentTime - wolfData.lastCollisionTime > wolfData.collisionCooldown) {
                                playerHealth -= wolfData.collisionDamage;
                                wolfData.lastCollisionTime = currentTime;
                                showPlayerDamageEffect();
                                playBeeAttackSound(); // Changed to a more distinct sound as requested
                                updateUI();
                            }
                        }
                    } else {
                        wolfData.isChasing = false;
                        
                        wolfData.targetTimer += deltaTime * 1000;
                        
                        if (!wolfData.randomTarget || wolfPos.distanceTo(wolfData.randomTarget) < 2 || wolfData.targetTimer > 5000) {
                            wolfData.randomTarget = generateRandomTargetInQuarter(quarter);
                            wolfData.targetTimer = 0;
                        }
                        
                        const direction = new THREE.Vector3().subVectors(wolfData.randomTarget, wolfPos).normalize();
                        const newPosition = wolfPos.clone().add(direction.multiplyScalar(wolfData.speed * 0.5));

                        newPosition.x = Math.max(quarter.minX, Math.min(quarter.maxX, newPosition.x));
                        newPosition.z = Math.max(quarter.minZ, Math.min(quarter.maxZ, newPosition.z));

                        const hillCheck = isInsideHill(newPosition, false);
                        if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.9) {
                            wolfData.randomTarget = generateRandomTargetInQuarter(quarter);
                            wolfData.targetTimer = 0;
                        } else {
                            let collisionDetected = false;
                            _sphere.set(newPosition, 2 * wolf.scale.x); const wolfBoundingSphere = _sphere;

                            
                        for (const mountain of mountains) {
                            const mountainPos = mountain.position;
                            const distToMountain = Math.sqrt(Math.pow(newPosition.x - mountainPos.x, 2) + Math.pow(newPosition.z - mountainPos.z, 2));
                            if (distToMountain < 25) { 
                                if (!mountain.userData.boundingBox) {
                                    mountain.userData.boundingBox = new THREE.Box3().setFromObject(mountain);
                                }
                                if (mountain.userData.boundingBox.intersectsSphere(wolfBoundingSphere)) {
                                    collisionDetected = true;
                                    break;
                                }
                            }
                        }

                            if (!collisionDetected) {
                                wolf.position.x = newPosition.x;
                                wolf.position.z = newPosition.z;
                            }

                            wolf.lookAt(
                                wolf.position.x + direction.x,
                                wolf.position.y,
                                wolf.position.z + direction.z
                            );
                        }
                    }
                }
                else if (wolfData.isProtector && wolfData.protectedSheep) {
                    const sheepPos = new THREE.Vector3();
                    wolfData.protectedSheep.getWorldPosition(sheepPos);
                    
                    const distanceToSheep = playerPos.distanceTo(sheepPos);
                    
                    if (distanceToSheep < wolfData.guardRadius && distanceToPlayer < wolfData.detectionRange) {
                        wolfData.isChasing = true;

                        const direction = new THREE.Vector3().subVectors(playerPos, wolfPos).normalize();
                        const newPosition = wolfPos.clone().add(direction.multiplyScalar(wolfData.speed * 1.5));

                        const hillCheck = isInsideHill(newPosition, false);
                        if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.9) {
                            const angleOffset = Math.PI / 4;
                            const testDirection = new THREE.Vector3(
                                Math.sin(wolf.rotation.y + angleOffset),
                                0,
                                Math.cos(wolf.rotation.y + angleOffset)
                            );
                            const testPosition = wolfPos.clone().add(testDirection.multiplyScalar(wolfData.speed * 1.5));
                            
                            const hillCheck2 = isInsideHill(testPosition, false);
                            if (!hillCheck2 || hillCheck2.distanceToHillCenter >= hillCheck2.hill.userData.radius * 0.9) {
                                newPosition.copy(testPosition);
                            }
                        }

                        let collisionDetected = false;
                        _sphere.set(newPosition, 2 * wolf.scale.x); const wolfBoundingSphere = _sphere;

                        
                        for (const mountain of mountains) {
                            const mountainPos = mountain.position;
                            const distToMountain = Math.sqrt(Math.pow(newPosition.x - mountainPos.x, 2) + Math.pow(newPosition.z - mountainPos.z, 2));
                            if (distToMountain < 25) { 
                                if (!mountain.userData.boundingBox) {
                                    mountain.userData.boundingBox = new THREE.Box3().setFromObject(mountain);
                                }
                                if (mountain.userData.boundingBox.intersectsSphere(wolfBoundingSphere)) {
                                    collisionDetected = true;
                                    break;
                                }
                            }
                        }

                        if (!collisionDetected) {
                            wolf.position.x = newPosition.x;
                            wolf.position.z = newPosition.z;
                        }

                        wolf.lookAt(
                            wolf.position.x + direction.x,
                            wolf.position.y,
                            wolf.position.z + direction.z
                        );

                        if (distanceToPlayer < 3) {
                            const currentTime = Date.now();
                            if (currentTime - wolfData.lastCollisionTime > wolfData.collisionCooldown) {
                                playerHealth -= wolfData.collisionDamage;
                                wolfData.lastCollisionTime = currentTime;
                                showPlayerDamageEffect();
                                playBeeAttackSound(); // Changed to a more distinct sound as requested
                                updateUI();
                            }
                        }
                    } else {
                        wolfData.isChasing = false;
                        
                        const wolfToSheep = new THREE.Vector3().subVectors(wolfPos, sheepPos);
                        const distanceToSheepCenter = wolfToSheep.length();
                        
                        if (distanceToSheepCenter > wolfData.guardRadius / 2) {
                            const returnDirection = new THREE.Vector3().subVectors(sheepPos, wolfPos).normalize();
                            const returnPosition = sheepPos.clone().add(returnDirection.multiplyScalar(wolfData.guardRadius / 3));
                            
                            const hillCheck = isInsideHill(returnPosition, false);
                            if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.9) {
                                returnPosition.copy(wolfPos);
                            }
                            
                            let collisionDetected = false;
                            const wolfBoundingSphere = new THREE.Sphere(returnPosition, 2 * wolf.scale.x);

                            
                        for (const mountain of mountains) {
                            const mountainPos = mountain.position;
                            const distToMountain = Math.sqrt(Math.pow(newPosition.x - mountainPos.x, 2) + Math.pow(newPosition.z - mountainPos.z, 2));
                            if (distToMountain < 25) { 
                                if (!mountain.userData.boundingBox) {
                                    mountain.userData.boundingBox = new THREE.Box3().setFromObject(mountain);
                                }
                                if (mountain.userData.boundingBox.intersectsSphere(wolfBoundingSphere)) {
                                    collisionDetected = true;
                                    break;
                                }
                            }
                        }

                            if (!collisionDetected) {
                                wolf.position.x = returnPosition.x;
                                wolf.position.z = returnPosition.z;
                            }
                        }
                    }
                } else {
                    wolfData.isChasing = false;
                }
            });
        }

        function moveBees() {
            player.getWorldPosition(_v1); const playerPos = _v1;

            bees.forEach((bee) => {
                const beeData = bee.userData;
                const beePos = new THREE.Vector3();
                bee.getWorldPosition(beePos);

                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ≠ŸÑ ÿßŸÑŸÇÿ±Ÿäÿ® ŸÅŸÇÿ∑ ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ≥ŸÑÿßÿ≥ÿ©
                const distToPlayer = beePos.distanceTo(playerPos);
                if (distToPlayer > 150 && !beeData.isChasing) return;

                beeData.wingFlapAngle += beeData.wingFlapSpeed * 0.02;
                const wingFlap = Math.sin(beeData.wingFlapAngle) * 0.5;
                
                if (bee.userData.wings) {
                            bee.userData.wings.forEach(wing => wing.rotation.x = wingFlap);
                        } else {
                            bee.userData.wings = [];
                            bee.children.forEach((child) => {
                                if (child.position.x !== 0) {
                                    child.rotation.x = wingFlap;
                                    bee.userData.wings.push(child);
                                }
                            });
                        }

                const distanceToPlayer = beePos.distanceTo(playerPos);
                
                if (distanceToPlayer < beeData.detectionRange) {
                    beeData.isChasing = true;
                    beeData.lastDetectedTime = Date.now();
                }

                if (beeData.isChasing) {
                    if (Date.now() - beeData.lastDetectedTime > beeData.chaseDuration) {
                        beeData.isChasing = false;
                    } else {
                        if (distanceToPlayer < beeData.detectionRange * 2) {
                            beeData.lastDetectedTime = Date.now();
                        }
                    }
                }

                if (beeData.isChasing) {
                    const direction = new THREE.Vector3().subVectors(playerPos, beePos).normalize();
                    const newPosition = beePos.clone().add(direction.multiplyScalar(beeData.speed * 1.2));
                    
                    const hillCheck = isInsideHill(newPosition, false);
                    if (hillCheck && hillCheck.distanceToHillCenter < hillCheck.hill.userData.radius * 0.8) {
                        newPosition.y = hillCheck.hillHeight + 5;
                    } else {
                        if (distanceToPlayer < 15) {
                            beeData.targetHeight = Math.max(
                                beeData.minAttackHeight,
                                beeData.targetHeight - beeData.heightChangeSpeed * 2
                            );
                        } else {
                            beeData.targetHeight = Math.min(
                                beeData.maxHeight,
                                beeData.targetHeight + beeData.heightChangeSpeed
                            );
                        }
                        newPosition.y = beeData.targetHeight + Math.sin(Date.now() * 0.008) * 0.4;
                    }
                    
                    let collisionDetected = false;
                    const beeBoundingSphere = new THREE.Sphere(newPosition, 0.8);
                    
                    for (const mountain of mountains) {
                        mountain.children.forEach((child) => {
                            const childBox = new THREE.Box3().setFromObject(child);
                            if (childBox.intersectsSphere(beeBoundingSphere)) {
                                collisionDetected = true;
                            }
                        });
                        if (collisionDetected) break;
                    }
                    
                    if (!collisionDetected) {
                        bee.position.x = newPosition.x;
                        bee.position.y = newPosition.y;
                        bee.position.z = newPosition.z;
                    }
                    
                    bee.lookAt(
                        bee.position.x + direction.x,
                        bee.position.y + direction.y,
                        bee.position.z + direction.z
                    );
                    
                    const effectiveAttackRange = beeData.attackRange + (beeData.maxHeight - bee.position.y) * 0.3;
                    if (distanceToPlayer < effectiveAttackRange) {
                        const currentTime = Date.now();
                        if (currentTime - beeData.lastAttackTime > beeData.attackCooldown) {
                            createBeeSting(beePos, playerPos);
                            beeData.lastAttackTime = currentTime;
                            playBeeAttackSound();
                        }
                    }
                    
                    const effectiveCollisionRange = 1.8 + (beeData.maxHeight - bee.position.y) * 0.2;
                    if (distanceToPlayer < effectiveCollisionRange) {
                        const currentTime = Date.now();
                        if (currentTime - beeData.lastCollisionTime > beeData.collisionCooldown) {
                            playerHealth -= beeData.collisionDamage;
                            beeData.lastCollisionTime = currentTime;
                            showPlayerDamageEffect();
                            playBeeAttackSound();
                            updateUI();
                            showBeeDamageEffect(beePos.x, beePos.y + 2, beePos.z, beeData.collisionDamage);
                        }
                    }
                } else {
                    beeData.isChasing = false;
                    
                    bee.position.x += (Math.random() - 0.5) * 0.08;
                    bee.position.z += (Math.random() - 0.5) * 0.08;
                    bee.position.y = beeData.targetHeight + Math.sin(Date.now() * 0.005) * 0.5;
                }
            });
        }

        function moveBeeStings() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            
            for (let i = beeStings.length - 1; i >= 0; i--) {
                const sting = beeStings[i];
                const stingData = sting.userData;
                
                sting.position.add(stingData.direction.clone().multiplyScalar(stingData.speed));
                stingData.distanceTraveled += stingData.speed;
                
                if (stingData.distanceTraveled > stingData.maxDistance) {
                    scene.remove(sting);
                    beeStings.splice(i, 1);
                    continue;
                }
                
                const stingPos = new THREE.Vector3();
                sting.getWorldPosition(stingPos);
                const distanceToPlayer = stingPos.distanceTo(playerPos);
                
                if (distanceToPlayer < 1.5) {
                    playerHealth -= stingData.damage;
                    scene.remove(sting);
                    beeStings.splice(i, 1);
                    showPlayerDamageEffect();
                    playBeeAttackSound();
                    updateUI();
                }
            }
        }

        function showPlayerDamageEffect() {
            playerDamageEffect.classList.add("active");
            setTimeout(() => {
                playerDamageEffect.classList.remove("active");
            }, 500);
        }

        function updateWolfProjectiles() {
            player.getWorldPosition(_v1); const playerPos = _v1;

            for (let i = wolfProjectiles.length - 1; i >= 0; i--) {
                const projectile = wolfProjectiles[i];

                projectile.position.add(
                    projectile.userData.direction
                    .clone()
                    .multiplyScalar(projectile.userData.speed)
                );

                const distanceToOrigin = projectile.position.distanceTo(
                    new THREE.Vector3(0, 0, 0)
                );
                if (distanceToOrigin > 1000) {
                    scene.remove(projectile);
                    wolfProjectiles.splice(i, 1);
                    continue;
                }

                const distanceToPlayer = projectile.position.distanceTo(playerPos);
                if (distanceToPlayer < 2) {
                    playerHealth -= projectile.userData.damage;
                    updateUI();
                    scene.remove(projectile);
                    wolfProjectiles.splice(i, 1);
                    effects.push({
                        particles: createStickSwingEffect(playerPos),
                        createdAt: now,
                    });
                }
            }
        }

        function checkBeeDamageFromStick() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            
            const attackRadius = 8;
            const damage = 60;
            
            const beesToDamage = [];
            
            for (let i = bees.length - 1; i >= 0; i--) {
                const bee = bees[i];
                const beePos = new THREE.Vector3();
                bee.getWorldPosition(beePos);
                
                const horizontalDistance = Math.sqrt(
                    Math.pow(beePos.x - playerPos.x, 2) + 
                    Math.pow(beePos.z - playerPos.z, 2)
                );
                
                const verticalDistance = Math.abs(beePos.y - playerPos.y);
                const effectiveAttackRadius = attackRadius + 3;
                
                if (horizontalDistance < effectiveAttackRadius && verticalDistance < 10) {
                    beesToDamage.push(bee);
                }
            }
            
            beeHives.forEach(hive => {
                if (hive.userData.bees) {
                    hive.userData.bees.forEach(bee => {
                        const beePos = new THREE.Vector3();
                        bee.getWorldPosition(beePos);
                        
                        const horizontalDistance = Math.sqrt(
                            Math.pow(beePos.x - playerPos.x, 2) + 
                            Math.pow(beePos.z - playerPos.z, 2)
                        );
                        
                        const verticalDistance = Math.abs(beePos.y - playerPos.y);
                        const effectiveAttackRadius = attackRadius + 3;
                        
                        if (horizontalDistance < effectiveAttackRadius && verticalDistance < 10) {
                            beesToDamage.push(bee);
                        }
                    });
                }
            });
            
            for (const bee of beesToDamage) {
                bee.userData.health -= damage * 1.5;

                if (bee.userData.health <= 0) {
                    scene.remove(bee);
                    
                    const beeIndex = bees.indexOf(bee);
                    if (beeIndex > -1) {
                        bees.splice(beeIndex, 1);
                    }
                    
                    beeHives.forEach(hive => {
                        if (hive.userData.bees) {
                            const hiveBeeIndex = hive.userData.bees.indexOf(bee);
                            if (hiveBeeIndex > -1) {
                                hive.userData.bees.splice(hiveBeeIndex, 1);
                            }
                        }
                    });
                    
                    coins.push(createCoin(bee.position.x, bee.position.z, 15));
                    score += 15;
                    playMonsterExplosionSound();
                    
                    if (Math.random() < 0.3) {
                        playerHealth = Math.min(maxPlayerHealth, playerHealth + 10);
                        showHealthGainEffect(bee.position.x, bee.position.y + 2, bee.position.z, 10);
                    }
                    
                    showBeeDamageEffect(bee.position.x, bee.position.y + 2, bee.position.z, damage);
                }
            }
            
            if (beesToDamage.length > 0) {
                effects.push({
                    particles: createStickSwingEffect(playerPos),
                    createdAt: Date.now(),
                });
                updateUI();
            }
            
            return beesToDamage.length;
        }

        function startBombCharge() {
            if (!gameStarted || gameOver || isRoundTransition || bombs <= 0 || isGameFrozen) return;

            isChargingBomb = true;
            bombCharge = 0;
            bombChargeIndicator.style.display = "block";
            bombBtn.classList.add("charging");
        }

        function updateBombCharge() {
            if (!isChargingBomb || isGameFrozen) return;

            bombCharge = Math.min(1, bombCharge + bombChargeSpeed);
            bombChargeBar.style.width = `${bombCharge * 100}%`;

            player.getWorldPosition(_v1); const playerPos = _v1;
            const explosionRadius = bombMaxRadius * bombCharge;
            showBombRangeIndicator(playerPos, explosionRadius);

            if (bombCharge >= 1) {
                explodeBomb();
            }
        }

        function showBombRangeIndicator(position, radius) {
            if (bombRangeIndicator) {
                scene.remove(bombRangeIndicator);
            }

            const geometry = new THREE.RingGeometry(radius - 0.5, radius + 0.5, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff5722,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            bombRangeIndicator = new THREE.Mesh(geometry, material);
            bombRangeIndicator.rotation.x = -Math.PI / 2;
            bombRangeIndicator.position.set(position.x, 0.1, position.z);
            scene.add(bombRangeIndicator);

            setTimeout(() => {
                if (bombRangeIndicator) {
                    scene.remove(bombRangeIndicator);
                    bombRangeIndicator = null;
                }
            }, 2000);
        }

        function updateEffects() {
            const now = Date.now();
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                if (now - effect.createdAt > 500) {
                    effect.particles.forEach((particle) => {
                        scene.remove(particle);
                    });
                    effects.splice(i, 1);
                } else {
                    effect.particles.forEach((particle) => {
                        particle.position.add(particle.userData.velocity);
                        particle.material.opacity = 0.8 * (1 - (now - effect.createdAt) / 500);
                    });
                }
            }
        }

        function rotateCoins() {
            coins.forEach((coin) => {
                coin.rotation.y += coin.userData.spinSpeed;

                coin.children.forEach((child) => {
                    if (child.userData && child.userData.angle !== undefined) {
                        child.userData.angle += coin.userData.sparkleSpeed;
                        child.position.set(
                            Math.cos(child.userData.angle) * 0.7,
                            0.1,
                            Math.sin(child.userData.angle) * 0.7
                        );
                        child.material.opacity = 0.5 + 0.5 * Math.sin(child.userData.angle * 2);
                    }
                });
            });
        }

        function updateBombBoxes() {
            const now = Date.now();
            bombBoxes.forEach((box) => {
                if (box.userData && box.userData.spark) {
                    box.userData.sparkTimer += 100;
                    if (box.userData.sparkTimer >= 500) {
                        box.userData.spark.visible = !box.userData.spark.visible;
                        box.userData.sparkTimer = 0;
                    }
                }
            });
        }

        function updateThirdPersonCamera() {
            player.getWorldPosition(_v1); const playerPos = _v1;

            const cameraOffset = new THREE.Vector3(
                Math.sin(cameraAngle) * cameraDistance,
                cameraHeight,
                Math.cos(cameraAngle) * cameraDistance
            );

            camera.position.copy(playerPos).add(cameraOffset);

            camera.lookAt(playerPos);
        }

        function collectCoins() {
            player.getWorldPosition(_v1); const playerPos = _v1;

            for (let i = coins.length - 1; i >= 0; i--) {
                const coinPos = new THREE.Vector3();
                coins[i].getWorldPosition(coinPos);
                const distance = playerPos.distanceTo(coinPos);

                if (distance < 3) {
                    coinsCollected += coins[i].userData.value;
                    showCoinAnimation(
                        coinPos.x,
                        coinPos.y + 2,
                        coinPos.z,
                        coins[i].userData.value
                    );
                    scene.remove(coins[i]);
                    coins.splice(i, 1);
                    updateUI();
                    playCoinSound();
                }
            }
        }

        function collectSheep() {
            player.getWorldPosition(_v1); const playerPos = _v1;

            for (let i = sheeps.length - 1; i >= 0; i--) {
                const sheepPos = new THREE.Vector3();
                sheeps[i].getWorldPosition(sheepPos);
                const distance = playerPos.distanceTo(sheepPos);

                if (distance < 5) {
                    sheepCollected++;
                    
                    showSheepAnimation(
                        sheepPos.x,
                        sheepPos.y + 2,
                        sheepPos.z
                    );
                    scene.remove(sheeps[i]);
                    sheeps.splice(i, 1);
                    updateUI();
                    playSheepSound();

                    if (sheepCollected >= 5) {
                        showSuccessMessage();
                        updateUI();
                    }
                }
            }
        }

        function collectBombBoxes() {
            player.getWorldPosition(_v1); const playerPos = _v1;

            for (let i = bombBoxes.length - 1; i >= 0; i--) {
                const boxPos = new THREE.Vector3();
                bombBoxes[i].getWorldPosition(boxPos);
                const distance = playerPos.distanceTo(boxPos);

                if (distance < 3) {
                    bombs += 1;
                    showBombAnimation(boxPos.x, boxPos.y + 2, boxPos.z);
                    scene.remove(bombBoxes[i]);
                    bombBoxes.splice(i, 1);
                    updateUI();
                    playGiftSound();
                }
            }
        }

        function collectHoney(hive) {
            if (hive.userData.honeyCollected) return;
            
            hive.userData.honeyCollected = true;
            const honeyValue = hive.userData.honeyValue;
            
            score += honeyValue;
            coinsCollected += Math.floor(honeyValue / 2);
            
            showHoneyCollectionMessage(hive.position.x, hive.position.y + 5, hive.position.z, honeyValue);
            
            hive.children.forEach(child => {
                if (child.isPointLight) {
                    child.intensity = 0;
                }
            });
            
            scene.remove(hive.userData.particles);
            
            playHoneyCollectSound();
            
            updateUI();
            
            console.log(`ÿ™ŸÖ ÿ¨ŸÖÿπ ${honeyValue} ÿπÿ≥ŸÑ ŸÖŸÜ ÿßŸÑÿÆŸÑŸäÿ©!`);
        }

        function checkHoneyCollection() {
            player.getWorldPosition(_v1); const playerPos = _v1;
            
            beeHives.forEach(hive => {
                if (hive.userData.honeyCollected) return;
                
                const hivePos = new THREE.Vector3();
                hive.getWorldPosition(hivePos);
                const distance = playerPos.distanceTo(hivePos);
                
                if (distance < 5) {
                    collectHoney(hive);
                }
            });
        }

        function showCoinAnimation(x, y, z, value) {
            const coinDiv = document.createElement("div");
            coinDiv.className = "coin-animation";
            coinDiv.textContent = `+${value}`;

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            coinDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            coinDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(coinDiv);

            setTimeout(() => {
                coinDiv.remove();
            }, 1500);
        }

        function showSheepAnimation(x, y, z) {
            const sheepDiv = document.createElement("div");
            sheepDiv.className = "coin-animation";
            sheepDiv.textContent = `+1 ÿÆÿ±ŸàŸÅ`;
            sheepDiv.style.color = "#ffffff";

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            sheepDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            sheepDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(sheepDiv);

            setTimeout(() => {
                sheepDiv.remove();
            }, 1500);
        }

        function showBombAnimation(x, y, z) {
            const bombDiv = document.createElement("div");
            bombDiv.className = "coin-animation";
            bombDiv.textContent = `+1 ÿ¥ÿπŸÑÿ© ŸÜÿßÿ±`;
            bombDiv.style.color = "#ff5722";

            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);

            bombDiv.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            bombDiv.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.querySelector(".scene-container").appendChild(bombDiv);

            setTimeout(() => {
                bombDiv.remove();
            }, 1500);
        }

        function buyHealth() {
            if (coinsCollected >= 100 && playerHealth < maxPlayerHealth && !isGameFrozen) {
                coinsCollected -= 100;
                playerHealth = Math.min(maxPlayerHealth, playerHealth + 30);
                
                showHealthPurchaseMessage(true, "ÿ™ŸÖ ÿ¥ÿ±ÿßÿ° 30 ÿµÿ≠ÿ© ÿ®ŸÜÿ¨ÿßÿ≠!");
                
                updateUI();
                playGiftSound();
            } else {
                if (coinsCollected < 100) {
                    showHealthPurchaseMessage(false, "ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿπŸÖŸÑÿßÿ™ ŸÉÿßŸÅŸäÿ©! ÿ™ÿ≠ÿ™ÿßÿ¨ 100 ÿπŸÖŸÑÿßÿ™");
                } else if (playerHealth >= maxPlayerHealth) {
                    showHealthPurchaseMessage(false, "ÿµÿ≠ÿ™ŸÉ ŸÖŸÖÿ™ŸÑÿ¶ÿ© ÿ®ÿßŸÑŸÅÿπŸÑ!");
                }
            }
        }

        function showHealthPurchaseMessage(success, message) {
            const messageDiv = document.createElement("div");
            messageDiv.className = "health-purchase-message";
            if (!success) {
                messageDiv.classList.add("error");
            }
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                messageDiv.remove();
            }, 2000);
        }

        function increaseDifficulty() {
            if (score >= level * 100) {
                level++;
                updateUI();
            }
        }

        function checkGameState() {
            if (playerHealth <= 0) {
                gameOverPanel.querySelector("h2").textContent = "ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!";
                gameOverPanel.querySelector("p").textContent = "ÿµÿ≠ÿ™ŸÉ ŸàÿµŸÑÿ™ ŸÑŸÑÿµŸÅÿ±!";
                endGame();
                return;
            }
        }

        function winGame() {
            gameOverPanel.querySelector("h2").textContent = "ÿ™ŸáÿßŸÜŸäŸÜÿß! ŸÑŸÇÿØ ŸÅÿ≤ÿ™!";
            gameOverPanel.querySelector("p").textContent = "ŸÑŸÇÿØ ÿ¨ŸÖÿπÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿÆÿ±ÿßŸÅ ÿßŸÑÿ∂ÿßÿ¶ÿπÿ©!";
            endGame();
        }

        function endGame() {
            gameStarted = false;
            gameOver = true;
            finalScore.textContent = score;
            finalCoins.textContent = coinsCollected;
            gameOverPanel.style.display = "block";
            document.getElementById("scoreSubmissionArea").style.display = "block";
            document.getElementById("submitScoreBtn").disabled = false;
            document.getElementById("submitScoreBtn").textContent = "ÿ≠ŸÅÿ∏ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© üèÜ";
            loadLeaderboard();
        }

        function restartGame() {
            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ±
            eagles.forEach((eagle) => scene.remove(eagle));
            eagles.length = 0;
            
            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©
            snatchingEagles.forEach((eagle) => scene.remove(eagle));
            snatchingEagles.length = 0;

            wolves.forEach((wolf) => scene.remove(wolf));
            wolves.length = 0;

            wolfProjectiles.forEach((p) => scene.remove(p));
            wolfProjectiles.length = 0;

            effects.forEach((effect) => {
                effect.particles.forEach((particle) => {
                    scene.remove(particle);
                });
            });
            effects.length = 0;

            coins.forEach((coin) => scene.remove(coin));
            coins.length = 0;

            sheeps.forEach((sheep) => scene.remove(sheep));
            sheeps.length = 0;

            treasureBoxes.forEach((box) => scene.remove(box));
            treasureBoxes.length = 0;

            bombBoxes.forEach((box) => scene.remove(box));
            bombBoxes.length = 0;

            platforms.forEach((platform) => scene.remove(platform));
            platforms.length = 0;

            mountains.forEach((mountain) => scene.remove(mountain));
            mountains.length = 0;

            bees.forEach((bee) => scene.remove(bee));
            bees.length = 0;

            beeStings.forEach((sting) => scene.remove(sting));
            beeStings.length = 0;

            crocodiles.forEach((croc) => scene.remove(croc));
            crocodiles.length = 0;

            beeHives.forEach((hive) => scene.remove(hive));
            beeHives.length = 0;

            hills.forEach((hill) => scene.remove(hill));
            hills.length = 0;

            score = 0;
            coinsCollected = 0;
            sheepCollected = 0;
            bombs = 0;
            level = 1;
            round = 1;
            gameOver = false;
            playerSpeed = 0.5; // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ©
            playerHealth = 100;
            isJumping = false;
            isOnGround = true;
            isOnAnySurface = false;
            isGameFrozen = false;

          player.position.set(-250, 25, -250); // ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ŸàŸÖÿÆÿ™ÿ®ÿ± ÿ®ÿπŸäÿØ ÿ¨ÿØÿßŸã ÿπŸÜ ÿßŸÑŸÜŸáÿ±
            player.rotation.set(0, 0, 0);
            camera.position.set(-240, 30, -240);
            camera.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0); // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ©
            isJumping = false;
            jumpVelocity = 0;
            isOnGround = true;

            updateUI();
            gameOverPanel.style.display = "none";
            gameStarted = true;
            emergencyFixBtn.style.display = 'none';

            createTerrain();
            createNature();
            createOasis();
            spawnPlatforms();
            spawnNewSheeps();
            spawnWavesForRound();
            addCrocodilesToOasis();
            createClimbingHill(-50, -50, 15);
        }

        function checkTreasureBoxCollision() {
            // ŸÖŸÜÿπ ŸÅÿ™ÿ≠ ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿµŸÜÿØŸàŸÇ ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑŸàŸÇÿ™
            if (isGameFrozen) return;
            
            player.getWorldPosition(_v1); const playerPos = _v1;

            for (let i = treasureBoxes.length - 1; i >= 0; i--) {
                const box = treasureBoxes[i];
                const boxPos = new THREE.Vector3();
                box.getWorldPosition(boxPos);
                const distance = playerPos.distanceTo(boxPos);

                if (distance < 3 && box.userData.isHealthBox) {
                    // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÑÿπÿ®ÿ© ŸÑŸäÿ≥ÿ™ ŸÖÿ¨ŸÖÿØÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã
                    if (!isGameFrozen) {
                        freezeGame();
                        showMathQuestion(box);
                        playBoxSound();
                    }
                    return; // ÿßŸÑÿÆÿ±Ÿàÿ¨ ÿ®ÿπÿØ ŸÅÿ™ÿ≠ ÿ£ŸàŸÑ ÿµŸÜÿØŸàŸÇ
                }
            }
        }

        function showMathQuestion(box) {
            const questionData = generateMathQuestion();
            currentQuestionUnit = questionData.unit;
            currentSubTopic = questionData.subTopic;
            questionText.innerHTML = questionData.question;

            if (questionData.sequence) {
                displaySequence(questionData.sequence);
                sequenceContainer.style.display = 'block';
            } else {
                sequenceContainer.style.display = 'none';
            }
            
            // ÿπÿ±ÿ∂ ÿßŸÑÿ±ÿ≥ŸàŸÖÿßÿ™ ÿßŸÑŸáŸÜÿØÿ≥Ÿäÿ© ÿ•ŸÜ Ÿàÿ¨ÿØÿ™
            const svgContainer = document.getElementById('svgContainer');
            if (svgContainer) {
                if (questionData.svg) {
                    svgContainer.innerHTML = questionData.svg;
                    svgContainer.style.display = 'flex';
                } else {
                    svgContainer.style.display = 'none';
                    svgContainer.innerHTML = '';
                }
            }

            optionsContainer.innerHTML = "";
            
            // ÿ•ŸÜÿ¥ÿßÿ° ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸÖÿπ ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ŸÖÿßŸÜ
            questionData.options.forEach((option) => {
                const button = document.createElement("button");
                button.className = "option-btn";
                button.innerHTML = option;
                
                // ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿπÿ±ŸÅ ŸÅÿ±ŸäÿØ ŸÑŸÉŸÑ ÿ≤ÿ±
                button.dataset.answer = option;
                
                // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ event listener ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©
                const clickHandler = () => {
                    if (!button.disabled) {
                        button.disabled = true;
                        handleAnswer(option, questionData.answer, box);
                    }
                };
                
                button.addEventListener("click", clickHandler, { once: true });
                optionsContainer.appendChild(button);
            });

            questionPanel.style.display = "block";
            const mBtn = document.getElementById('mathHelpBtn');
            if (mBtn) mBtn.style.display = 'flex'; // ÿ•ÿ∏Ÿáÿßÿ± ÿ≤ÿ± ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿπŸÜÿØ ÿ∏ŸáŸàÿ± ÿßŸÑÿ≥ÿ§ÿßŸÑ
            
            // ÿ•ÿÆÿ®ÿßÿ± MathJax ÿ®ÿ£ŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ™ÿ∫Ÿäÿ± ŸÑŸäŸÇŸàŸÖ ÿ®ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©
            if (typeof MathJax !== 'undefined' && MathJax.typeset) {
                MathJax.typesetPromise();
            }
            
            // ÿ•ÿ∂ÿßŸÅÿ© ÿ≤ÿ± ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ∑Ÿàÿßÿ±ÿ¶
            if (!document.getElementById('emergencyCloseBtn')) {
                const emergencyBtn = document.createElement("button");
                emergencyBtn.id = 'emergencyCloseBtn';
                emergencyBtn.className = 'option-btn';
                emergencyBtn.textContent = 'ÿ•ÿ∫ŸÑÿßŸÇ (ÿ∑Ÿàÿßÿ±ÿ¶)';
                emergencyBtn.style.background = 'linear-gradient(to right, #f44336, #d32f2f)';
                emergencyBtn.style.marginTop = '20px';
                
                emergencyBtn.addEventListener('click', () => {
                    console.log("Emergency close activated");
                    questionPanel.style.display = "none";
                    movementControls.style.pointerEvents = 'auto';
                    attackBtn.style.pointerEvents = 'auto';
                    jumpBtn.style.pointerEvents = 'auto';
                    bombBtn.style.pointerEvents = 'auto';
                    
                    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿµŸÜÿØŸàŸÇ ŸÑÿ™ÿ¨ŸÜÿ® ÿßŸÑÿ™ŸÉÿ±ÿßÿ±
                    // Removed Three.js disposal logic to fix immediate freeze bug.
                    // This was likel// ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿµŸÜÿØŸàŸÇ ŸÑÿ™ÿ¨ŸÜÿ® ÿßŸÑÿ™ŸÉÿ±ÿßÿ±
                    scene.remove(box);
                    const boxIndex = treasureBoxes.indexOf(box);
                    if (boxIndex > -1) {
                        treasureBoxes.splice(boxIndex, 1);
                    }
                    
                    // Dispose of Three.js resources to prevent memory leak (Delayed for safety)
                    setTimeout(() => {
                        if (box.children.length > 0) {
                            box.children.forEach(child => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(material => material.dispose());
                                    } else {
                                        child.material.dispose();
                                    }
                                }
                            });
                        }
                    }, 1000); // 1 second delay
                    
                    unfreezeGame();
                });
                
                optionsContainer.appendChild(emergencyBtn);
            }
        }

        function handleAnswer(selectedOption, correctAnswer, box) {
            const mBtn = document.getElementById('mathHelpBtn');
            if (mBtn) mBtn.style.display = 'none'; // ÿ•ÿÆŸÅÿßÿ° ÿ≤ÿ± ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿπŸÜÿØ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©
            // ŸÖŸÜÿπ ÿßŸÑŸÜŸÇÿ± ÿßŸÑŸÖÿ™ÿπÿØÿØ ŸÅŸàÿ±ÿßŸã
            const buttons = document.querySelectorAll('.option-btn');
            buttons.forEach(btn => btn.disabled = true);
            
            const isCorrect = selectedOption === correctAnswer;
            let prizeMessage = isCorrect ? "ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©!" : "ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ©!";
            let isWin = isCorrect;

            if (isCorrect) {
                try {
                    score += 20; // ÿ•ÿ∂ÿßŸÅÿ© 20 ŸÜŸÇÿ∑ÿ© ŸÑŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©
                    const rewardType = Math.floor(Math.random() * 3);
                    switch (rewardType) {
                        case 0:
                            playerHealth = Math.min(maxPlayerHealth, playerHealth + 20);
                            prizeMessage = "ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ÿßŸÑÿ¨ÿßÿ¶ÿ≤ÿ©: ÿµÿ≠ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©!";
                            break;
                        case 1:
                            bombs += 2;
                            prizeMessage = "ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ÿßŸÑÿ¨ÿßÿ¶ÿ≤ÿ©: ŸÇŸÜÿßÿ®ŸÑ ÿ•ÿ∂ÿßŸÅŸäÿ©!";
                            break;
                        case 2:
                            // ŸÖŸÜÿπ ÿ™ŸàŸÑŸäÿØ ÿÆÿ±ÿßŸÅ ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸäŸäŸÜ 3 Ÿà 4 ŸÑÿ∂ŸÖÿßŸÜ ÿ®ŸÇÿßÿ° ÿßŸÑÿπÿØÿØ 5 ŸÅŸÇÿ∑
                            if (round === 3 || round === 4) {
                                playerHealth = Math.min(maxPlayerHealth, playerHealth + 30);
                                prizeMessage = "ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ÿßŸÑÿ¨ÿßÿ¶ÿ≤ÿ©: ÿµÿ≠ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©!";
                            } else {
                                const sheepX = Math.random() * 400 - 200;
                                const sheepZ = Math.random() * 400 - 200;
                                const newSheep = createSheep(sheepX, 2, sheepZ);
                                if (newSheep) {
                                    sheeps.push(newSheep);
                                    totalSheeps++;
                                }
                                prizeMessage = "ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ÿßŸÑÿ¨ÿßÿ¶ÿ≤ÿ©: ÿ¥ÿßÿ© ÿ¨ÿØŸäÿØÿ© ŸÑŸÑŸÇÿ∑Ÿäÿπ!";
                            }
                            break;
                    }
                    playGiftSound();
                } catch (e) {
                    console.error("Error giving reward:", e);
                }
            }

            showAnswerMessage(isWin, prizeMessage);
            
            // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿµŸÜÿØŸàŸÇ ŸÅŸàÿ±ÿßŸã ŸÖŸÜ ÿßŸÑŸÖÿµŸÅŸàŸÅÿ© ŸàÿßŸÑŸÖÿ¥ŸáÿØ ŸÑŸÖŸÜÿπ ÿ£Ÿä ÿ™ÿØÿßÿÆŸÑ
            const boxIndex = treasureBoxes.indexOf(box);
            if (boxIndex > -1) treasureBoxes.splice(boxIndex, 1);
            scene.remove(box);

            // ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÑŸàÿ≠ÿ© Ÿàÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ÿ¨ŸÖŸäÿØ ÿ®ÿ≥ÿ±ÿπÿ©
            setTimeout(() => {
                unfreezeGame();
                updateUI();
            }, 800);
        }

        function showAnswerMessage(isCorrect, message) {
            const messageDiv = document.createElement("div");
            messageDiv.className = "answer-message";
            if (!isCorrect) {
                messageDiv.classList.add("incorrect");
            }
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                messageDiv.remove();
            }, 1500);
        }

        function animate(time) {
            gameLoopId = requestAnimationFrame(animate);

            if (isGameFrozen) {
                // Continue rendering but skip game logic
                
                
                // ŸÖŸÜÿ∑ŸÇ ÿßŸÑÿ∫ÿ±ŸÇ ÿßŸÑÿ™ÿØÿ±Ÿäÿ¨Ÿä ÿßŸÑŸÖÿ∂ŸÖŸàŸÜ - Manus Ultimate Fix
                if (typeof gameStarted !== 'undefined' && gameStarted && !gameOver) {
                    const p = player.position;
                                    // ÿ™ÿ≠ÿØŸäÿØ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜŸáÿ± ŸàŸÜÿµŸÅ ÿßŸÑŸÇÿ∑ÿ±
                const hillCenterX = -50;
                const hillCenterZ = -50;
                const riverInnerRadius = 40; // ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                const riverOuterRadius = 180; // ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (180 ŸÇÿ∑ÿ±)
                const distanceToCenter = Math.sqrt((p.x - hillCenterX) ** 2 + (p.z - hillCenterZ) ** 2);
                const overRiver = (distanceToCenter >= riverInnerRadius && distanceToCenter <= riverOuterRadius);
                    if (overRiver) {
                        let onRock = false;
                        if (window.riverRocks) {
                            for (let r of window.riverRocks) {
                                const rockData = r.userData;
                                const horizontalDistance = Math.sqrt(
                                    (p.x - r.position.x) ** 2 +
                                    (p.z - r.position.z) ** 2
                                );
                                // Check if player is horizontally on the rock and vertically above or on it
                                if (horizontalDistance < rockData.radius * 0.5 && p.y >= rockData.topY - 0.5) {
                                    onRock = true;
                                    break;
                                }
                            }
                        }
                        if (!onRock) {
                            // ÿ∫ÿ±ŸÇ ÿ™ÿØÿ±Ÿäÿ¨Ÿä ÿ®ÿ∑Ÿäÿ° ÿ¨ÿØÿßŸã ŸàŸàÿßŸÇÿπŸä
                            if (p.y > -10) { // ÿπŸÖŸÇ ÿ£ŸÉÿ®ÿ± ŸÑŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿ±ÿ§Ÿäÿ© ÿßŸÑÿ∫ÿ±ŸÇ
                                p.y -= 0.02; // ÿ≥ÿ±ÿπÿ© ÿ∫ÿ±ŸÇ ŸáÿßÿØÿ¶ÿ©
                                if (p.y < 0) {
                                    if (typeof playerHealth !== 'undefined') {
                                        playerHealth -= 0.05; // ÿÆÿ≥ÿßÿ±ÿ© ÿµÿ≠ÿ© ÿ®ÿ≥Ÿäÿ∑ÿ© ÿ¨ÿØÿßŸã ŸàŸÖÿ≥ÿ™ŸÖÿ±ÿ©
                                        if (typeof updateUI === 'function') updateUI();
                                    }
                                }
                            }
                            
                            // ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿπŸäŸäŸÜ ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß ŸÖÿßÿ™ ÿßŸÑŸÑÿßÿπÿ® ÿ£Ÿà ŸàÿµŸÑ ŸÑÿπŸÖŸÇ ÿ≥ÿ≠ŸäŸÇ ÿ¨ÿØÿßŸã
                            if (p.y < -8) {
                                p.set(200, 1.2, 200); // ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ÿ®ÿπŸäÿØ ÿπŸÜ ÿßŸÑŸÜŸáÿ± (ÿßŸÑŸÜŸáÿ± ÿ≠ŸàŸÑ -50, -50)
                                if (typeof playerHealth !== 'undefined') {
                                    playerHealth -= 10;
                                    if (typeof updateUI === 'function') updateUI();
                                }
                            }
                        }
                    }
                }

                
                

                if(window.updateCharging) window.updateCharging();
                if(window.updateChargeBar) window.updateChargeBar();
                if(window.updateQuadraticJump) window.updateQuadraticJump();
                renderer.render(scene, camera);
                return;
            }

            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            if (gameStarted && !gameOver && !isRoundTransition) {
                movePlayer();
                
                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™Ÿàÿ≤Ÿäÿπ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ´ŸÇŸäŸÑÿ© ÿπŸÑŸâ ÿßŸÑÿ•ÿ∑ÿßÿ±ÿßÿ™
                const frameCount = Math.floor(time / 16) % 4;
                
                moveWolves(deltaTime);
                
                // ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ≥ŸÑÿßÿ≥ÿ©: ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÉÿßÿ¶ŸÜÿßÿ™ ÿßŸÑÿ∑ÿßÿ¶ÿ±ÿ© ŸÅŸä ŸÉŸÑ ÿ•ÿ∑ÿßÿ±
                moveBees();
                moveEagles();
                moveSnatchingEagles();
                moveHiveBees();
                
                if (frameCount === 0) {
                    moveCrocodiles();
                } else if (frameCount === 1) {
                    moveBeeStings();
                    updateWolfProjectiles();
                } else if (frameCount === 2) {
                    rotateCoins();
                    collectCoins();
                    collectSheep();
                } else {
                    collectBombBoxes();
                    checkHoneyCollection();
                    checkTreasureBoxCollision();
                    updateEffects();
                    updateBombBoxes();
                }

                if (isChargingBomb) {
                    updateBombCharge();
                }

                // ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ°: ÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠ ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ŸÅŸÇÿ∑
                player.getWorldPosition(_v1);
                crocodiles.forEach((croc) => {
                    if (croc.position.distanceTo(_v1) < 100) {
                        animateCrocodileJaw(croc, deltaTime);
                        animateCrocodileLegs(croc, deltaTime);
                    }
                });

                if (frameCount === 0) {
                    increaseDifficulty();
                    checkGameState();
                    updateUI();
                }

                updateThirdPersonCamera();

                if ((joystickActive && (joystickDirection.x !== 0 || joystickDirection.y !== 0)) || 
                    (keys.w || keys.a || keys.s || keys.d || keys.arrowup || keys.arrowleft || keys.arrowdown || keys.arrowright)) {
                    animateWalking(playerModel, deltaTime);
                    animateLegs(playerModel, deltaTime);
                } else {
                    playerModel.userData.walkCycle = 0;
                }

                animateStickAttack(playerModel, deltaTime);
            }

            
                
                // ŸÖŸÜÿ∑ŸÇ ÿßŸÑÿ∫ÿ±ŸÇ ÿßŸÑÿ™ÿØÿ±Ÿäÿ¨Ÿä ÿßŸÑŸÖÿ∂ŸÖŸàŸÜ - Manus Ultimate Fix
                if (typeof gameStarted !== 'undefined' && gameStarted && !gameOver) {
                    const p = player.position;
                                    // ÿ™ÿ≠ÿØŸäÿØ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜŸáÿ± ŸàŸÜÿµŸÅ ÿßŸÑŸÇÿ∑ÿ±
                const hillCenterX = -50;
                const hillCenterZ = -50;
                const riverInnerRadius = 40; // ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                const riverOuterRadius = 180; // ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (180 ŸÇÿ∑ÿ±)
                const distanceToCenter = Math.sqrt((p.x - hillCenterX) ** 2 + (p.z - hillCenterZ) ** 2);
                const overRiver = (distanceToCenter >= riverInnerRadius && distanceToCenter <= riverOuterRadius);
                    if (overRiver) {
                        let onRock = false;
                        if (window.riverRocks) {
                            for (let r of window.riverRocks) {
                                const rockData = r.userData;
                                const horizontalDistance = Math.sqrt(
                                    (p.x - r.position.x) ** 2 +
                                    (p.z - r.position.z) ** 2
                                );
                                // Check if player is horizontally on the rock and vertically above or on it
                                if (horizontalDistance < rockData.radius * 0.5 && p.y >= rockData.topY - 0.5) {
                                    onRock = true;
                                    break;
                                }
                            }
                        }
                        if (!onRock) {
                            // ÿ∫ÿ±ŸÇ ÿ™ÿØÿ±Ÿäÿ¨Ÿä ÿ®ÿ∑Ÿäÿ° ÿ¨ÿØÿßŸã ŸàŸàÿßŸÇÿπŸä
                            if (p.y > -10) { // ÿπŸÖŸÇ ÿ£ŸÉÿ®ÿ± ŸÑŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿ±ÿ§Ÿäÿ© ÿßŸÑÿ∫ÿ±ŸÇ
                                p.y -= 0.02; // ÿ≥ÿ±ÿπÿ© ÿ∫ÿ±ŸÇ ŸáÿßÿØÿ¶ÿ©
                                if (p.y < 0) {
                                    if (typeof playerHealth !== 'undefined') {
                                        playerHealth -= 0.05; // ÿÆÿ≥ÿßÿ±ÿ© ÿµÿ≠ÿ© ÿ®ÿ≥Ÿäÿ∑ÿ© ÿ¨ÿØÿßŸã ŸàŸÖÿ≥ÿ™ŸÖÿ±ÿ©
                                        if (typeof updateUI === 'function') updateUI();
                                    }
                                }
                            }
                            
                            // ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿπŸäŸäŸÜ ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß ŸÖÿßÿ™ ÿßŸÑŸÑÿßÿπÿ® ÿ£Ÿà ŸàÿµŸÑ ŸÑÿπŸÖŸÇ ÿ≥ÿ≠ŸäŸÇ ÿ¨ÿØÿßŸã
                            if (p.y < -8) {
                                p.set(200, 1.2, 200); // ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ÿ®ÿπŸäÿØ ÿπŸÜ ÿßŸÑŸÜŸáÿ± (ÿßŸÑŸÜŸáÿ± ÿ≠ŸàŸÑ -50, -50)
                                if (typeof playerHealth !== 'undefined') {
                                    playerHealth -= 10;
                                    if (typeof updateUI === 'function') updateUI();
                                }
                            }
                        }
                    }
                }

                
                

                if(window.updateCharging) window.updateCharging();
                if(window.updateChargeBar) window.updateChargeBar();
                if(window.updateQuadraticJump) window.updateQuadraticJump();
                renderer.render(scene, camera);
        }

        function setupJoystickControls() {
            const joystickContainer = document.querySelector('.joystick-container');
            
            joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
            window.addEventListener('touchmove', handleJoystickMove, { passive: false });
            window.addEventListener('touchend', handleJoystickEnd, { passive: false });

            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            window.addEventListener('mousemove', handleJoystickMove);
            window.addEventListener('mouseup', handleJoystickEnd);
            
            joystickContainer.addEventListener('touchstart', (e) => e.preventDefault());
            joystickContainer.addEventListener('touchmove', (e) => e.preventDefault());
        }

        function handleJoystickStart(e) {
            if (!gameStarted || gameOver || isRoundTransition || isGameFrozen) return;

            e.preventDefault();
            joystickActive = true;
            joystickHandle.classList.add('active');

            const rect = joystickBase.getBoundingClientRect();
            joystickCenterX = rect.left + rect.width / 2;
            joystickCenterY = rect.top + rect.height / 2;

            joystickDirection.x = 0;
            joystickDirection.y = 0;

            if (e.type === 'touchstart') {
                joystickTouchId = e.changedTouches[0].identifier;
                updateJoystickPosition(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            } else {
                updateJoystickPosition(e.clientX, e.clientY);
            }
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;

            e.preventDefault();

            let clientX, clientY;

            if (e.type === 'touchmove') {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                if (!touch) return;
                clientX = touch.clientX;
                clientY = touch.clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            updateJoystickPosition(clientX, clientY);
        }
function restartGame() {
            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ±
            eagles.forEach((eagle) => scene.remove(eagle));
            eagles.length = 0;
            
            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©
            snatchingEagles.forEach((eagle) => scene.remove(eagle));
            snatchingEagles.length = 0;

            wolves.forEach((wolf) => scene.remove(wolf));
            wolves.length = 0;

            wolfProjectiles.forEach((p) => scene.remove(p));
            wolfProjectiles.length = 0;

            effects.forEach((effect) => {
                effect.particles.forEach((particle) => {
                    scene.remove(particle);
                });
            });
            effects.length = 0;

            coins.forEach((coin) => scene.remove(coin));
            coins.length = 0;

            sheeps.forEach((sheep) => scene.remove(sheep));
            sheeps.length = 0;

            treasureBoxes.forEach((box) => scene.remove(box));
            treasureBoxes.length = 0;

            bombBoxes.forEach((box) => scene.remove(box));
            bombBoxes.length = 0;

            platforms.forEach((platform) => scene.remove(platform));
            platforms.length = 0;

            mountains.forEach((mountain) => scene.remove(mountain));
            mountains.length = 0;

            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≠ŸÑÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©
            bees.forEach((bee) => scene.remove(bee));
            bees.length = 0;

            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≠ŸÑ ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿßŸÑÿÆŸÑÿßŸäÿß
            beeHives.forEach(hive => {
                if (hive.userData.bees) {
                    hive.userData.bees.forEach(bee => scene.remove(bee));
                    hive.userData.bees.length = 0;
                }
            });

            beeStings.forEach((sting) => scene.remove(sting));
            beeStings.length = 0;

            crocodiles.forEach((croc) => scene.remove(croc));
            crocodiles.length = 0;

            beeHives.forEach((hive) => scene.remove(hive));
            beeHives.length = 0;

            hills.forEach((hill) => scene.remove(hill));
            hills.length = 0;

            score = 0;
            coinsCollected = 0;
            sheepCollected = 0;
            bombs = 0;
            level = 1;
            round = 1;
            gameOver = false;
            playerSpeed = 0.5; // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ©
            playerHealth = 100;
            isJumping = false;
            isOnGround = true;
            isOnAnySurface = false;
            isGameFrozen = false;

          player.position.set(-250, 25, -250); // ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ŸàŸÖÿÆÿ™ÿ®ÿ± ÿ®ÿπŸäÿØ ÿ¨ÿØÿßŸã ÿπŸÜ ÿßŸÑŸÜŸáÿ±
            player.rotation.set(0, 0, 0);
            camera.position.set(-240, 30, -240);
            camera.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0); // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ©
            isJumping = false;
            jumpVelocity = 0;
            isOnGround = true;

            updateUI();
            gameOverPanel.style.display = "none";
            gameStarted = true;
            emergencyFixBtn.style.display = 'none';

            createTerrain();
            createNature();
            createOasis();
            spawnPlatforms();
            spawnNewSheeps();
            spawnWavesForRound();
            addCrocodilesToOasis();
            createClimbingHill(-50, -50, 15);
        }

        function nextRound() {
            isRoundTransition = true;
            nextRoundBtn.disabled = true;
            nextRoundBtn.style.display = "none";

            // ÿ•ÿ∂ÿßŸÅÿ© ŸÜŸÇÿßÿ∑ ŸÖŸÉÿßŸÅÿ£ÿ© ŸÑÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©
            score += 500; 
            
            round++;
            playerHealth = maxPlayerHealth;
            sheepCollected = 0;

            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ±
            eagles.forEach((eagle) => scene.remove(eagle));
            eagles.length = 0;
            
            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©
            snatchingEagles.forEach((eagle) => scene.remove(eagle));
            snatchingEagles.length = 0;

            wolves.forEach((wolf) => scene.remove(wolf));
            wolves.length = 0;

            coins.forEach((coin) => scene.remove(coin));
            coins.length = 0;

            wolfProjectiles.forEach((p) => scene.remove(p));
            wolfProjectiles.length = 0;

            effects.forEach((effect) => {
                effect.particles.forEach((particle) => scene.remove(particle));
            });
            effects.length = 0;

            sheeps.forEach((sheep) => scene.remove(sheep));
            sheeps.length = 0;

            treasureBoxes.forEach((box) => scene.remove(box));
            treasureBoxes.length = 0;

            bombBoxes.forEach((box) => scene.remove(box));
            bombBoxes.length = 0;

            platforms.forEach((platform) => scene.remove(platform));
            platforms.length = 0;

            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≠ŸÑÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©
            bees.forEach((bee) => scene.remove(bee));
            bees.length = 0;

            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿ≠ŸÑ ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿßŸÑÿÆŸÑÿßŸäÿß
            beeHives.forEach(hive => {
                if (hive.userData.bees) {
                    hive.userData.bees.forEach(bee => scene.remove(bee));
                    hive.userData.bees.length = 0;
                }
            });

            beeStings.forEach((sting) => scene.remove(sting));
            beeStings.length = 0;

            crocodiles.forEach((croc) => scene.remove(croc));
            crocodiles.length = 0;

            beeHives.forEach((hive) => scene.remove(hive));
            beeHives.length = 0;

            hills.forEach((hill) => scene.remove(hill));
            hills.length = 0;

            spawnPlatforms();
            spawnNewSheeps();
            spawnWavesForRound();
            addCrocodilesToOasis();

            // ÿ•ÿπÿßÿØÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ™ŸÑÿ© ŸÖÿπ ÿßŸÑŸÜÿ≥Ÿàÿ±
            createClimbingHill(-50, -50, 15);

            let message = `ÿßŸÑÿ¨ŸàŸÑÿ© ${round}`;
            if (beeHives.length > 0) {
                message += ` - ŸáŸÜÿßŸÉ ${beeHives.length} ÿÆŸÑŸäÿ© ÿπÿ≥ŸÑ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖ`;
            }
            if (snatchingEagles.length > 0) {
                message += ` - ÿßÿ≠ÿ∞ÿ± ÿßŸÑŸÜÿ≥Ÿàÿ± ÿßŸÑÿÆÿßÿ∑ŸÅÿ©!`;
            }
            roundMessage.textContent = message;

            roundTransition.classList.add("active");

            setTimeout(() => {
                roundTransition.classList.remove("active");
                isRoundTransition = false;
                updateUI();
            }, 2000);
        }

        function updateJoystickPosition(clientX, clientY) {
            const deltaX = clientX - joystickCenterX;
            const deltaY = clientY - joystickCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            const deadZone = joystickRadius * 0.05;

            if (distance <= deadZone) {
                joystickDirection.x = 0;
                joystickDirection.y = 0;
                joystickHandle.style.transform = 'translate(-50%, -50%)';
                return;
            }

            if (distance <= joystickRadius) {
                const effectiveDistance = Math.min(distance, joystickRadius);
                const normalizedDistance = (effectiveDistance - deadZone) / (joystickRadius - deadZone);
                
                joystickDirection.x = (deltaX / distance) * normalizedDistance;
                joystickDirection.y = (deltaY / distance) * normalizedDistance;

                joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            } else {
                const angle = Math.atan2(deltaY, deltaX);
                joystickDirection.x = Math.cos(angle);
                joystickDirection.y = Math.sin(angle);

                const limitedX = Math.cos(angle) * joystickRadius;
                const limitedY = Math.sin(angle) * joystickRadius;
                
                joystickHandle.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
            }
        }

        function handleJoystickEnd(e) {
            if (!joystickActive) return;

            e.preventDefault();

            if (e.type === 'touchend') {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                if (!touch) return;
            }

            joystickActive = false;
            joystickTouchId = null;
            joystickDirection.x = 0;
            joystickDirection.y = 0;
            joystickHandle.classList.remove('active');
            joystickHandle.style.transform = 'translate(-50%, -50%)';
        }

        function getTouchTarget(touch) {
            return document.elementFromPoint(touch.clientX, touch.clientY);
        }

        function isAttackButton(element) {
            return element.id === "attackBtn";
        }

        function isJumpButton(element) {
            return element.id === "jumpBtn";
        }

        function isBombButton(element) {
            return element.id === "bombBtn";
        }

        function isBuyHealthButton(element) {
            return element.id === "buyHealthBtn";
        }

        function setupMultiTouchControls() {
            window.addEventListener(
                "touchstart",
                (e) => {
                    if (!gameStarted || gameOver || isRoundTransition) return;

                    for (const touch of e.changedTouches) {
                        const targetElement = getTouchTarget(touch);

                        if (isAttackButton(targetElement)) {
                            buttonTouchIds.set(touch.identifier, targetElement);
                            stickAttack();
                        } else if (isJumpButton(targetElement)) {
                            buttonTouchIds.set(touch.identifier, targetElement);
                            jump();
                        } else if (isBombButton(targetElement)) {
                            buttonTouchIds.set(touch.identifier, targetElement);
                            startBombCharge();
                        } else if (isBuyHealthButton(targetElement)) {
                            buttonTouchIds.set(touch.identifier, targetElement);
                            buyHealth();
                        } else if (!cameraTouchId) {
                            cameraTouchId = touch.identifier;
                            previousTouchX = touch.clientX;
                            previousTouchY = touch.clientY;
                        }
                    }
                }, {
                    passive: true
                }
            );

            window.addEventListener(
                "touchmove",
                (e) => {
                    if (!gameStarted || gameOver || isRoundTransition) return;

                    for (const touch of e.changedTouches) {
                        if (touch.identifier === cameraTouchId) {
                            const deltaX = touch.clientX - previousTouchX;
                            const deltaY = touch.clientY - previousTouchY;

                            cameraAngle -= deltaX * touchSensitivity;
                            cameraHeight = Math.max(
                                1,
                                Math.min(10, cameraHeight + deltaY * 0.01)
                            );

                            previousTouchX = touch.clientX;
                            previousTouchY = touch.clientY;
                        }
                    }
                }, {
                    passive: true
                }
            );

            window.addEventListener("touchend", (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;

                for (const touch of e.changedTouches) {
                    if (touch.identifier === cameraTouchId) {
                        cameraTouchId = null;
                    } else if (buttonTouchIds.has(touch.identifier)) {
                        const targetElement = buttonTouchIds.get(touch.identifier);
                        if (isBombButton(targetElement) && isChargingBomb) {
                            explodeBomb();
                        }
                        buttonTouchIds.delete(touch.identifier);
                    }
                }
            });
        }

        function setupMouseControls() {
            window.addEventListener("mousedown", (e) => {
                if (!gameStarted || e.target !== canvas || gameOver || isRoundTransition) return;
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
                document.body.classList.add("dragging");
            });

            window.addEventListener("mouseup", () => {
                isDragging = false;
                document.body.classList.remove("dragging");
            });

            window.addEventListener("mousemove", (e) => {
                if (!gameStarted || !isDragging || gameOver || isRoundTransition) return;
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;

                cameraAngle -= deltaX * mouseSensitivity;
                cameraHeight = Math.max(1, Math.min(10, cameraHeight + deltaY * 0.01));

                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });
        }

        function setupKeyboardControls() {
            document.addEventListener("keydown", (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;

                const key = e.key.toLowerCase();
                
                if (keys.hasOwnProperty(key)) {
                    keys[key] = true;
                }

                switch (key) {
                    case " ":
                        jump();
                        break;
                    case "f":
                        stickAttack();
                        break;
                    case "b":
                        if (e.repeat) return;
                        startBombCharge();
                        break;
                    case "h":
                        buyHealth();
                        break;
                }
            });

            document.addEventListener("keyup", (e) => {
                if (!gameStarted || gameOver || isRoundTransition) return;

                const key = e.key.toLowerCase();
                
                if (keys.hasOwnProperty(key)) {
                    keys[key] = false;
                }

                switch (key) {
                    case "b":
                        if (isChargingBomb) {
                            explodeBomb();
                        }
                        break;
                }
            });
        }

        bombBtn.addEventListener("mousedown", startBombCharge);
        bombBtn.addEventListener("mouseup", explodeBomb);
        bombBtn.addEventListener("mouseleave", () => {
            if (isChargingBomb) {
                explodeBomb();
            }
        });

        attackBtn.addEventListener("mousedown", stickAttack);
        jumpBtn.addEventListener("mousedown", jump);
        buyHealthBtn.addEventListener("mousedown", buyHealth);

        restartBtn.addEventListener("click", restartGame);
        nextRoundBtn.addEventListener("click", nextRound);
        emergencyFixBtn.addEventListener("click", safeUnfreezeGame);

        // ŸÖŸÜÿ∑ŸÇ ÿ≤ÿ± ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿ© - ŸÖŸÜŸáÿßÿ¨ ÿßŸÑÿµŸÅ ÿßŸÑÿ≥ÿßÿ®ÿπ ÿßŸÑÿ£ÿ±ÿØŸÜŸä (Manus Smart Help)
        const mathHelpBtn = document.getElementById('mathHelpBtn');
        const mathModal = document.getElementById('mathModal');
        const mathOverlay = document.getElementById('mathOverlay');
        const closeMathModal = document.getElementById('closeMathModal');
        const mathModalContent = document.getElementById('mathModalContent');

        // ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿßŸÑÿ™ÿπŸÑŸäŸÖŸäÿ© ÿßŸÑŸÖÿÆÿµÿµÿ© ŸÑŸÉŸÑ ŸÖŸàÿ∂Ÿàÿπ ŸÅÿ±ÿπŸä - ŸÖŸÜŸáÿßÿ¨ ÿßŸÑÿµŸÅ ÿßŸÑÿ≥ÿßÿ®ÿπ ÿßŸÑÿ£ÿ±ÿØŸÜŸä
        const mathHelpDatabase = {
            "ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©": `
                <div class="math-content-item">
                    <h3>ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ© ŸÑŸÑÿπÿØÿØ ÿßŸÑŸÜÿ≥ÿ®Ÿä</h3>
                    <p>ŸáŸä ÿßŸÑŸÖÿ≥ÿßŸÅÿ© ÿ®ŸäŸÜ ÿ∞ŸÑŸÉ ÿßŸÑÿπÿØÿØ ŸàÿßŸÑÿµŸÅÿ± ÿπŸÑŸâ ÿÆÿ∑ ÿßŸÑÿ£ÿπÿØÿßÿØÿå ŸàŸäŸèÿ±ŸÖÿ≤ ŸÑŸáÿß ÿ®ÿßŸÑÿ±ŸÖÿ≤ $| |$.</p>
                    <p><b>ŸÇÿßÿπÿØÿ© ÿ∞Ÿáÿ®Ÿäÿ©:</b> ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ© ÿØÿßÿ¶ŸÖÿßŸã ŸÖŸàÿ¨ÿ®ÿ© ÿ£Ÿà ÿµŸÅÿ±ÿßŸã. ŸáŸä "ÿ™ÿ£ŸÉŸÑ" ÿßŸÑÿ•ÿ¥ÿßÿ±ÿ© ÿßŸÑÿ≥ÿßŸÑÿ®ÿ©!</p>
                    <p><b>ÿ£ŸÖÿ´ŸÑÿ©:</b> $|-5| = 5$ ÿå $|12| = 12$ ÿå $|0| = 0$.</p>
                </div>`,
            "ÿßŸÑŸÉÿ≥Ÿàÿ± ÿßŸÑÿπÿ¥ÿ±Ÿäÿ©": `
                <div class="math-content-item">
                    <h3>ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÉÿ≥ÿ± ÿßŸÑÿπÿßÿØŸä ÿ•ŸÑŸâ ŸÉÿ≥ÿ± ÿπÿ¥ÿ±Ÿä</h3>
                    <p><b>ÿßŸÑŸÉÿ≥ÿ± ÿßŸÑŸÖŸÜÿ™ŸáŸä:</b> ÿ™ŸÜÿ™ŸáŸä ÿ£ÿ±ŸÇÿßŸÖŸá ÿßŸÑÿπÿ¥ÿ±Ÿäÿ© (ŸÖÿ´ŸÑ $\\frac{1}{2} = 0.5$). Ÿäÿ≠ÿØÿ´ Ÿáÿ∞ÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿπŸàÿßŸÖŸÑ ÿßŸÑŸÖŸÇÿßŸÖ ŸáŸä 2 ÿ£Ÿà 5 ŸÅŸÇÿ∑.</p>
                    <p><b>ÿßŸÑŸÉÿ≥ÿ± ÿßŸÑÿØŸàÿ±Ÿä:</b> ÿ™ÿ™ŸÉÿ±ÿ± ÿ£ÿ±ŸÇÿßŸÖŸá ÿ®ÿ¥ŸÉŸÑ ŸÑÿß ŸÜŸáÿßÿ¶Ÿä (ŸÖÿ´ŸÑ $\\frac{1}{3} = 0.333...$). ŸÜÿ∂ÿπ ÿÆÿ∑ÿßŸã ŸÅŸàŸÇ ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑŸÖÿ™ŸÉÿ±ÿ±: $0.\\bar{3}$.</p>
                </div>`,
            "ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÇŸàŸâ": `
                <div class="math-content-item">
                    <h3>ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÇŸàÿ© (ÿßŸÑÿ£ÿ≥ÿ≥)</h3>
                    <p>ÿßŸÑŸÇŸàÿ© ŸáŸä ÿ™ŸÉÿ±ÿßÿ± ÿ∂ÿ±ÿ® ÿßŸÑÿ£ÿ≥ÿßÿ≥ ŸÅŸä ŸÜŸÅÿ≥Ÿá ÿ®ÿπÿØÿØ ŸÖÿ±ÿßÿ™ ÿßŸÑÿ£ÿ≥.</p>
                    <p><b>ŸÖÿ´ÿßŸÑ:</b> $3^4$ ÿ™ÿπŸÜŸä $3 \\times 3 \\times 3 \\times 3 = 81$.</p>
                    <p><b>ÿ™ŸÜÿ®ŸäŸá:</b> $3^4$ ŸÑÿß ÿ™ÿ≥ÿßŸàŸä $3 \\times 4$!</p>
                </div>`,
            "ÿßŸÑÿ¨ÿ∞Ÿàÿ± ÿßŸÑÿ™ÿ±ÿ®ŸäÿπŸäÿ©": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ¨ÿ∞ÿ± ÿßŸÑÿ™ÿ±ÿ®ŸäÿπŸä</h3>
                    <p>ŸáŸà ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿπÿØÿØ ÿßŸÑÿ∞Ÿä ÿ•ÿ∞ÿß ÿ∂ÿ±ÿ®ÿ™Ÿá ŸÅŸä ŸÜŸÅÿ≥Ÿá Ÿäÿπÿ∑ŸäŸÉ ŸÖÿß ÿ™ÿ≠ÿ™ ÿßŸÑÿ¨ÿ∞ÿ±.</p>
                    <p><b>ÿ£ŸÖÿ´ŸÑÿ© ÿ¥ŸáŸäÿ±ÿ©:</b> $\\sqrt{25}=5$ ÿå $\\sqrt{64}=8$ ÿå $\\sqrt{100}=10$.</p>
                </div>`,
            "ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ£ÿ≥ÿ≥": `
                <div class="math-content-item">
                    <h3>ŸÇÿßŸÜŸàŸÜ ÿ∂ÿ±ÿ® ÿßŸÑŸÇŸàŸâ</h3>
                    <p>ÿπŸÜÿØ ÿ∂ÿ±ÿ® ŸÇŸàÿ™ŸäŸÜ ŸÑŸáŸÖÿß <b>ŸÜŸÅÿ≥ ÿßŸÑÿ£ÿ≥ÿßÿ≥</b>ÿå ŸÜŸÇŸàŸÖ ÿ®ÿ¨ŸÖÿπ ÿßŸÑÿ£ÿ≥ÿ≥: $a^m \\times a^n = a^{m+n}$.</p>
                    <p><b>ŸÖÿ´ÿßŸÑ:</b> $5^2 \\times 5^4 = 5^{2+4} = 5^6$.</p>
                </div>`,
            "ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿπŸÉÿ≥Ÿä": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿπŸÉÿ≥Ÿä</h3>
                    <p>ŸÅŸä ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿπŸÉÿ≥Ÿäÿå ÿ≠ÿßÿµŸÑ ÿ∂ÿ±ÿ® $x$ ŸÅŸä $y$ ÿØÿßÿ¶ŸÖÿßŸã ÿ´ÿßÿ®ÿ™ ŸàŸäÿ≥ÿßŸàŸä $k$.</p>
                    <p><b>ÿßŸÑŸÇÿßÿπÿØÿ©:</b> $x \\times y = k$. ŸÑÿ•Ÿäÿ¨ÿßÿØ $y$ÿå ŸÜŸÇÿ≥ŸÖ ÿßŸÑÿ´ÿßÿ®ÿ™ ÿπŸÑŸâ $x$: $y = k/x$.</p>
                </div>`,
            "ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿ∑ÿ±ÿØŸä": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿ∑ÿ±ÿØŸä</h3>
                    <p>ŸÅŸä ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿ∑ÿ±ÿØŸäÿå ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿ®ŸäŸÜ $y$ Ÿà $x$ ÿ´ÿßÿ®ÿ™ÿ© Ÿàÿ™ÿ≥ÿßŸàŸä $k$.</p>
                    <p><b>ÿßŸÑŸÖÿπÿßÿØŸÑÿ©:</b> $y = k \\times x$. ŸÑÿ•Ÿäÿ¨ÿßÿØ $y$ÿå ŸÜÿ∂ÿ±ÿ® ÿßŸÑÿ´ÿßÿ®ÿ™ ŸÅŸä ŸÇŸäŸÖÿ© $x$.</p>
                </div>`,
            "ÿ∂ÿ±Ÿäÿ®ÿ© ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™": `
                <div class="math-content-item">
                    <h3>ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ≥ÿπÿ± ÿ®ÿπÿØ ÿßŸÑÿ∂ÿ±Ÿäÿ®ÿ©</h3>
                    <p>1. ÿßÿ≠ÿ≥ÿ® ŸÇŸäŸÖÿ© ÿßŸÑÿ∂ÿ±Ÿäÿ®ÿ©: (ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ£ÿµŸÑŸä $\\times$ ÿßŸÑŸÜÿ≥ÿ®ÿ©) $\\div$ 100.</p>
                    <p>2. ÿßŸÑÿ≥ÿπÿ± ÿßŸÑŸÜŸáÿßÿ¶Ÿä = ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ£ÿµŸÑŸä + ŸÇŸäŸÖÿ© ÿßŸÑÿ∂ÿ±Ÿäÿ®ÿ©.</p>
                    <p><b>ŸÖÿ´ÿßŸÑ:</b> ÿ≥ŸÑÿπÿ© ÿ®ŸÄ 100 ÿØŸäŸÜÿßÿ± Ÿàÿ∂ÿ±Ÿäÿ®ÿ™Ÿáÿß 16%ÿå ÿßŸÑÿ∂ÿ±Ÿäÿ®ÿ© ŸáŸä 16 ÿØŸäŸÜÿßÿ±ÿå ÿßŸÑÿ≥ÿπÿ± ÿßŸÑŸÜŸáÿßÿ¶Ÿä 116 ÿØŸäŸÜÿßÿ±.</p>
                </div>`,
            "ÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ∂ŸÑÿπ": `
                <div class="math-content-item">
                    <h3>ŸÖÿ¨ŸÖŸàÿπ ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑÿØÿßÿÆŸÑŸäÿ©</h3>
                    <p>ŸÑÿ•Ÿäÿ¨ÿßÿØ ŸÖÿ¨ŸÖŸàÿπ ÿ≤ŸàÿßŸäÿß ÿ£Ÿä ŸÖÿ∂ŸÑÿπÿå ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÇÿßŸÜŸàŸÜ: $S = (n - 2) \\times 180^\\circ$.</p>
                    <p>ÿ≠Ÿäÿ´ $n$ ŸáŸà ÿπÿØÿØ ÿßŸÑÿ£ÿ∂ŸÑÿßÿπ. (ÿßŸÑŸÖÿ´ŸÑÿ´: 180ÿå ÿßŸÑÿ±ÿ®ÿßÿπŸä: 360ÿå ÿßŸÑÿÆŸÖÿßÿ≥Ÿä: 540).</p>
                </div>`,
            "ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ÿ™ÿßŸÖÿ© ŸàÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©": `
                <div class="math-content-item">
                    <h3>ÿßŸÑŸÖÿ™ÿ™ÿßŸÖÿ© ŸàÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©</h3>
                    <p><b>ÿßŸÑÿ≤ÿßŸàŸäÿ™ÿßŸÜ ÿßŸÑŸÖÿ™ÿ™ÿßŸÖÿ™ÿßŸÜ:</b> ŸÖÿ¨ŸÖŸàÿπ ŸÇŸäÿßÿ≥ŸáŸÖÿß $90^\\circ$ (ÿ≤ÿßŸàŸäÿ© ŸÇÿßÿ¶ŸÖÿ©).</p>
                    <p><b>ÿßŸÑÿ≤ÿßŸàŸäÿ™ÿßŸÜ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ™ÿßŸÜ:</b> ŸÖÿ¨ŸÖŸàÿπ ŸÇŸäÿßÿ≥ŸáŸÖÿß $180^\\circ$ (ÿÆÿ∑ ŸÖÿ≥ÿ™ŸÇŸäŸÖ).</p>
                </div>`,
            "ÿ≤ŸàÿßŸäÿß ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸÇŸäŸÖ": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ≤ŸàÿßŸäÿß ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸÇŸäŸÖ Ÿàÿßÿ≠ÿØ</h3>
                    <p>ŸÖÿ¨ŸÖŸàÿπ ŸÇŸäÿßÿ≥ÿßÿ™ ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑÿ™Ÿä ÿ™ŸÇÿπ ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸÇŸäŸÖ Ÿàÿßÿ≠ÿØ ŸàŸÖŸÜ ÿ¨Ÿáÿ© Ÿàÿßÿ≠ÿØÿ© ŸáŸà ÿØÿßÿ¶ŸÖÿßŸã $180^\\circ$.</p>
                    <p><b>ÿßŸÑÿ≠ŸÑ:</b> $x = 180 - $ ÿßŸÑÿ≤ÿßŸàŸäÿ© ÿßŸÑŸÖÿπŸÑŸàŸÖÿ©.</p>
                </div>`,
            "ÿßŸÑÿ™ŸÇÿßÿ®ŸÑ ÿ®ÿßŸÑÿ±ÿ£ÿ≥": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ŸÇÿßÿ®ŸÑÿ© ÿ®ÿßŸÑÿ±ÿ£ÿ≥</h3>
                    <p>ÿ™ŸÜÿ™ÿ¨ ŸÖŸÜ ÿ™ŸÇÿßÿ∑ÿπ ŸÖÿ≥ÿ™ŸÇŸäŸÖŸäŸÜ. ŸÉŸÑ ÿ≤ÿßŸàŸäÿ™ŸäŸÜ ŸÖÿ™ŸÇÿßÿ®ŸÑÿ™ŸäŸÜ ÿ®ÿßŸÑÿ±ÿ£ÿ≥ <b>ŸÖÿ™ÿ≥ÿßŸàŸäÿ™ÿßŸÜ ÿ™ŸÖÿßŸÖÿßŸã</b> ŸÅŸä ÿßŸÑŸÇŸäÿßÿ≥.</p>
                </div>`,
            "ÿßŸÑÿ™ÿ®ÿßÿØŸÑ ÿßŸÑÿØÿßÿÆŸÑŸä": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ™ÿ®ÿßÿØŸÑ ÿßŸÑÿØÿßÿÆŸÑŸä (ÿ≠ÿ±ŸÅ Z)</h3>
                    <p>ÿπŸÜÿØŸÖÿß ŸäŸÇÿ∑ÿπ ŸÖÿ≥ÿ™ŸÇŸäŸÖ ŸÖÿ≥ÿ™ŸÇŸäŸÖŸäŸÜ ŸÖÿ™Ÿàÿßÿ≤ŸäŸäŸÜÿå ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ÿ®ÿßÿØŸÑÿ© ÿØÿßÿÆŸÑŸäÿßŸã ÿ™ŸÉŸàŸÜ <b>ŸÖÿ™ÿ≥ÿßŸàŸäÿ©</b>.</p>
                    <p>ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿ¥ŸÉŸÑ Ÿäÿ¥ÿ®Ÿá ÿ≠ÿ±ŸÅ Z ŸÑÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ≤ŸàÿßŸäÿß ÿßŸÑŸÖÿ™ÿ®ÿßÿØŸÑÿ©.</p>
                </div>`,
            "ÿßŸÑŸáŸÜÿØÿ≥ÿ©": `
                <div class="math-content-item">
                    <h3>ŸÖŸÅÿßŸáŸäŸÖ ŸáŸÜÿØÿ≥Ÿäÿ© ÿπÿßŸÖÿ©</h3>
                    <p>ÿ™ÿ∞ŸÉÿ± ÿØÿßÿ¶ŸÖÿßŸã ÿßŸÑŸÇŸàÿßÿπÿØ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ŸÑŸÑÿ≤ŸàÿßŸäÿß ŸàÿßŸÑŸÖÿ∂ŸÑÿπÿßÿ™ ŸÑÿ≠ŸÑ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ§ÿßŸÑ.</p>
                </div>`,
            "ÿßŸÑÿ£ÿπÿØÿßÿØ ÿßŸÑŸÜÿ≥ÿ®Ÿäÿ©": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ£ÿπÿØÿßÿØ ÿßŸÑŸÜÿ≥ÿ®Ÿäÿ©</h3>
                    <p>ÿ™ÿ∞ŸÉÿ± ŸÇŸàÿßÿπÿØ ÿßŸÑÿ™ÿπÿßŸÖŸÑ ŸÖÿπ ÿßŸÑŸÉÿ≥Ÿàÿ± ŸàÿßŸÑÿ£ÿπÿØÿßÿØ ÿßŸÑÿπÿ¥ÿ±Ÿäÿ© ŸàÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©.</p>
                </div>`,
            "ÿßŸÑÿ£ÿ≥ÿ≥ ŸàÿßŸÑÿ¨ÿ∞Ÿàÿ±": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ£ÿ≥ÿ≥ ŸàÿßŸÑÿ¨ÿ∞Ÿàÿ±</h3>
                    <p>ÿ™ÿ∞ŸÉÿ± ŸÇŸàÿßŸÜŸäŸÜ ÿßŸÑÿ£ÿ≥ÿ≥ ŸàŸÉŸäŸÅŸäÿ© ÿ•Ÿäÿ¨ÿßÿØ ÿßŸÑÿ¨ÿ∞Ÿàÿ± ÿßŸÑÿ™ÿ±ÿ®ŸäÿπŸäÿ© ŸÑŸÑŸÖÿ±ÿ®ÿπÿßÿ™ ÿßŸÑŸÉÿßŸÖŸÑÿ©.</p>
                </div>`,
            "ÿßŸÑÿ™ŸÜÿßÿ≥ÿ®": `
                <div class="math-content-item">
                    <h3>ÿßŸÑÿ™ŸÜÿßÿ≥ÿ®</h3>
                    <p>ÿ™ÿ∞ŸÉÿ± ÿßŸÑŸÅÿ±ŸÇ ÿ®ŸäŸÜ ÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿ∑ÿ±ÿØŸä (ÿßŸÑŸÇÿ≥ŸÖÿ© ÿ´ÿßÿ®ÿ™ÿ©) ŸàÿßŸÑÿ™ŸÜÿßÿ≥ÿ® ÿßŸÑÿπŸÉÿ≥Ÿä (ÿßŸÑÿ∂ÿ±ÿ® ÿ´ÿßÿ®ÿ™).</p>
                </div>`
        };

        let currentSubTopic = "ÿßŸÑŸáŸÜÿØÿ≥ÿ©"; // ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ± ÿßŸÑÿ¨ÿØŸäÿØ ŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿßŸÑŸÅÿ±ÿπŸä ÿßŸÑÿØŸÇŸäŸÇ ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ©
        let currentQuestionUnit = "ÿßŸÑŸáŸÜÿØÿ≥ÿ©"; // ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä

        mathHelpBtn.addEventListener('click', () => {
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿßŸÑŸÅÿ±ÿπŸä ÿßŸÑÿØŸÇŸäŸÇ ŸÑŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ≠ÿßŸÑŸä
            // ŸÜÿ∏ÿßŸÖ ÿ≠ŸÖÿßŸäÿ©: ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ™ŸàŸÅÿ± ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿßŸÑŸÅÿ±ÿπŸäÿå ÿ¨ÿ±ÿ® ÿßŸÑŸàÿ≠ÿØÿ© ÿßŸÑÿπÿßŸÖÿ©ÿå ÿ´ŸÖ ÿßŸÑŸáŸÜÿØÿ≥ÿ© ŸÉÿÆŸäÿßÿ± ÿ£ÿÆŸäÿ±
            const helpContent = mathHelpDatabase[currentSubTopic] || 
                                mathHelpDatabase[currentQuestionUnit] || 
                                mathHelpDatabase["ÿßŸÑŸáŸÜÿØÿ≥ÿ©"];
            mathModalContent.innerHTML = helpContent;
            
            mathModal.style.display = 'block';
            mathOverlay.style.display = 'block';
            
            // ÿ•ÿÆÿ®ÿßÿ± MathJax ÿ®ÿ£ŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ™ÿ∫Ÿäÿ± ŸÑŸäŸÇŸàŸÖ ÿ®ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ŸÅŸàÿ±ÿßŸã
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                MathJax.typesetPromise([mathModalContent]).catch((err) => console.log('MathJax error:', err));
            }
        });

        const hideMathModal = () => {
            mathModal.style.display = 'none';
            mathOverlay.style.display = 'none';
        };

        closeMathModal.addEventListener('click', hideMathModal);
        mathOverlay.addEventListener('click', hideMathModal);

        window.startGame = function() {
            console.log("üéÆ Game started!");
            // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ¢ŸÖŸÜ ÿßŸÑÿ¥ÿßŸÖŸÑ
            player.position.set(-250, 25, -250); // ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ŸàŸÖÿÆÿ™ÿ®ÿ± ÿ®ÿπŸäÿØ ÿ¨ÿØÿßŸã ÿπŸÜ ÿßŸÑŸÜŸáÿ±
            gameStarted = true;
            gameOver = false;
            score = 0;
            coinsCollected = 0;
            jumpVelocity = 0;
            isOnGround = true;
            startScreen.style.display = "none";
            scoreDisplay.style.display = "block";
            coinsDisplay.style.display = "block";
        };
        
        startGameBtn.addEventListener("click", () => {
            // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ¢ŸÖŸÜ ÿßŸÑÿ¥ÿßŸÖŸÑ
            player.position.set(-250, 25, -250); // ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ŸàŸÖÿÆÿ™ÿ®ÿ± ÿ®ÿπŸäÿØ ÿ¨ÿØÿßŸã ÿπŸÜ ÿßŸÑŸÜŸáÿ±
            player.rotation.set(0, 0, 0);
            camera.position.set(-240, 30, -240);
            camera.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0); // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ©
            isJumping = false;
            jumpVelocity = 0;
            isOnGround = true;
            startScreen.style.display = "none";
            scoreDisplay.style.display = "block";
            coinsDisplay.style.display = "block";
            sheepDisplay.style.display = "block";
            bombsDisplay.style.display = "block";
            crocodilesDisplay.style.display = "block";
            hivesDisplay.style.display = "block";
            eaglesDisplay.style.display = "block";
            snatchingEaglesDisplay.style.display = "block";
            healthIndicator.style.display = "block";
            roundIndicator.style.display = "block";
            laserSight.style.display = "block";
            buyHealthBtn.style.display = "block";

            gameStarted = true;
            spawnPlatforms();
            spawnNewSheeps();
            spawnWavesForRound();
            addCrocodilesToOasis();
            createClimbingHill(-50, -50, 15);
            
            updateUI();

            setupMouseControls();
            setupMultiTouchControls();
            setupJoystickControls();
            setupKeyboardControls();
        });

        window.addEventListener("resize", () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        window.onload = function() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            animate();
        };
    </script>

    <script>
    // --- ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÇŸÅÿ≤ ÿßŸÑŸÜŸÇŸä ŸàÿßŸÑŸÖÿßÿ° (ŸÜÿ≥ÿÆÿ© v19) ---
    window.addEventListener('load', function() {
        function initPureJump() {
            if (typeof THREE === 'undefined' || typeof scene === 'undefined' || typeof player === 'undefined') {
                setTimeout(initPureJump, 500);
                return;
            }

            // 1. ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÜŸáÿ± ŸàÿßŸÑÿµÿÆŸàÿ± - ŸÜŸáÿ± ÿØÿßÿ¶ÿ±Ÿä ÿ≠ŸàŸÑ ÿßŸÑÿ™ŸÑÿ©
            // ÿ•ŸÜÿ¥ÿßÿ° ŸÜŸáÿ± ÿØÿßÿ¶ÿ±Ÿä ÿ≠ŸàŸÑ ÿßŸÑÿ™ŸÑÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ RingGeometry
            const hillCenterX = -50;
            const hillCenterZ = -50;
            const riverInnerRadius = 40; // ŸÜÿµŸÅ ŸÇÿ∑ÿ± ÿØÿßÿÆŸÑŸä (ŸÇÿ±ÿ® ÿßŸÑÿ™ŸÑÿ©)
            // ÿßŸÑŸÇÿ∑ÿ± ÿßŸÑÿÆÿßÿ±ÿ¨Ÿä Ÿäÿ™ÿ∫Ÿäÿ± ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: 500 ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ´ÿßŸÜŸä ŸÅŸÇÿ∑ÿå Ÿà180 ŸÅŸä ÿ®ŸÇŸäÿ© ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™
            let riverOuterRadius = 180;
            if (typeof round !== 'undefined' && round === 2) {
                riverOuterRadius = 180;
            }
            
            const riverGeo = new THREE.RingGeometry(riverInnerRadius, riverOuterRadius, 64);
            const riverMat = new THREE.MeshStandardMaterial({ color: 0x0066ff, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
            const river = new THREE.Mesh(riverGeo, riverMat);
            river.rotation.x = -Math.PI / 2;
            river.position.set(hillCenterX, -0.4, hillCenterZ);
            scene.add(river);

            window.riverRocks = [];
            // ÿ™Ÿàÿ≤Ÿäÿπ ÿßŸÑÿµÿÆŸàÿ± ÿπŸÑŸâ ÿ¥ŸÉŸÑ ÿ¨ÿ≥ÿ± ŸÖÿ≥ÿ™ŸÇŸäŸÖ ŸÖŸÜ ÿßŸÑÿ≠ÿßŸÅÿ© ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© ÿ•ŸÑŸâ ÿßŸÑÿØÿßÿÆŸÑŸäÿ©
            const jumpDistance = 15; // ÿßŸÑŸÖÿ≥ÿßŸÅÿ© ÿßŸÑÿ£ŸÅŸÇŸäÿ© ÿßŸÑŸÇÿµŸàŸâ ŸÑŸÑŸÇŸÅÿ≤ (ÿ™ŸÇÿØŸäÿ± ŸÖÿ≠ÿ≥Ÿàÿ®)
            const rockSpacing = jumpDistance * 1.2; // ÿ™ŸÖ ÿ™ÿµÿ∫Ÿäÿ± ÿßŸÑŸÖÿ≥ÿßŸÅÿ© ÿ®ŸäŸÜ ÿßŸÑÿµÿÆŸàÿ± ŸÑÿ™ŸÉŸàŸÜ ÿ£ŸÉÿ´ÿ± ÿ™ŸÇÿßÿ±ÿ®ÿßŸã ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            const MAX_ROCKS = 10; // ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑÿπÿØÿØ ÿßŸÑÿµÿÆŸàÿ±
            
            // ÿ™ÿ≠ÿØŸäÿØ ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ®ÿØÿßŸäÿ© (ÿßŸÑÿ≠ÿßŸÅÿ© ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ©) ŸàŸÜŸÇÿ∑ÿ© ÿßŸÑŸÜŸáÿßŸäÿ© (ÿßŸÑÿ≠ÿßŸÅÿ© ÿßŸÑÿØÿßÿÆŸÑŸäÿ©)
            // ÿ≥ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿ≤ÿßŸàŸäÿ© ÿ´ÿßÿ®ÿ™ÿ© (ŸÖÿ´ŸÑ 0) ŸÑÿ™ÿ≠ÿØŸäÿØ ÿÆÿ∑ ŸÖÿ≥ÿ™ŸÇŸäŸÖ ÿπŸÑŸâ ŸÖÿ≠Ÿàÿ± X
            const startRadius = riverOuterRadius - 1; // ŸÇÿ±Ÿäÿ® ŸÖŸÜ ÿßŸÑÿ≠ÿßŸÅÿ© ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ©
            const endRadius = riverInnerRadius + 1; // ŸÇÿ±Ÿäÿ® ŸÖŸÜ ÿßŸÑÿ≠ÿßŸÅÿ© ÿßŸÑÿØÿßÿÆŸÑŸäÿ©
            
            // ÿ≠ÿ≥ÿßÿ® ÿπÿØÿØ ÿßŸÑÿµÿÆŸàÿ± ÿßŸÑŸÑÿßÿ≤ŸÖÿ© ŸÑŸÖÿØ ÿßŸÑÿ¨ÿ≥ÿ±
            const totalDistance = startRadius - endRadius;
            const rocksNeeded = Math.min(MAX_ROCKS, Math.floor(totalDistance / rockSpacing) + 1);
            
            // ÿ™ÿ≠ÿØŸäÿØ ÿ≤ÿßŸàŸäÿ© ÿ´ÿßÿ®ÿ™ÿ© ŸÑŸÑÿ¨ÿ≥ÿ± (ŸÖÿ´ŸÑÿßŸã 45 ÿØÿ±ÿ¨ÿ©)
            const bridgeAngle = Math.PI / 4; 
            
            for (let i = 0; i < rocksNeeded; i++) {
                // ÿ≠ÿ≥ÿßÿ® ŸÜÿµŸÅ ÿßŸÑŸÇÿ∑ÿ± ŸÑŸÉŸÑ ÿµÿÆÿ±ÿ©
                const currentRadius = startRadius - (i * rockSpacing);
                
                // ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿ≤ÿßŸàŸäÿ© ŸàŸÜÿµŸÅ ÿßŸÑŸÇÿ∑ÿ± ŸÖÿπ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÜÿ≠ÿ±ÿßŸÅ ÿπÿ¥Ÿàÿßÿ¶Ÿä ŸÑÿ¨ÿπŸÑŸáÿß ÿ∫Ÿäÿ± ŸÖŸÜÿ™ÿ∏ŸÖÿ©
                const randomOffset = (Math.random() - 0.5) * 0.5; // ÿßŸÜÿ≠ÿ±ÿßŸÅ ÿ®ÿ≥Ÿäÿ∑ ŸÅŸä ÿßŸÑÿ≤ÿßŸàŸäÿ©
                const currentAngle = bridgeAngle + randomOffset;
                const rockX = hillCenterX + Math.cos(currentAngle) * currentRadius;
                const rockZ = hillCenterZ + Math.sin(currentAngle) * currentRadius;
                
                // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿµÿÆÿ±ÿ©
                const rockSize = 4 + Math.random() * 2; // Get the size here
                const rGeo = new THREE.DodecahedronGeometry(rockSize, 0);
                const rMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const r = new THREE.Mesh(rGeo, rMat);
                const rockHeightScale = 0.1; // Revert to flatter look
                r.position.set(rockX, 0.0, rockZ); // Position them low, just above water
                r.scale.y = rockHeightScale;
                r.userData = {
                    isRock: true,
                    radius: rockSize, // Effective radius for horizontal collision
                    topY: 0.0 + (rockSize * rockHeightScale) / 2 // Top surface Y position (Updated for flatter look)
                };
                scene.add(r);
                window.riverRocks.push(r);
            }

            // 2. ŸÖŸÜÿ∑ŸÇ ÿßŸÑŸÇŸÅÿ≤ ÿßŸÑŸÇŸàŸä ŸàÿßŸÑŸÖÿ≥ÿ™ÿ¨Ÿäÿ®
            document.addEventListener("keydown", e => { 
                if(e.code === 'Space') {
                    e.preventDefault();
                    window.startCharging();
                }
            });
            document.addEventListener('keyup', e => { 
                if(e.code === 'Space') {
                    e.preventDefault();
                    window.stopCharging();
                }
            });
            const jBtn = document.getElementById('jumpBtn');
            if (jBtn) {
                jBtn.onmousedown = function(e) { e.preventDefault(); window.startCharging(); };
                jBtn.onmouseup = function(e) { e.preventDefault(); window.stopCharging(); };
                jBtn.ontouchstart = function(e) { e.preventDefault(); window.startCharging(); };
                jBtn.ontouchend = function(e) { e.preventDefault(); window.stopCharging(); };
            }

            // 3. ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ° ŸàŸÖŸÜÿπ ÿßŸÑŸÖÿ¥Ÿä ÿπŸÑŸâ ÿßŸÑŸÖÿßÿ°
            const originalAnimate = window.animate;
            window.animate = function(t) {
                if (typeof gameStarted !== 'undefined' && gameStarted && !gameOver) {
                    // ÿßŸÑŸÇŸÅÿ≤
                    if (window.isJumping) {
                        player.position.y += window.jumpVelocity;
                        window.jumpVelocity -= GRAVITY;
                        if (player.position.y <= 1.2) {
                            player.position.y = 1.2;
                            window.isJumping = false;
                            window.jumpVelocity = 0;
                        }
                    }

                    // ÿßŸÑŸÖÿßÿ° (ÿßŸÑÿ≥ŸÇŸàÿ∑ ÿßŸÑÿ≠ŸÇŸäŸÇŸä)
                    const p = player.position;
                    if (p.z < -25 && p.z > -115) {
                        let onRock = false;
                        for (let r of window.riverRocks) {
                            const d = Math.sqrt((p.x-r.position.x)**2 + (p.z-r.position.z)**2);
                            if (d < 7) { onRock = true; break; }
                        }
                        if (!onRock && !window.isJumping) {
                            // ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ≥ŸÇŸàÿ∑ ÿßŸÑÿ≥ÿ±Ÿäÿπ
                            if (false) { // ÿ™ÿπÿ∑ŸäŸÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿπŸäŸäŸÜ ÿπŸÜÿØ -2
                                playerHealth -= 5;
                                updateUI();
                                // ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÑÿßÿπÿ® ŸÑŸÑŸäÿßÿ®ÿ≥ÿ© ÿ•ÿ∞ÿß ÿ∫ÿ±ŸÇ ÿ™ŸÖÿßŸÖÿßŸã
                                // p.set(200, 1.2, 200); // ŸÖŸàŸÇÿπ ÿ¢ŸÖŸÜ ÿ®ÿπŸäÿØ ÿπŸÜ ÿßŸÑŸÜŸáÿ± (ÿßŸÑŸÜŸáÿ± ÿ≠ŸàŸÑ -50, -50) // ÿ™ÿπÿ∑ŸäŸÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä
                            }
                        }
                    }
                }
                originalAnimate(t);
            };
        }
        initPureJump();
    });
    </script>


    <script>
    // --- ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖŸÇÿ∞ŸàŸÅÿßÿ™ ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸä (ŸÜÿ≥ÿÆÿ© v20) ---
    window.addEventListener('load', function() {
        function initProjectileJump() {
            if (typeof THREE === 'undefined' || typeof scene === 'undefined' || typeof player === 'undefined') {
                setTimeout(initProjectileJump, 500);
                return;
            }

            // 1. ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ° ŸÑŸÑŸÖŸÇÿ∞ŸàŸÅÿßÿ™
            window.isJumping = false;
            window.vVel = 0; // ÿßŸÑÿ≥ÿ±ÿπÿ© ÿßŸÑÿ±ÿ£ÿ≥Ÿäÿ©
            window.hVel = { x: 0, z: 0 }; // ÿßŸÑÿ≥ÿ±ÿπÿ© ÿßŸÑÿ£ŸÅŸÇŸäÿ©
            const GRAVITY = 0.045; // ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ© ŸÑÿ¨ÿπŸÑ ÿßŸÑŸÇŸÅÿ≤ÿ© ÿ£ŸÇÿµÿ± Ÿàÿ£ŸÉÿ´ÿ± ÿ•ÿ≠ŸÉÿßŸÖÿßŸã
            const JUMP_FORCE = 0.85; // ŸÇŸàÿ© ŸÇŸÅÿ≤ ÿπŸÖŸàÿØŸäÿ© ŸÖÿ™Ÿàÿ≥ÿ∑ÿ© ŸÑŸÑÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿØŸÇŸäŸÇ
            const HORIZONTAL_BOOST = 0.5; // ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑÿØŸÅÿπ ÿßŸÑÿ£ŸÅŸÇŸä ÿ®ÿ¥ŸÉŸÑ ŸÉÿ®Ÿäÿ± ŸÑŸÖŸÜÿπ ÿßŸÑÿßŸÜÿØŸÅÿßÿπ ÿßŸÑÿ≤ÿßÿ¶ÿØ

            window.triggerProjectileJump = function() {
                if (!window.isJumping && gameStarted && !gameOver) {
                    window.isJumping = true;
                    window.vVel = JUMP_FORCE;
                    
                    // ÿ≠ÿ≥ÿßÿ® ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸÇŸÅÿ≤ÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ≠ÿßŸÑŸäÿ© (velocity)
                    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÑÿßÿπÿ® Ÿäÿ™ÿ≠ÿ±ŸÉÿå ŸÜŸÖŸÜÿ≠Ÿá ÿØŸÅÿπÿ© ÿ£ŸÅŸÇŸäÿ© ŸÖÿ™ŸÜÿßÿ≥ÿ®ÿ© ŸÖÿπ ÿ≥ÿ±ÿπÿ™Ÿá ÿßŸÑÿ≠ÿßŸÑŸäÿ©
                    if (typeof velocity !== 'undefined') {
                        // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ≥ÿ±ÿπÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸÖÿπ Ÿàÿ∂ÿπ ÿ≠ÿØ ÿ£ŸÇÿµŸâ ŸÑŸÑÿßŸÜÿØŸÅÿßÿπ
                        const maxJumpSpeed = 0.4;
                        window.hVel.x = Math.max(-maxJumpSpeed, Math.min(maxJumpSpeed, velocity.x * HORIZONTAL_BOOST));
                        window.hVel.z = Math.max(-maxJumpSpeed, Math.min(maxJumpSpeed, velocity.z * HORIZONTAL_BOOST));
                    } else {
                        window.hVel.x = 0;
                        window.hVel.z = 0;
                    }
                }
            };

            // ÿ±ÿ®ÿ∑ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±
            document.addEventListener('keydown', e => { if(e.code === 'Space') window.triggerProjectileJump(); });
            const jBtn = document.getElementById('jumpBtn');
            if (jBtn) jBtn.onclick = window.triggerProjectileJump;

            // 2. ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿ®ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖŸÇÿ∞ŸàŸÅÿßÿ™
            const originalAnimate = window.animate;
            window.animate = function(t) {
                if (typeof gameStarted !== 'undefined' && gameStarted && !gameOver) {
                    if (window.isJumping) {
                        // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ±ÿ£ÿ≥Ÿäÿ© (ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ©)
                        player.position.y += window.vVel;
                        window.vVel -= GRAVITY;

                        // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ£ŸÅŸÇŸäÿ© (ÿßŸÑŸÖŸÇÿ∞ŸàŸÅ)
                        player.position.x += window.hVel.x;
                        player.position.z += window.hVel.z;

                        // ÿßŸÑŸáÿ®Ÿàÿ∑
                        if (player.position.y <= 1.2) {
                            player.position.y = 1.2;
                            window.isJumping = false;
                            window.vVel = 0;
                            window.hVel = { x: 0, z: 0 };
                        }
                    }
                }
                originalAnimate(t);
            };
        }
        initProjectileJump();
    });
    </script>


    

<script>
// ==========================================
// ÿ≠ŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ v30: ŸÅŸäÿ≤Ÿäÿßÿ° ÿßŸÑÿ∫ÿ±ŸÇ ÿßŸÑÿ≠ŸÇŸäŸÇŸäÿ©
// ==========================================
(function() {
    const check = setInterval(() => {
        if (typeof THREE !== 'undefined' && typeof player !== 'undefined' && typeof riverRocks !== 'undefined') {
            clearInterval(check);
            
            // ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÖŸÜ ÿ≠ŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            window.verticalVelocity = 0;
            const gravity = 0.008;
            const waterDensity = 0.02;
            window.jumpState = { active: false };

            // ÿØÿßŸÑÿ© ÿßŸÑŸÇŸÅÿ≤ ÿßŸÑŸäÿØŸàŸä
            window.executeJump = function() {
                const playerBottom = player.position.y - 1;
                if (!window.jumpState.active && window.gameStarted && playerBottom >= 0.1) {
                    window.verticalVelocity = 0.25; // ŸÇŸàÿ© ŸÇŸÅÿ≤ÿ© ŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÑŸÑÿπÿ®ÿ©
                    window.jumpState.active = true;
                    
                    // ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ÿ±ŸÉÿ© ÿ£ŸÅŸÇŸäÿ© ŸÑŸÑŸÇŸÅÿ≤ÿ©
                    window.jumpState.hVel = { x: 0, z: 0 };
                    if (window.keys) {
                        if (keys['ArrowUp'] || keys['w']) window.jumpState.hVel.z = -0.3;
                        if (keys['ArrowDown'] || keys['s']) window.jumpState.hVel.z = 0.3;
                        if (keys['ArrowLeft'] || keys['a']) window.jumpState.hVel.x = -0.3;
                        if (keys['ArrowRight'] || keys['d']) window.jumpState.hVel.x = 0.3;
                    }
                }
            };

            window.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); executeJump(); } });
            const jBtn = document.getElementById('jumpBtn');
            if (jBtn) jBtn.onmousedown = jBtn.ontouchstart = (e) => { e.preventDefault(); executeJump(); };

            // ÿ≠ŸÑŸÇÿ© ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ° ÿßŸÑŸÖÿØŸÖÿ¨ÿ© (ŸÖŸÜÿ∑ŸÇ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ + ŸÖŸÜÿ∑ŸÇ ÿßŸÑŸÑÿπÿ®ÿ©)
            const oldAnimate = window.animate;
            window.animate = function(t) {
                if (window.gameStarted && !window.gameOver) {
                    
                    const playerBottom = player.position.y - 1;
                                        // ÿ™ÿ≠ÿØŸäÿØ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÜŸáÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜŸáÿ± ŸàŸÜÿµŸÅ ÿßŸÑŸÇÿ∑ÿ±
                    const hillCenterX = -50;
                    const hillCenterZ = -50;
                    const riverInnerRadius = 40; // ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                    const riverOuterRadius = 180; // ÿ™ŸÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (180 ŸÇÿ∑ÿ±)
                    const distanceToCenter = Math.sqrt((player.position.x - hillCenterX) ** 2 + (player.position.z - hillCenterZ) ** 2);
                    const overRiver = (distanceToCenter >= riverInnerRadius && distanceToCenter <= riverOuterRadius);
                    let onRock = false;
                    for (let r of riverRocks) {
                        if (player.position.distanceTo(r.position) < 6) { onRock = true; break; }
                    }

                    // ŸÅŸäÿ≤Ÿäÿßÿ° ÿßŸÑÿ∫ÿ±ŸÇ ÿßŸÑÿ¨ÿØŸäÿØÿ© (ÿßŸÑÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑŸÖÿ≠ÿ≥ŸÜÿ©)
                    // ÿ™ÿ≠ÿØŸäÿØ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÑÿßÿπÿ® ŸÅŸä ÿßŸÑŸÖÿßÿ°
                    const wasInWater = window.isInWater || false;
                    
                    // ŸÖŸÜÿ∑ŸÇ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ™Ÿàÿßÿ¨ÿØ ŸÅŸä ÿßŸÑŸÖÿßÿ° - ŸÖÿ™ŸàÿßŸÅŸÇ ŸÖÿπ ÿßŸÑÿ•ÿµŸÑÿßÿ≠ ÿßŸÑÿ¨ÿØŸäÿØ
                    const hillCenterX_water = -50;
                    const hillCenterZ_water = -50;
                    const riverInnerRadius_water = 40;
                    const riverOuterRadius_water = 180;
                    const distToCenter_water = Math.sqrt((player.position.x - hillCenterX_water) ** 2 + (player.position.z - hillCenterZ_water) ** 2);
                    
                    if (distToCenter_water >= riverInnerRadius_water && distToCenter_water <= riverOuterRadius_water && !onRock && player.position.y < 0.5) {
                        window.isInWater = true;
                    } else {
                        window.isInWater = false;
                    }
                    
                    if (overRiver && !onRock) {
                        // ÿ™ŸÜÿ®ŸäŸá ÿßŸÑŸÖŸäÿßŸá ÿßŸÑÿ≥ÿßŸÖÿ©
                        const alertEl = document.getElementById('toxicAlert');
                        if (window.isInWater) {
                            if (alertEl) alertEl.style.display = 'block';
                            
                            // ÿµŸàÿ™ ÿ™ŸÜÿ®ŸäŸá ÿ®ÿ≥Ÿäÿ∑ ÿπŸÜÿØ ÿßŸÑÿØÿÆŸàŸÑ ŸÑÿ£ŸàŸÑ ŸÖÿ±ÿ©
                            if (!wasInWater) {
                                try {
                                    if (typeof playSound === 'function') {
                                        playSound(440, 'sine', 0.2, 0.1);
                                    } else {
                                        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                                        const oscillator = audioCtx.createOscillator();
                                        const gainNode = audioCtx.createGain();
                                        oscillator.connect(gainNode);
                                        gainNode.connect(audioCtx.destination);
                                        oscillator.type = 'sine';
                                        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                                        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                                        oscillator.start();
                                        oscillator.stop(audioCtx.currentTime + 0.2);
                                    }
                                } catch(e) {}
                            }

                            // ÿØÿßÿÆŸÑ ÿßŸÑŸÖÿßÿ° - ÿ∫ÿ±ŸÇ ÿ™ÿØÿ±Ÿäÿ¨Ÿä
                            // ÿ∫ÿ±ŸÇ ÿ™ÿØÿ±Ÿäÿ¨Ÿä ŸÅŸä ÿßŸÑŸÖÿßÿ°
                            window.verticalVelocity -= gravity * 0.5; // ÿ¨ÿßÿ∞ÿ®Ÿäÿ© ŸÖÿÆŸÅŸÅÿ© ŸÅŸä ÿßŸÑŸÖÿßÿ°
                            
                            // ŸÖŸÇÿßŸàŸÖÿ© ÿßŸÑŸÖÿßÿ° (ÿ™ÿ≤ŸäÿØ ÿπŸÜÿØŸÖÿß ÿ™ŸÉŸàŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ© ÿπÿßŸÑŸäÿ©)
                            window.verticalVelocity *= (1 - waterDensity * Math.abs(window.verticalVelocity));
                            
                            // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑÿπŸÖŸàÿØŸäÿ©
                            player.position.y += window.verticalVelocity;
                            
                            // ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑÿµÿ≠ÿ© ÿ™ÿØÿ±Ÿäÿ¨ŸäÿßŸã ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ∫ÿ±ŸÇ
                            if (typeof playerHealth !== 'undefined' && player.position.y < 0) {
                                playerHealth -= 0.3; // ÿÆÿ≥ÿßÿ±ÿ© ÿµÿ≠ÿ© ŸÖÿ≥ÿ™ŸÖÿ±ÿ©
                                if (typeof updateUI === 'function') updateUI();
                            }
                            
                            // ÿ™ÿ≠ÿØŸäÿØ ÿπŸÖŸÇ ÿ£ŸÇÿµŸâ ÿ™ÿ≠ÿ™ ÿßŸÑŸÖÿßÿ°
                            const maxDepth = -4;
                            if (player.position.y < maxDepth) {
                                // ÿ≠ÿ≥ÿßÿ® ÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ≠ÿßŸÅÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÖŸàŸÇÿπ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ≠ÿßŸÑŸä ÿ®ÿßŸÑŸÜÿ≥ÿ®ÿ© ŸÑŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜŸáÿ±
                                const dx = player.position.x - (-50);
                                const dz = player.position.z - (-50);
                                const angle = Math.atan2(dz, dx);
                                const safeRadius = 190; // ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜŸáÿ± ŸÇŸÑŸäŸÑÿßŸã (ÿßŸÑŸÜŸáÿ± ŸäŸÜÿ™ŸáŸä ÿπŸÜÿØ 180)
                                
                                const safeX = -50 + Math.cos(angle) * safeRadius;
                                const safeZ = -50 + Math.sin(angle) * safeRadius;
                                
                                player.position.set(safeX, 1.2, safeZ); // Ÿàÿ∂ÿπŸá ÿπŸÜÿØ ÿ£ŸÇÿ±ÿ® ÿ≠ÿßŸÅÿ© ÿ¢ŸÖŸÜÿ©
                                window.verticalVelocity = 0;
                                window.jumpState.active = false;
                                
                                // ÿÆÿ≥ÿßÿ±ÿ© ÿµÿ≠ÿ© ŸÉÿ®Ÿäÿ±ÿ© ÿπŸÜÿØ ÿßŸÑÿ∫ÿ±ŸÇ ÿßŸÑŸÉÿßŸÖŸÑ
                                if (typeof playerHealth !== 'undefined') {
                                    playerHealth -= 30;
                                    if (typeof updateUI === 'function') updateUI();
                                    if (playerHealth <= 0) {
                                        if (typeof gameOver !== 'undefined') window.gameOver = true;
                                        if (typeof showGameOver === 'function') showGameOver();
                                    }
                                }
                                // ÿØÿπŸÖ ŸÖÿ™ÿ∫Ÿäÿ± health ÿßŸÑŸÇÿØŸäŸÖ
                                if (typeof health !== 'undefined') {
                                    health -= 30;
                                    if (typeof updateHealthBar === 'function') updateHealthBar();
                                    if (health <= 0 && typeof endGame === 'function') endGame();
                                }
                            }
                        } else {
                            // ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÖÿßÿ° (ŸÅŸàŸÇ ÿ≥ÿ∑ÿ≠ ÿßŸÑŸÖÿßÿ°) - ÿ≥ŸÇŸàÿ∑ ÿ≠ÿ±
                            window.verticalVelocity -= gravity; // ÿ¨ÿßÿ∞ÿ®Ÿäÿ© ÿπÿßÿØŸäÿ©
                            player.position.y += window.verticalVelocity;
                        }
                                         // ÿ™ÿ£ÿ´Ÿäÿ± ÿØÿÆŸàŸÑ/ÿÆÿ±Ÿàÿ¨ ÿßŸÑŸÖÿßÿ° (ÿ™ÿ∫ŸäŸäÿ± ÿ∑ŸÅŸäŸÅ ŸÅŸä ÿßŸÑÿ≥ÿ±ÿπÿ©)
                        if (wasInWater !== window.isInWater) {
                            window.verticalVelocity *= 0.7; // ÿ™ÿÆŸÅŸäŸÅ ÿßŸÑÿ≥ÿ±ÿπÿ© ÿπŸÜÿØ ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ
                        }
                    } else {
                        // ÿπŸÑŸâ ÿßŸÑŸäÿßÿ®ÿ≥ÿ© ÿ£Ÿà ÿßŸÑÿµÿÆŸàÿ±
                        const alertEl = document.getElementById('toxicAlert');
                        if (alertEl) alertEl.style.display = 'none';        player.position.y += window.verticalVelocity;
                            player.position.x += (window.jumpState.hVel?.x || 0);
                            player.position.z += (window.jumpState.hVel?.z || 0);

                            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÑÿ©
                            const hillCheck = isInsideHill(player.position, false);
                            let targetY = 0; // ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© ŸÑŸÑÿ£ÿ±ÿ∂ ŸáŸä 0
                            
                            // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÑÿßÿπÿ® ŸÅŸä ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ™ŸÑÿ© ÿßŸÑŸÖÿ±ŸÉÿ≤Ÿäÿ© (ÿØÿßÿÆŸÑ ÿßŸÑŸÜŸáÿ±)
                            if (distToCenter_water < riverInnerRadius_water) {
                                targetY = 1.2; // ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑŸÇÿßÿπÿØÿ© ÿßŸÑŸÖÿ±ŸÉÿ≤Ÿäÿ©
                            }
                            
                            if (onRock) targetY = 0.2;

                            if (hillCheck) {
                                targetY = hillCheck.playerSurfaceY; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿØŸÇŸäŸÇ ŸÖŸÜ isInsideHill
                            }

                            // ŸÅÿ≠ÿµ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ŸÖÿπ ÿßŸÑÿ£ÿ¨ÿ≥ÿßŸÖ ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿßŸÑÿ∞Ÿáÿßÿ® ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿ•ŸÑŸâ targetY
                            if (player.position.y <= targetY) {
                                let collisionDetected = false;
                                let finalY = targetY;
                                
                                // ŸÅÿ≠ÿµ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ŸÖÿπ ÿßŸÑÿµÿÆŸàÿ±
                                if (window.riverRocks) {
                                    for (let r of window.riverRocks) {
                                        const rockData = r.userData;
                                        const horizontalDistance = Math.sqrt(
                                            (player.position.x - r.position.x) ** 2 + 
                                            (player.position.z - r.position.z) ** 2
                                        );
                                        // Check if player is horizontally on the rock and vertically above or on it
                                        if (horizontalDistance < rockData.radius * 0.5 && player.position.y >= rockData.topY - 0.5) {
                                            collisionDetected = true;
                                            finalY = rockData.topY; // ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿµÿÆÿ±ÿ©
                                            break;
                                        }
                                    }
                                }
                                
                                // ŸÅÿ≠ÿµ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ŸÖÿπ ÿßŸÑÿ™ŸÑÿßŸÑ
                                if (!collisionDetected && hillCheck) {
                                    collisionDetected = true;
                                    finalY = hillCheck.playerSurfaceY;
                                }
                                
                                // ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸáŸÜÿßŸÉ ÿßÿµÿ∑ÿØÿßŸÖÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ targetY ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
                                player.position.y = finalY;
                                window.verticalVelocity = 0;
                                window.jumpState.active = false;
                                
                                // ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ŸÖÿπ ÿßŸÑÿ£ÿ¨ÿ≥ÿßŸÖ ÿßŸÑÿ£ÿÆÿ±Ÿâ (ŸÖÿ´ŸÑ ÿßŸÑÿ∞ÿ¶ÿßÿ® ŸàÿßŸÑÿ™ŸÖÿßÿ≥Ÿäÿ≠)
                                // Ÿáÿ∞ÿß Ÿäÿ∂ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÑÿßÿπÿ® ŸäŸÖŸÉŸÜŸá ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ŸáŸÖ ŸÅŸàÿ± ÿßŸÑŸáÿ®Ÿàÿ∑
                                if (typeof checkCollisions === 'function') {
                                    checkCollisions();
                                }
                            }
                        } else {
                            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÑÿ©
                            const hillCheck = isInsideHill(player.position, false);
                            let targetY = 0;
                            
                            if (distToCenter_water < riverInnerRadius_water) {
                                targetY = 1.2;
                            }
                            
                            if (onRock) targetY = 0.2;

                            if (hillCheck) {
                                targetY = hillCheck.playerSurfaceY; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿØŸÇŸäŸÇ ŸÖŸÜ isInsideHill
                            }

                            player.position.y = targetY;
                            window.verticalVelocity = 0;
                        }
                    }
                }
                if (oldAnimate) oldAnimate(t);
            };
        }
    }, 100);
})();
</script>
<!-- ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿßŸÑŸÖŸÉÿ±ÿ± - Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿßŸÑÿ£ÿµŸÑŸä ŸÅŸä ÿßŸÑÿ≥ÿ∑ÿ± 1469 -->

<!-- ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ŸÑŸàÿ≠ÿ© ÿßŸÑÿµÿØÿßÿ±ÿ© ÿßŸÑŸÖŸÉÿ±ÿ±ÿ© - Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÑŸàÿ≠ÿ© ÿßŸÑÿµÿØÿßÿ±ÿ© ÿßŸÑÿ£ÿµŸÑŸäÿ© ŸÅŸä ÿßŸÑÿ≥ÿ∑ÿ± 1478 -->

</body></html>
